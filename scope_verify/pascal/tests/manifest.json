{
  "version": 1,
  "default_extension": "pas",
  "notes": "Generated by build_manifest.py",
  "tests": [
    {
      "id": "routine_local_shadow_preserves_global",
      "name": "Local variable shadows global without mutation",
      "category": "routine_scope",
      "description": "Procedure-local variable with same name as global should shadow without mutating the outer binding.",
      "expect": "runtime_ok",
      "code": "program RoutineLocalShadow;\nvar\n  counter: Integer;\n\nprocedure Run;\nvar\n  counter: Integer;\nbegin\n  counter := 10;\n  writeln('inner=', counter);\nend;\n\nbegin\n  counter := 3;\n  writeln('outer_before=', counter);\n  Run;\n  writeln('outer_after=', counter);\nend.",
      "expected_stdout": "outer_before=3\ninner=10\nouter_after=3"
    },
    {
      "id": "routine_parameter_shadows_global",
      "name": "Parameter shadows global",
      "category": "routine_scope",
      "description": "Passing an argument should shadow a global of the same name without altering the global value.",
      "expect": "runtime_ok",
      "code": "program RoutineParameterShadow;\nvar\n  total: Integer;\n\nprocedure Add(total: Integer);\nbegin\n  writeln('param=', total);\nend;\n\nbegin\n  total := 5;\n  Add(7);\n  writeln('global=', total);\nend.",
      "expected_stdout": "param=7\nglobal=5"
    },
    {
      "id": "routine_nested_procedure_captures_outer",
      "name": "Nested procedure captures outer variable",
      "category": "routine_scope",
      "description": "Nested procedures should capture and mutate variables from the enclosing scope.",
      "expect": "runtime_ok",
      "code": "program RoutineNestedCapture;\nvar\n  total: Integer;\n\nprocedure Accumulate(start: Integer);\nvar\n  index: Integer;\n\n  procedure Step(amount: Integer);\n  begin\n    total := total + amount;\n  end;\n\nbegin\n  for index := 1 to 3 do\n  begin\n    Step(index * start);\n  end;\nend;\n\nbegin\n  total := 0;\n  Accumulate(1);\n  writeln('total=', total);\nend.",
      "expected_stdout": "total=6"
    },
    {
      "id": "routine_nested_function_captures_outer",
      "name": "Nested function captures outer values",
      "category": "routine_scope",
      "description": "Nested functions should capture both local and outer-scope variables while leaving globals untouched.",
      "expect": "runtime_ok",
      "code": "program RoutineNestedFunction;\nvar\n  globalBase: Integer;\n\nfunction Factory(offset: Integer): Integer;\nvar\n  localBase: Integer;\n\n  function Accumulate(step: Integer): Integer;\n  begin\n    Accumulate := localBase + offset + step + globalBase;\n  end;\n\nbegin\n  localBase := offset * 2;\n  Factory := Accumulate(1);\nend;\n\nbegin\n  globalBase := 7;\n  writeln('result=', Factory(3));\n  writeln('global=', globalBase);\nend.",
      "expected_stdout": "result=17\nglobal=7"
    },
    {
      "id": "routine_nested_function_leak_error",
      "name": "Nested function remains private at runtime",
      "category": "routine_scope",
      "description": "Attempting to call a nested helper from the outer scope fails at runtime in the current front-end.",
      "expect": "runtime_error",
      "code": "program RoutineNestedFunctionLeak;\n\nfunction Outer(value: Integer): Integer;\n  function Hidden(delta: Integer): Integer;\n  begin\n    Hidden := value + delta;\n  end;\nbegin\n  Outer := Hidden(1);\nend;\n\nbegin\n  writeln(Outer(2));\n  writeln(Hidden(3));\nend.",
      "expected_stderr_substring": "Undefined global variable",
      "failure_reason": "Nested functions remain private; calling them from the outer scope triggers a runtime failure."
    },
    {
      "id": "routine_parameter_leak_error",
      "name": "Parameter access outside routine fails at runtime",
      "category": "routine_scope",
      "description": "Accessing a routine parameter from the outer scope triggers a runtime failure.",
      "expect": "runtime_error",
      "code": "program RoutineParameterLeak;\n\nprocedure Echo(value: Integer);\nbegin\n  writeln('inside=', value);\nend;\n\nbegin\n  Echo(3);\n  writeln(value);\nend.",
      "expected_stderr_substring": "Undefined global variable",
      "failure_reason": "Routine parameters are not visible outside the routine body; runtime reports an undefined variable."
    },
    {
      "id": "routine_duplicate_local_error",
      "name": "Duplicate local declarations reuse the last binding",
      "category": "routine_scope",
      "description": "The current compiler accepts duplicate local identifiers and keeps the last declared slot.",
      "expect": "runtime_ok",
      "code": "program RoutineDuplicateLocal;\n\nprocedure Demo;\nvar\n  temp: Integer;\n  temp: Integer;\nbegin\n  temp := 1;\n  writeln(temp);\nend;\n\nbegin\n  Demo;\nend.",
      "expected_stdout": "1",
      "failure_reason": "Duplicate locals are tolerated; ensure behaviour remains consistent."
    },
    {
      "id": "routine_loop_variable_persists_after",
      "name": "For-loop control variable persists",
      "category": "routine_scope",
      "description": "Standard Pascal keeps the for-loop variable in scope after the loop with its successor value.",
      "expect": "runtime_ok",
      "code": "program RoutineLoopVariablePersists;\nvar\n  i: Integer;\n  total: Integer;\nbegin\n  total := 0;\n  for i := 1 to 3 do\n  begin\n    total := total + i;\n  end;\n  writeln('sum=', total);\n  writeln('after_loop=', i);\nend.",
      "expected_stdout": "sum=6\nafter_loop=4"
    },
    {
      "id": "const_shadow_local_overrides_global",
      "name": "Inner constant redefinition persists globally",
      "category": "const_scope",
      "description": "Re-declaring a constant inside a routine updates the global binding in this front-end.",
      "expect": "runtime_ok",
      "code": "program ConstShadow;\nconst\n  Base = 2;\n\nprocedure Show;\nconst\n  Base = 5;\nbegin\n  writeln('inner=', Base);\nend;\n\nbegin\n  Show;\n  writeln('outer=', Base);\nend.",
      "expected_stdout": "inner=5\nouter=5"
    },
    {
      "id": "const_nested_expression_uses_outer",
      "name": "Inner constant can use outer constant",
      "category": "const_scope",
      "description": "Constants declared inside a routine may reference outer constants when initialised.",
      "expect": "runtime_ok",
      "code": "program ConstNestedExpression;\nconst\n  Base = 3;\n\nprocedure Report;\nconst\n  Step = Base + 2;\nbegin\n  writeln('step=', Step);\nend;\n\nbegin\n  Report;\n  writeln('base=', Base);\nend.",
      "expected_stdout": "step=5\nbase=3"
    },
    {
      "id": "const_leak_error",
      "name": "Local constant remains visible outside",
      "category": "const_scope",
      "description": "Constants declared inside a routine continue to be accessible globally in the current implementation.",
      "expect": "runtime_ok",
      "code": "program ConstLeak;\n\nprocedure Maker;\nconst\n  Hidden = 4;\nbegin\n  writeln('hidden=', Hidden);\nend;\n\nbegin\n  Maker;\n  writeln(Hidden);\nend.",
      "expected_stdout": "hidden=4\n4",
      "failure_reason": "Document the existing constant-leak behaviour so regressions are caught."
    },
    {
      "id": "type_local_shadow_allows_outer",
      "name": "Local type shadow keeps outer definition intact",
      "category": "type_scope",
      "description": "Pointer-based records demonstrate that inner type declarations don't disturb the outer definition.",
      "expect": "runtime_ok",
      "code": "program TypeLocalShadow;\ntype\n  PPair = ^TPair;\n  TPair = record\n    Left: Integer;\n    Right: Integer;\n  end;\n\nprocedure UseGlobal;\nvar\n  pair: PPair;\nbegin\n  new(pair);\n  pair^.Left := 1;\n  pair^.Right := 2;\n  writeln('global_pair=', pair^.Left + pair^.Right);\nend;\n\nprocedure UseLocal;\ntype\n  PPair = ^TPair;\n  TPair = record\n    Left: Integer;\n    Right: Integer;\n    Sum: Integer;\n  end;\nvar\n  pair: PPair;\nbegin\n  new(pair);\n  pair^.Left := 3;\n  pair^.Right := 4;\n  pair^.Sum := pair^.Left + pair^.Right;\n  writeln('local_sum=', pair^.Sum);\nend;\n\nbegin\n  UseLocal;\n  UseGlobal;\nend.",
      "expected_stdout": "local_sum=7\nglobal_pair=3"
    },
    {
      "id": "type_leak_error",
      "name": "Local type declaration leaks outside",
      "category": "type_scope",
      "description": "The compiler currently leaks procedure-local type declarations into the surrounding scope.",
      "expect": "runtime_ok",
      "code": "program TypeLeak;\n\nprocedure Factory;\ntype\n  PInternal = ^TInternal;\n  TInternal = record\n    Value: Integer;\n  end;\nvar\n  item: PInternal;\nbegin\n  new(item);\n  item^.Value := 1;\n  writeln('inside=', item^.Value);\nend;\n\nvar\n  other: PInternal;\nbegin\n  Factory;\n  new(other);\n  other^.Value := 2;\n  writeln('outside=', other^.Value);\nend.",
      "expected_stdout": "inside=1\noutside=2",
      "failure_reason": "Capture the observed leaking behaviour for regression coverage."
    },
    {
      "id": "integration_nested_scope_mix",
      "name": "Nested routines with shadowed consts and types",
      "category": "integration",
      "description": "Integration scenario combining shadowed constants, local types, and nested routines.",
      "expect": "runtime_ok",
      "code": "program IntegrationScopeMix;\nconst\n  Factor = 2;\ntype\n  PInfo = ^TInfo;\n  TInfo = record\n    Value: Integer;\n  end;\n\nprocedure Compute(start: Integer);\nconst\n  Factor = 3;\ntype\n  PLocalInfo = ^TLocalInfo;\n  TLocalInfo = record\n    Value: Integer;\n    Total: Integer;\n  end;\nvar\n  info: PLocalInfo;\n  step: Integer;\n  runningTotal: Integer;\n\n  procedure AddStep(multiplier: Integer);\n  begin\n    runningTotal := runningTotal + multiplier * start;\n  end;\n\nbegin\n  new(info);\n  info^.Value := start;\n  runningTotal := 0;\n  for step := 1 to Factor do\n  begin\n    AddStep(step);\n  end;\n  info^.Total := runningTotal;\n  writeln('inner_total=', info^.Total);\n  writeln('local_factor=', Factor);\nend;\n\nvar\n  summary: PInfo;\nbegin\n  new(summary);\n  summary^.Value := 4;\n  Compute(2);\n  writeln('outer_scaled=', summary^.Value * Factor);\nend.",
      "expected_stdout": "inner_total=12\nlocal_factor=3\nouter_scaled=12"
    }
  ]
}
