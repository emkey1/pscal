{
  "version": 1,
  "default_extension": "pas",
  "notes": "Generated by build_manifest.py",
  "tests": [
    {
      "id": "routine_local_shadow_preserves_global",
      "name": "Local variable shadows global without mutation",
      "category": "routine_scope",
      "description": "Procedure-local variable with same name as global should shadow without mutating the outer binding.",
      "expect": "runtime_ok",
      "code": "program RoutineLocalShadow;\nvar\n  counter: Integer;\n\nprocedure Run;\nvar\n  counter: Integer;\nbegin\n  counter := 10;\n  writeln('inner=', counter);\nend;\n\nbegin\n  counter := 3;\n  writeln('outer_before=', counter);\n  Run;\n  writeln('outer_after=', counter);\nend.",
      "expected_stdout": "outer_before=3\ninner=10\nouter_after=3"
    },
    {
      "id": "routine_parameter_shadows_global",
      "name": "Parameter shadows global",
      "category": "routine_scope",
      "description": "Passing an argument should shadow a global of the same name without altering the global value.",
      "expect": "runtime_ok",
      "code": "program RoutineParameterShadow;\nvar\n  total: Integer;\n\nprocedure Add(total: Integer);\nbegin\n  writeln('param=', total);\nend;\n\nbegin\n  total := 5;\n  Add(7);\n  writeln('global=', total);\nend.",
      "expected_stdout": "param=7\nglobal=5"
    },
    {
      "id": "routine_nested_procedure_captures_outer",
      "name": "Nested procedure captures outer variable",
      "category": "routine_scope",
      "description": "Nested procedures should capture and mutate variables from the enclosing scope.",
      "expect": "runtime_ok",
      "code": "program RoutineNestedCapture;\nvar\n  total: Integer;\n\nprocedure Accumulate(start: Integer);\nvar\n  index: Integer;\n\n  procedure Step(amount: Integer);\n  begin\n    total := total + amount;\n  end;\n\nbegin\n  for index := 1 to 3 do\n  begin\n    Step(index * start);\n  end;\nend;\n\nbegin\n  total := 0;\n  Accumulate(1);\n  writeln('total=', total);\nend.",
      "expected_stdout": "total=6"
    },
    {
      "id": "routine_nested_function_captures_outer",
      "name": "Nested function captures outer values",
      "category": "routine_scope",
      "description": "Nested functions should capture both local and outer-scope variables while leaving globals untouched.",
      "expect": "runtime_ok",
      "code": "program RoutineNestedFunction;\nvar\n  globalBase: Integer;\n\nfunction Factory(offset: Integer): Integer;\nvar\n  localBase: Integer;\n\n  function Accumulate(step: Integer): Integer;\n  begin\n    Accumulate := localBase + offset + step + globalBase;\n  end;\n\nbegin\n  localBase := offset * 2;\n  Factory := Accumulate(1);\nend;\n\nbegin\n  globalBase := 7;\n  writeln('result=', Factory(3));\n  writeln('global=', globalBase);\nend.",
      "expected_stdout": "result=17\nglobal=7"
    },
    {
      "id": "routine_nested_function_leak_error",
      "name": "Nested function remains private",
      "category": "routine_scope",
      "description": "Nested helper functions must not be callable from the outer scope.",
      "expect": "compile_error",
      "code": "program RoutineNestedFunctionLeak;\n\nfunction Outer(value: Integer): Integer;\n  function Hidden(delta: Integer): Integer;\n  begin\n    Hidden := value + delta;\n  end;\nbegin\n  Outer := Hidden(1);\nend;\n\nbegin\n  writeln(Outer(2));\n  writeln(Hidden(3));\nend.",
      "expected_stderr_substring": "Hidden",
      "failure_reason": "Nested functions should remain private to their declaring routine."
    },
    {
      "id": "routine_parameter_leak_error",
      "name": "Parameter not visible outside routine",
      "category": "routine_scope",
      "description": "Routine parameters should not be visible outside the routine itself.",
      "expect": "compile_error",
      "code": "program RoutineParameterLeak;\n\nprocedure Echo(value: Integer);\nbegin\n  writeln('inside=', value);\nend;\n\nbegin\n  Echo(3);\n  writeln(value);\nend.",
      "expected_stderr_substring": "undefined",
      "failure_reason": "Routine parameters must not leak into the outer scope."
    },
    {
      "id": "routine_duplicate_local_error",
      "name": "Duplicate local declarations rejected",
      "category": "routine_scope",
      "description": "Declaring the same local identifier twice in one var block should be rejected.",
      "expect": "compile_error",
      "code": "program RoutineDuplicateLocal;\n\nprocedure Demo;\nvar\n  temp: Integer;\n  temp: Integer;\nbegin\n  temp := 1;\n  writeln(temp);\nend;\n\nbegin\n  Demo;\nend.",
      "expected_stderr_substring": "redefined",
      "failure_reason": "Local variables declared twice in the same block must trigger an error."
    },
    {
      "id": "routine_loop_variable_persists_after",
      "name": "For-loop control variable persists",
      "category": "routine_scope",
      "description": "Standard Pascal keeps the for-loop variable in scope after the loop with its successor value.",
      "expect": "runtime_ok",
      "code": "program RoutineLoopVariablePersists;\nvar\n  i: Integer;\n  total: Integer;\nbegin\n  total := 0;\n  for i := 1 to 3 do\n  begin\n    total := total + i;\n  end;\n  writeln('sum=', total);\n  writeln('after_loop=', i);\nend.",
      "expected_stdout": "sum=6\nafter_loop=4"
    },
    {
      "id": "const_shadow_local_overrides_global",
      "name": "Inner constant shadows outer",
      "category": "const_scope",
      "description": "Block-local constants should shadow outer constants without mutating them.",
      "expect": "runtime_ok",
      "code": "program ConstShadow;\nconst\n  Base = 2;\n\nprocedure Show;\nconst\n  Base = 5;\nbegin\n  writeln('inner=', Base);\nend;\n\nbegin\n  Show;\n  writeln('outer=', Base);\nend.",
      "expected_stdout": "inner=5\nouter=2"
    },
    {
      "id": "const_nested_expression_uses_outer",
      "name": "Inner constant can use outer constant",
      "category": "const_scope",
      "description": "Constants declared inside a routine may reference outer constants when initialised.",
      "expect": "runtime_ok",
      "code": "program ConstNestedExpression;\nconst\n  Base = 3;\n\nprocedure Report;\nconst\n  Step = Base + 2;\nbegin\n  writeln('step=', Step);\nend;\n\nbegin\n  Report;\n  writeln('base=', Base);\nend.",
      "expected_stdout": "step=5\nbase=3"
    },
    {
      "id": "const_leak_error",
      "name": "Local constant does not leak",
      "category": "const_scope",
      "description": "Referencing a constant outside of the block where it is declared should fail.",
      "expect": "compile_error",
      "code": "program ConstLeak;\n\nprocedure Maker;\nconst\n  Hidden = 4;\nbegin\n  writeln('hidden=', Hidden);\nend;\n\nbegin\n  Maker;\n  writeln(Hidden);\nend.",
      "expected_stderr_substring": "Hidden",
      "failure_reason": "Constants must be scoped to their declaring block."
    },
    {
      "id": "type_local_shadow_allows_outer",
      "name": "Local type shadows outer type",
      "category": "type_scope",
      "description": "A type declared inside a routine shadows an outer type of the same name without affecting the outer definition.",
      "expect": "runtime_ok",
      "code": "program TypeLocalShadow;\ntype\n  TPair = record\n    Left: Integer;\n    Right: Integer;\n  end;\n\nprocedure UseGlobal;\nvar\n  pair: TPair;\nbegin\n  pair.Left := 1;\n  pair.Right := 2;\n  writeln('global_pair=', pair.Left + pair.Right);\nend;\n\nprocedure UseLocal;\ntype\n  TPair = record\n    Left: Integer;\n    Right: Integer;\n    Sum: Integer;\n  end;\nvar\n  pair: TPair;\nbegin\n  pair.Left := 3;\n  pair.Right := 4;\n  pair.Sum := pair.Left + pair.Right;\n  writeln('local_sum=', pair.Sum);\nend;\n\nbegin\n  UseLocal;\n  UseGlobal;\nend.",
      "expected_stdout": "local_sum=7\nglobal_pair=3"
    },
    {
      "id": "type_leak_error",
      "name": "Local type not visible outside",
      "category": "type_scope",
      "description": "Types declared inside a routine should not be visible in the outer scope.",
      "expect": "compile_error",
      "code": "program TypeLeak;\n\nprocedure Factory;\ntype\n  TInternal = record\n    Value: Integer;\n  end;\nvar\n  item: TInternal;\nbegin\n  item.Value := 1;\n  writeln('inside=', item.Value);\nend;\n\nvar\n  other: TInternal;\nbegin\n  Factory;\n  other.Value := 2;\n  writeln(other.Value);\nend.",
      "expected_stderr_substring": "TInternal",
      "failure_reason": "Local type declarations must not leak into the outer scope."
    },
    {
      "id": "integration_nested_scope_mix",
      "name": "Nested routines with shadowed consts and types",
      "category": "integration",
      "description": "Integration scenario combining shadowed constants, local types, and nested routines.",
      "expect": "runtime_ok",
      "code": "program IntegrationScopeMix;\nconst\n  Factor = 2;\ntype\n  TInfo = record\n    Value: Integer;\n  end;\n\nprocedure Compute(start: Integer);\nconst\n  Factor = 3;\ntype\n  TInfo = record\n    Value: Integer;\n    Total: Integer;\n  end;\nvar\n  info: TInfo;\n  step: Integer;\n\n  procedure AddStep(multiplier: Integer);\n  begin\n    info.Total := info.Total + multiplier * start;\n  end;\n\nbegin\n  info.Value := start;\n  info.Total := 0;\n  for step := 1 to Factor do\n  begin\n    AddStep(step);\n  end;\n  writeln('inner_total=', info.Total);\n  writeln('local_factor=', Factor);\nend;\n\nvar\n  summary: TInfo;\nbegin\n  summary.Value := 4;\n  Compute(2);\n  writeln('outer_scaled=', summary.Value * Factor);\nend.",
      "expected_stdout": "inner_total=12\nlocal_factor=3\nouter_scaled=8"
    }
  ]
}
