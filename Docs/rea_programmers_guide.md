# Rea Programmer's Guide

## Preface

This guide explains how to build, extend, and use the Rea front end for the PSCAL virtual machine. It is aimed at engineers who need to work on the compiler, author standard library code, or ship applications in Rea. Read it alongside the language specification (`Docs/rea_language_reference.md`), the overview (`Docs/rea_overview.md`), and the implementation notes in `src/rea/README.md`. Those documents capture design intent; this guide focuses on day-to-day workflows, examples, and practical maintenance tips.

## 1. Getting Started

### 1.1 Repository Layout

Rea shares the repository with the other PSCAL front ends. The most relevant directories are:

- `src/rea` – lexer, parser, semantic passes, and glue into the shared compiler pipeline.
- `Docs/rea_*.md` – language overview, tutorial, and supporting reference material.
- `Examples/rea` – runnable samples (console and SDL) that double as regression fixtures.
- `Tests/rea` – focused unit and integration tests that execute compiled bytecode.
- `Tests/scope_verify/rea` – manifest-driven harness for module and name-resolution behaviours.
- `rea-obj` – cached bytecode artefacts generated by the compiler during development.

### 1.2 Toolchain Requirements

Rea builds with the same prerequisites as the rest of PSCAL:

- C11-capable compiler (clang or GCC recommended).
- CMake 3.24 or newer.
- libcurl for networking helpers.
- Optional: SDL2 or SDL3 with the matching SDL_image/SDL_mixer/SDL_ttf add-ons for graphics samples.
- Python 3.9+ to run the scope harness and manifest tooling.

### 1.3 Building the Rea Front End

Configure the project from the repository root and enable optional components as needed:

```sh
cmake -S . -B build -DSDL=ON         # add -DBUILD_DASCAL=ON if you also need the Pascal CLI
cmake --build build --target rea     # builds build/bin/rea
```

The compiler reuses the shared VM and installer. To install the toolchain globally, run `cmake --install build` after building (use `sudo` when writing to system locations). Reconfigure with `-DSDL=OFF` for headless environments.

### 1.4 Running Rea Programs

The front end accepts individual files or directories containing an entry point:

```sh
build/bin/rea path/to/program.rea
build/bin/rea Examples/rea/base/hello
```

Files in `Examples/rea` are executable scripts with a `#!/usr/bin/env rea` shebang, so they can also be launched directly. Key compiler flags:

- `--dump-ast-json` – emit the parsed AST as JSON and exit.
- `--dump-bytecode` – print the compiled bytecode before running it.
- `--dump-bytecode-only` – compile, dump bytecode, and exit without executing.
- `--dump-ext-builtins` – dump extended builtin inventory.
- `--no-run` – compile without running to perform static analysis or bytecode inspection.
- `--vm-trace-head=N` – trace the first `N` VM instructions.
- `--no-cache` – ignore cached `.rea.obj` artifacts in `rea-obj/`.
- `--strict` – enable stricter top-level parsing.

Inside source files, add `trace on` to enable a short instruction trace without CLI options. Combine these tools to isolate compiler and runtime issues quickly.

## 2. Language Tour

### 2.1 Lexical Structure

Rea uses familiar C-like tokens with a few twists:

- Single-line comments start with `//`. When placed between expressions the same token acts as integer division, so prefer `//` comments at the start of a statement or after punctuation.
- Multi-line comments use `/* ... */` and can nest logically by pairing opening and closing markers.
- Identifiers are case-sensitive and must begin with a letter or `_`.
- Reserved keywords cover types (`int`, `float`, `str`, `bool`, `mstream`, ...), object constructs (`class`, `new`, `extends`, `my`, `myself`, `super`), and control flow (`if`, `while`, `switch`, `return`).
- Preprocessor-style directives currently only include `#import` for module loading.

### 2.2 Types and Values

Primitive types map directly onto VM representations. The compiler defaults to 64-bit integers and doubles when no suffix is supplied.

| Keyword       | VM Type           | Notes |
| ------------- | ----------------- | ----- |
| `int`         | `TYPE_INT64`      | Default integer width. |
| `int32`       | `TYPE_INT32`      | Legacy 32-bit integers. |
| `int16`       | `TYPE_INT16`      | 16-bit values (e.g. buffers). |
| `int8` / `byte` | `TYPE_INT8`     | Fits in a single byte. |
| `float`       | `TYPE_DOUBLE`     | IEEE 754 double precision. |
| `float32`     | `TYPE_FLOAT`      | 32-bit floats. |
| `long double` | `TYPE_LONG_DOUBLE`| Extended precision, platform dependent. |
| `char`        | `TYPE_CHAR`       | 8-bit character. |
| `str` / `string` | `TYPE_STRING`  | Dynamically sized string. |
| `text`        | `TYPE_FILE`       | File handle, compatible with VM streams. |
| `mstream`     | `TYPE_MSTREAM`    | In-memory stream for buffered IO. |
| `bool`        | `TYPE_BOOLEAN`    | `true` or `false`. |
| `void`        | `TYPE_VOID`       | Procedures that return no value. |

Numeric literals follow C rules (decimal, hex `0x`, binary `0b`, with optional exponents). Character and string literals share the same escape sequences as the other PSCAL languages (`\n`, `\t`, `\x41`, etc.).

### 2.3 Expressions and Operators

Arithmetic operators include `+`, `-`, `*`, `/`, `//` (floor division), and `%`. Bitwise XOR is available through `^` or the `xor` keyword. Comparison operators (`==`, `!=`, `<`, `<=`, `>`, `>=`) and logical operators (`&&`, `||`, `!`) behave like their C counterparts. The compiler emits the VM's `TO_BOOL` opcode for logical results, so boolean expressions always collapse to canonical `TRUE`/`FALSE` values.

Assignment comes in both simple (`=`) and compound (`+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `&=`, `|=`, `^=`) forms. Member access uses the dot operator (`object.field`).

### 2.4 Control Flow

Rea supports familiar structured control flow:

- `if`/`else` conditionals with block or single-statement bodies.
- `while`, `do ... while`, and C-style `for` loops.
- `switch` statements with `case`, `default`, `break`, and `continue`.
- Early exit via `return`, plus `break`/`continue` within loops.

Labeled `switch` statements compile into jump tables when possible, matching the behaviour of the Pascal and C-like front ends.

### 2.5 Functions and Procedures

Top-level functions declare a return type and parameter list. Procedures use `void` as the return type. Parameters are passed by value.

```rea
int add(int a, int b) {
  return a + b;
}

void logLine(str label, int value) {
  writeln(label, value);
}
```

Functions can appear at the top level or inside modules (see Section 4). Methods follow the same syntax but live inside class blocks (Section 3).

## 3. Object-Oriented Programming in Rea

### 3.1 Classes, Fields, and Methods

Classes package fields and methods together. Each instance stores its own fields; methods receive an implicit receiver accessible as `my` or `myself`.

```rea
class Counter {
  int n;

  void inc() {
    myself.n = myself.n + 1;
  }

  int set(int v) {
    myself.n = v;
    return myself.n;
  }
}

Counter c = new Counter();
c.set(3);
writeln("c=", c.n);
```

This example comes from `Examples/rea/base/method_demo` and demonstrates direct field access alongside method calls on both existing variables and `new` expressions.

### 3.2 Constructors and Initialization

A method that shares the class name acts as a constructor. It may accept parameters, perform side effects, and must be invoked through `new`.

```rea
class Window {
  int width;
  int height;

  void Window(int w, int h) {
    myself.width = w;
    myself.height = h;
  }
}

Window mainWindow = new Window(640, 480);
```

Constructors do not declare a return type. The compiler ensures that every code path either calls `return;` (without a value) or reaches the final brace.

### 3.3 Inheritance and `super`

Rea implements single inheritance via `extends`. Call `super(...)` inside a constructor to delegate to the parent, and use `super.method()` to invoke overridden behaviour.

```rea
class Dog extends Animal {
  str breed;

  void Dog(str name, int age, str dogBreed) {
    super(name, age);
    myself.breed = dogBreed;
  }

  void speak() {
    writeln(myself.name, " barks loudly.");
    super.speak();
  }
}
```

The inheritance example in `Examples/rea/base/inheritance_and_constructor` expands on this pattern and shows that subclasses can access inherited fields directly.

### 3.4 Dynamic Dispatch and V-Tables

Every class contributes a virtual method table (V-table). When a method is called on an object, the compiler emits a lookup through the receiver's V-table to resolve the correct implementation. This mirrors the Pascal and C-like behaviour, keeping builtin IDs stable across front ends.

When extending the compiler:

- Ensure semantic analysis records method offsets consistently. Helper routines in `src/rea/semantic.c` maintain V-table order.
- Keep push/pop pairs balanced when working with global compiler state to avoid leaking the current class context.
- Add regression tests under `Tests/rea` when modifying dispatch. The `rea-method-dispatch-runtime.md` notebook in `Docs/` captures outstanding investigation notes and is a good place to document new findings.

## 4. Modules and Imports

### 4.1 Declaring Modules

Modules package related declarations and control their public surface:

```rea
module ModPublic {
  export const int VALUE = 12;

  export int getValue() {
    return VALUE;
  }

  const int hiddenHelper = 99;
}
```

This snippet (from the scope harness manifest) declares a module named `ModPublic` with two exported members and one private constant.

### 4.2 Exporting Members

Use `export` on functions, methods, or constants to expose them to importers. Fields without `export` remain private to the module. Exports are stored in the module's symbol table during semantic analysis, and missing exports raise compile-time errors when referenced from other modules.

### 4.3 Importing Modules with `#import`

Load modules with `#import "relative/path.rea"` at the top level. Add `as Alias` to qualify the import:

```rea
#import "modules/mod_alias_base.rea" as DataModule;

int main() {
  writeln("local=", answer());
  writeln("qualified=", DataModule.answer());
  return 0;
}
```

Imports are resolved relative to the including file. The compiler caches loaded modules, so repeated `#import` directives do not reload the same file. Name clashes between two modules that export the same unqualified symbol trigger diagnostics (see `module_conflicting_import_error` in the scope manifest).

### 4.4 Module Testing Patterns

The scope harness (`Tests/scope_verify/rea/rea_scope_test_harness.py`) materialises module fixtures from its manifest and validates visibility, aliasing, and transitive exports. Use it when changing module semantics:

```sh
python3 Tests/scope_verify/rea/rea_scope_test_harness.py \
    --manifest Tests/scope_verify/rea/tests/manifest.json --only module_
```

Passing `--update` regenerates the concrete `.rea` files under `Tests/scope_verify/rea/tests/modules/` to keep fixtures in sync with the manifest.

## 5. Working with the PSCAL VM

### 5.1 Built-in Functions and IO

Rea inherits the PSCAL VM's builtin catalog. Core functions include:

- Text IO: `writeln`, `write`, `readln`, `printf`.
- String utilities: `length`, `copy`, `pos`, `concat`.
- Math helpers: `abs`, `sqrt`, `sin`, `cos`, `random`.
- System calls: `getpid`, `dosExec`, `sleep`.

Reference `Docs/extended_builtins.md` for the full list and argument conventions. Builtins are registered in a stable order, so always append new entries when extending the dispatcher.

### 5.2 Extended Built-ins and SDL Support

When built with `-DSDL=ON`, Rea gains access to the same SDL helpers as the Pascal front end (`InitGraph3D`, `GLClear`, `GLPerspective`, etc.). The SDL bouncing balls samples in `Examples/rea/sdl/` demonstrate window creation, rendering loops, and the `BouncingBalls3DStepUltraAdvanced` physics helper.

Set the following environment variables for headless or automated runs:

```sh
export SDL_VIDEODRIVER=dummy
export SDL_AUDIODRIVER=dummy
export RUN_SDL=1          # enable SDL suites in the test harness
```

If optional JSON support (yyjson) or other extended libraries are unavailable, the Rea test runner honours `REA_TEST_EXT_BUILTINS=0` and `REA_TEST_HAS_YYJSON=0` to skip unsupported checks.

### 5.3 Interfacing with Other Front Ends

All PSCAL front ends emit the same bytecode format, so VM libraries written in Pascal or C-like can be consumed from Rea once compiled. Keep shared modules in dedicated directories and document their calling conventions. Use the bytecode dumper to confirm that mixed-language components agree on symbol names and call signatures.

## 6. Concurrency and Advanced Runtime Features

### 6.1 Threads and Synchronization

Lightweight threads mirror the Pascal runtime. The `spawn` builtin launches a function on a new VM thread, `join` waits for completion, and `mutex`/`lock`/`unlock` guard critical sections.

```rea
int counter = 0;
int m = mutex();

void worker() {
  for (int i = 0; i < 5; i = i + 1) {
    lock(m);
    counter = counter + 1;
    writeln("counter=", counter);
    unlock(m);
  }
}

int main() {
  int t1 = spawn worker();
  int t2 = spawn worker();
  join t1;
  join t2;
  writeln("final counter=", counter);
  return 0;
}
```

See `Examples/rea/base/threads` for the full program and additional commentary.

### 6.2 Async Patterns and External Services

Higher-level async patterns are built from the primitives above. Examples include:

- Network access via `httpGet` and friends (`Examples/rea/base/openai_chat_demo`; the earlier `openweather_forecast` script remains available in the repository history if you need a weather API template).
- Background computation using `spawn` with a shared queue, guarded by mutexes.
- Timed loops that combine `sleep` with SDL frame updates in `Examples/rea/sdl/multibouncingballs`.

When composing async workflows, document ownership of shared resources and ensure every `lock` has a matching `unlock`, even along exceptional paths.

## 7. Diagnostics and Tooling

### 7.1 Compiler Flags and Tracing

Use the CLI switches described in Section 1.4 during compiler development. Additional helper tips:

- `--no-run` compiles without executing, useful for bytecode inspection or compile-only CI checks.
- Embed `trace on` comments to trigger tracing near complicated sections without editing CLI arguments.
- Combine `--dump-ast-json` with `jq` to visualise parse trees.

### 7.2 Bytecode Inspection and VM Tracing

`--dump-bytecode` prints disassembled output annotated with offsets. For deeper analysis, run the resulting `.obj` through `build/bin/pscald` (built by enabling `BUILD_PSCALD` during configuration). To capture canonical disassembly, execute `Tests/run_rea_tests.sh` against fixtures that provide `.disasm` expectations or invoke `build/bin/rea --dump-bytecode-only` directly on the sources under investigation. The VM trace (`--vm-trace-head=N`) is invaluable when hunting control-flow regressions or verifying module initialisation order.

### 7.3 Logging and Error Reporting

Compiler diagnostics report line numbers and a short description. Common categories include:

- Parse errors (`Expected '}' to close module body.`) emitted from `parser.c`.
- Semantic errors such as duplicate aliases or private-member access, raised in `semantic.c`.
- Runtime panics (null dereferences, stack underflow) surfaced by the VM; these include instruction pointers to aid debugging.

Wrap new diagnostics in unit tests under `Tests/rea` or the scope harness to prevent regressions.

## 8. Testing and Quality Assurance

### 8.1 Unit and Regression Suites

`Tests/run_rea_tests.sh` exercises the curated suite under `Tests/rea`. Each test folder includes `.rea` sources, expected stdout (`.out`), optional stderr substrings (`.err`), and CLI argument files (`.args`). Run the suite before submitting compiler changes:

```sh
Tests/run_rea_tests.sh --only short_circuit
```

### 8.2 Scope Verification Harness

The scope harness (Section 4.4) provides deeper coverage for modules, closures, and name resolution rules. It is slower than the unit suite but catches many semantic edge cases. Keep `Tests/scope_verify/rea/tests/manifest.json` up to date when language rules change.

### 8.3 Adding New Tests

1. Create a new `.rea` source and supporting fixtures under `Tests/rea` or the scope harness manifest.
2. Capture expected outputs using `--dump-bytecode` or `--dump-bytecode-only` when necessary.
3. Update manifests via `python3 Tests/scope_verify/rea/tests/build_manifest.py`.
4. Document the scenario in the test file comments for future maintainers.

## 9. Recipes and Examples

### 9.1 Hello World and CLI Utilities

`Examples/rea/base/hello` is the canonical hello-world script. Each example includes a shebang so it can be executed directly after `cmake --install` publishes the interpreter shim.

### 9.2 Object-Oriented Patterns

Explore `Examples/rea/base/method_demo`, `inheritance_and_constructor`, and `polymorphism` for idiomatic class usage, constructor chaining, and method overriding.

### 9.3 Graphics and SDL Samples

`Examples/rea/sdl/multibouncingballs` and the `*_3d` variants demonstrate 2D and 3D rendering, event processing, and interaction with the extended SDL builtins. These programs double as regression tests for the graphics pipeline.

### 9.4 Data and External Integrations

`Examples/rea/base/sqlite_spotify_demo` shows how to call VM-provided database helpers, while `openai_chat_demo` highlights HTTP integrations powered by libcurl and the extended OpenAI-compatible helpers. The previous `openweather_forecast` sample is kept in the project history if you prefer the weather-service walkthrough as a starting point. Treat these programs as templates when binding additional services.

## 10. Maintenance and Contribution Workflow

### 10.1 Updating the Compiler

When touching the implementation in `src/rea`:

- Review existing globals before adding new ones; many helpers depend on push/pop stacks to restore compiler state.
- Update both the parser and semantic passes when introducing new syntax.
- Add regression coverage in `Tests/rea` and the scope harness.
- Keep `rea-obj/` caches in mind; either delete them or use `--no-cache` during debugging after grammar changes.

### 10.2 Documenting Language Changes

Extend this guide, the language reference, and the tutorial when adding surface features. Cross-link relevant sections so future contributors can discover updates quickly. Mention new environment variables or flags in release notes (`Docs/RELEASE_NOTES_*.md`).

### 10.3 Release Checklist

Before cutting a release candidate:

1. Build with and without SDL to ensure both configurations succeed.
2. Run `Tests/run_all_tests` or the targeted suites you modified.
3. Refresh cached examples if outputs changed (`Tests/scope_verify/... --update`).
4. Update documentation and changelog entries.
5. Tag the release and publish any new sample programs.

## Appendices

### A. Command-line Reference

- `build/bin/rea [options] <source>` – compile and run a program.
- `--dump-ast-json` – emit AST JSON and exit.
- `--dump-bytecode` – print bytecode before execution.
- `--dump-bytecode-only` – print bytecode and exit.
- `--dump-ext-builtins` – dump extended builtin inventory.
- `--vm-trace-head=N` – trace the first `N` VM instructions.
- `--no-cache` – ignore `rea-obj/` caches.
- `--strict` – enable stricter top-level parsing.
- `--no-run` – compile the program without launching the VM.

### B. Environment Variables

- `SDL_VIDEODRIVER`, `SDL_AUDIODRIVER` – select SDL backends for headless runs.
- `RUN_SDL` – opt into SDL tests.
- `RUN_NET_TESTS` – enable network-dependent suites in Tests/run_all_tests.
- `REA_TEST_EXT_BUILTINS` – advertise availability of optional builtin libraries.
- `REA_TEST_HAS_YYJSON` – signal JSON support to the Rea harness.
- `PSCAL_STRICT_VM` – enforce VM/bytecode version compatibility across all front ends.

### C. Error Messages and Troubleshooting

- **Parse errors**: Revisit the syntax near the reported line; unterminated modules and missing braces are common when editing large blocks.
- **Module resolution failures**: Confirm `#import` paths are relative to the importing file and that exported names are unique.
- **Runtime panics**: Use `--vm-trace-head` and `trace on` to locate the failing bytecode, then inspect the disassembly.
- **Cache confusion**: Remove `rea-obj/*.obj` or pass `--no-cache` when bytecode appears stale.

### D. Glossary

- **AST** – Abstract Syntax Tree produced by the parser.
- **Builtin** – Function implemented by the VM and callable from Rea.
- **Module** – Compilation unit wrapped in `module Name { ... }` with explicit exports.
- **V-table** – Per-class table of method pointers used for dynamic dispatch.
- **VM** – PSCAL virtual machine that executes bytecode emitted by all front ends.
