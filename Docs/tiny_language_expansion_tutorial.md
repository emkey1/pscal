# Tutorial: Expanding Tiny (CLike Compiler)

This guide explains how to add new language features to the Tiny compiler implemented in `bin/tiny.clike`.

It focuses on practical changes: tokenizer, parser, AST, and bytecode generation.

## Prerequisites

- You can already compile Tiny programs with:
  - `tiny source.tiny`
- You can inspect generated bytecode with:
  - `pscald source.pbc`

Recommended read first:

- `Docs/clike_tiny_compiler.md`

## Compiler Structure (Where To Edit)

`bin/tiny.clike` is organized in this order:

1. Utility helpers (`readFile`, `resolveRoot`, output path helpers)
2. Opcode/type loading (`loadOpcodes`, `loadTypeTags`, `opcode`)
3. Constant/code buffers (`addConstInt`, `addConstStr`, `emit`, `emitShort`)
4. Tokenizer (`tokenize`, token arrays)
5. Parser + AST node types (`parse*`, node arrays)
6. Semantic passes (`collectVars`)
7. Codegen (`compileExpr`, `compileStmt`, `compileProgram`)
8. Serialization (`writePbc`)

Most language extensions touch sections 4 through 7.

## Safe Workflow For New Features

1. Add syntax in `tokenize`.
2. Extend parser (`parseExpr`/`parseStatement` family).
3. Add new AST node kinds if needed.
4. Update codegen for new nodes/operators.
5. Compile a tiny sample and run `pscald` to verify opcode sequence.
6. Run with `pscalvm` and validate runtime behavior.

## Feature Ideas And How To Implement Them

## 1) Add `>` and `<=` comparisons

### What to change

- Tokenizer:
  - recognize `>` and optionally `<=`, `>=`, `<>`.
- Parser:
  - allow those operators in `parseExpr`.
- Codegen:
  - map operators to VM ops.

### Hint

If VM lacks direct `GREATER`/`LESS_EQUAL`, lower them:

- `a > b` => `b < a`
- `a <= b` => `!(b < a)` (or equivalent with available ops)

Use `pscald` to confirm the lowered sequence.

## 2) Add unary minus (`-x`)

### What to change

- Parser:
  - in `parseFactor` (or a new `parseUnary`), detect leading `-`.
- AST:
  - either add `N_UNARY` or rewrite as `0 - expr`.
- Codegen:
  - emit lowered subtraction if you choose rewrite.

### Hint

Lowest-risk approach is rewrite:

- parse `-expr` as `BinOp("-", Num(0), expr)`

No new VM opcode handling required.

## 3) Add `while ... do ... end`

### What to change

- Keywords:
  - add `while`, `do` in tokenizer keyword list.
- Parser:
  - add `parseWhile`.
- AST:
  - add node type `N_WHILE`.
- Codegen:
  - emit condition test + backward jump loop.

### Hint

Compile shape can mirror `repeat`:

- label start
- evaluate condition
- `JUMP_IF_FALSE` -> end
- body
- unconditional `JUMP` -> start
- end label

## 4) Add boolean literals (`true`, `false`)

### What to change

- Tokenizer:
  - treat as keywords (or identifiers with special-case).
- Parser:
  - parse into number-like node (`1`/`0`) or dedicated bool node.
- Codegen:
  - emit constants `1` and `0`.

### Hint

Tiny currently treats truth as integer. Reusing int constants keeps everything simple.

## 5) Add `mod`

### What to change

- Tokenizer:
  - make `mod` a keyword/operator token.
- Parser:
  - include in `parseTerm` precedence with `*` and `/`.
- Codegen:
  - emit a VM opcode if available; otherwise lower using division/multiply/subtract if possible.

### Hint

Check `src/compiler/bytecode.h` for an existing modulo opcode before lowering manually.

## 6) Add block comments or line comments

### What to change

- Tokenizer comment stripping currently removes `{ ... }`.
- Extend stripping logic for:
  - line comments (`// ...`)
  - block comments (`/* ... */`)

### Hint

Do this early in `tokenize` before token scanning loops.

## Parser And AST Tips

- Keep precedence explicit:
  - `parseExpr` (relational)
  - `parseSimpleExpr` (`+`, `-`)
  - `parseTerm` (`*`, `/`, maybe `mod`)
  - `parseFactor` (literals, vars, parens, unary)
- Use lowering when possible instead of introducing many new AST kinds.
- Keep errors strict with `consume(...)`; this avoids ambiguous parse states.

## Codegen Tips

- Reuse existing helper emitters:
  - `emitConst`
  - `emitGetGlobal`
  - `emitGetGlobalAddr`
- Prefer VM-native operations if available.
- When lowering operators, disassemble to ensure stack order is correct.

## Validation Checklist

- Parser accepts expected syntax and rejects malformed input.
- `pscald` output is structurally correct:
  - jumps target the right offsets
  - constants table is reasonable
- Runtime behavior in `pscalvm` matches language intent.
- Existing Tiny programs still compile and run unchanged.

## Suggested Test Cases Per Feature

- Comparison operators:
  - both true and false branches.
- Loops:
  - zero-iteration and multi-iteration.
- Unary minus:
  - nested expressions like `-(x + 1) * 2`.
- Booleans:
  - interaction with `if` and `until`.

## Keeping Python And CLike Tiny In Sync

If you also maintain `tools/tiny`:

- Apply feature changes to both frontends.
- Compare disassembly from both compilers on the same `.tiny` program.
- Prefer semantic parity over byte-for-byte identical instruction ordering.

## Future Bigger Steps

If you want to go beyond “Tiny classic”:

- scoped locals instead of globals
- procedures/functions
- typed declarations (`var x: integer`)
- strings and richer builtins

Those require larger parser/codegen redesign, but the same incremental workflow still works.
