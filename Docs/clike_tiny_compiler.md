# CLike Tiny Compiler

This document describes the Tiny compiler implemented in CLike (`bin/tiny.clike`) and the `tiny` wrapper (`bin/tiny`).

## Overview

PSCAL includes two Tiny compilers:

- `tools/tiny` (Python reference implementation)
- `bin/tiny.clike` (CLike implementation used in PSCAL environments where Python is not available)

The CLike compiler emits PSCAL VM bytecode (`.pbc`) that runs with `pscalvm`.

## Quick Start

Compile only (default):

```sh
tiny program.tiny
```

Compile and run immediately:

```sh
tiny --run program.tiny
```

Compile to an explicit output path:

```sh
tiny program.tiny out/program.pbc
```

Run bytecode manually:

```sh
pscalvm out/program.pbc
```

Disassemble bytecode:

```sh
pscald out/program.pbc
```

## `tiny` Wrapper Behavior

The `bin/tiny` wrapper is an exsh script and is the recommended entrypoint.

- Usage:
  - `tiny [--run] <source.tiny> [out.pbc]`
- If `bin/tiny.pbc` exists, wrapper runs:
  - `pscalvm bin/tiny.pbc <source> <out>`
- Otherwise, wrapper falls back to:
  - `clike bin/tiny.clike <source> <out>`
- Default output path (when not supplied):
  - `<current-working-directory>/<source-basename>.pbc`

Notes:

- `--run` runs the generated output file with `pscalvm` after successful compile.
- The wrapper normalizes source path with `realpath` when available.

## Direct `tiny.clike` Invocation

You can run the compiler directly:

```sh
clike bin/tiny.clike source.tiny [out.pbc]
```

Direct mode default output differs from wrapper mode:

- Direct `tiny.clike`: defaults to source-based path (`source.tiny` -> `source.pbc` beside source)
- `tiny` wrapper: defaults to current working directory

## Tiny Language Subset

The CLike Tiny compiler supports the classic Tiny subset:

- Statements:
  - assignment: `x := expr`
  - input: `read x`
  - output: `write expr` and `write` (no expression)
  - conditionals: `if expr then ... [else ...] end`
  - loops: `repeat ... until expr`
- Expressions:
  - arithmetic: `+ - * /`
  - relational: `< =`
  - grouping: `( ... )`
- Literals and identifiers:
  - integer numbers
  - variable identifiers
- Comments:
  - `{ comment }` (non-nesting)

Variables are collected from usage and emitted as globals in generated bytecode.

## Bytecode Emission Notes

`tiny.clike` reads VM definitions from repo headers at compile time:

- opcodes: `src/compiler/bytecode.h`
- VM version: `src/core/version.h`
- type tags: `src/core/types.h`

If `types.h` is missing, it falls back to canonical tags used by Tiny:

- integer: `TYPE_INT32` fallback value `2`
- string: `TYPE_STRING` fallback value `4`

Generated bytecode includes loader footer fields expected by `pscalvm` (matching the Python Tiny frontend convention).

## Runtime Requirements

Generated Tiny bytecode expects VM builtins:

- `read`
- `write`

If those builtins are unavailable in the active runtime, execution will fail.

## Troubleshooting

`tiny: expected bytecode at ... but it was not created`

- Compile step returned success but output file is missing.
- Re-run with explicit output path and verify destination permissions.

`tiny: source ... not found`

- Source path is wrong or inaccessible.
- Use an absolute path to verify path resolution.

`tiny: bytecode.h missing ...` or `tiny: version.h missing ...`

- Compiler is running outside a valid PSCAL workspace layout.
- Ensure `PSCALI_WORKSPACE_ROOT` points to the repository root (or run through `bin/tiny`).

Disassembly works but execution fails

- Verify VM/runtime parity and builtin availability.
- Compare output from:
  - `pscald <file.pbc>`
  - `pscalvm <file.pbc>`

## Recommended Workflow

For day-to-day usage:

1. `tiny source.tiny`
2. `pscalvm source.pbc` (or output path you selected)
3. `pscald source.pbc` when debugging code generation

Use `tiny --run source.tiny` for a single-command compile+execute loop.
