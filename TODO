Support goto? (no)
---
Plan to add CreateThread/WaitForThread and @ procedure pointers

Lexical support for @
Extend the lexer to recognize @ as a token representing the address-of operator.
Ensure it does not conflict with existing tokens.
Parser and AST updates
Modify the grammar to allow @Identifier as a primary expression that yields a pointer to a routine.
Add an AST node for addr-of expressions and ensure semantic checks confirm the identifier refers to a procedure/function.
Procedure-pointer type system
Introduce procedure/function pointer types (e.g., PHandler = function(data: Pointer): Integer).
Update type-checking logic so variables of these types can store and pass procedure addresses.
Symbol table & semantic analysis
Treat procedure declarations as first-class entities whose addresses can be taken.
Enforce matching signatures when assigning or passing procedure pointers.
Thread handle type
Define a built-in Thread type holding a runtime thread ID or handle.
Ensure thread handles can be stored in variables and passed around.
Built-in thread functions
Implement CreateThread(procPtr, argPtr) and WaitForThread(threadHandle) in the runtime VM.
CreateThread spawns a thread executing the provided routine with the supplied data pointer and returns a Thread handle.
WaitForThread blocks until the given handle completes.
Code generation adjustments
Emit bytecode or IR for addr-of expressions and procedure-pointer calls.
Support passing a pointer argument to threads and returning a result if needed.
Backward compatibility
Keep existing spawn/join APIs functional, possibly by internally mapping them onto the new primitives or leaving them untouched.
Testing
Add unit tests for @ operator semantics, procedure pointer assignments, and calls.
Write end-to-end tests demonstrating CreateThread/WaitForThread with data passing and synchronization.
Verify existing spawn/join tests still pass.
Documentation & examples
Update language reference to describe procedure pointers, @, and new threading functions.
Provide examples mirroring the sample SDLThreadedMandelbrot program to showcase usage.
This staged approach introduces address-of and procedure pointers, then layers a richer thread API atop the existing runtime without disrupting current programs.
---
Provide ability to query threads and thread states

---
Networking additions:

- Phase 1: Solid HTTP sync API (libcurl easy)
    - Sessions with keep-alive, headers map, redirects, timeouts.
    - Bodies to/from MStream or file; status + headers; basic auth.
    - Map curl errors to stable VM error codes.
- Phase 2: Async execution
    - Option A: Use threads under the hood (CreateThread/WaitForThread) returning Thread or HttpFuture handle.
    - Option B: libcurl multi + poll/select integration for true non-blocking; if chosen, add a simple event loop
(NetRunLoopStart/Stop, NetPoll) and Futures.
- Phase 3: TLS/security knobs
    - CA bundle/custom CA, client cert/key, hostname verification, pinning, proxies, HTTP/2.
- Phase 4: Reliability and ergonomics
    - Retry/backoff, rate-limiting, cookie jar, compressed responses, streaming uploads, progress callbacks,
cancellation.
- Phase 5: Sockets
    - TCP/UDP sockets, non-blocking, poll, DNS helpers; straightforward thin wrappers over BSD sockets.
- Phase 6: Higher protocols (optional)
    - WebSocket client (upgrade from HTTP), SSE streaming; consider libwebsockets for WS.
    - MQTT via libmosquitto (optional module).
- Phase 7: Tooling and docs
    - Unit tests with a tiny embedded HTTP server (or testcontainers) and golden-cases.
    - Examples: JSON API fetcher, file uploader, WebSocket echo, TCP echo client.
    - Troubleshooting guide for TLS/CA issues.
