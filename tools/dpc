#!/usr/bin/env python3
"""Dump Pscal cache entries with original source file paths."""

import argparse
import os
from pathlib import Path

FNV_OFFSET = 2166136261
FNV_PRIME = 16777619

def hash_path(path: str) -> int:
    real = os.path.realpath(path)
    h = FNV_OFFSET
    for b in os.fsencode(real):
        h ^= b
        h = (h * FNV_PRIME) & 0xFFFFFFFF
    return h

def build_hash_map(search_dirs: list[str]) -> dict[int, list[str]]:
    mapping: dict[int, list[str]] = {}
    for directory in search_dirs:
        base = Path(directory)
        if not base.is_dir():
            continue
        for root, dirs, files in os.walk(base, followlinks=False):
            if ".git" in dirs:
                dirs.remove(".git")
            for name in files:
                file_path = Path(root) / name
                abs_str = os.path.realpath(file_path)
                h = hash_path(abs_str)
                mapping.setdefault(h, []).append(abs_str)
    return mapping

def main() -> None:
    parser = argparse.ArgumentParser(
        description="Display original file paths for cached Pscal bytecode files."
    )
    parser.add_argument(
        "--cache-dir",
        default="~/.pscal_cache",
        help="Cache directory (default: ~/.pscal_cache)",
    )
    repo_root = str(Path(__file__).resolve().parents[1])
    parser.add_argument(
        "search_dirs",
        nargs="*",
        default=[repo_root],
        help=f"Directories to recursively search for source files (default: {repo_root})",
    )
    args = parser.parse_args()

    cache_dir = Path(os.path.expanduser(args.cache_dir))
    if not cache_dir.is_dir():
        raise SystemExit(f"Cache directory not found: {cache_dir}")

    hash_map = build_hash_map(args.search_dirs)

    for cache_file in sorted(cache_dir.glob("*.bc")):
        try:
            target_hash = int(cache_file.stem)
        except ValueError:
            print(f"{cache_file.name}: (invalid cache filename)")
            continue
        matches = hash_map.get(target_hash, [])
        if matches:
            for m in matches:
                print(f"{cache_file.name}: {m}")
        else:
            print(f"{cache_file.name}: (no match)")

if __name__ == "__main__":
    main()
