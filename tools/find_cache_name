#!/usr/bin/env python3
"""Locate the source file associated with a Pscal cache entry."""

import argparse
import os
import struct
from pathlib import Path
from typing import Optional

FNV_OFFSET = 2166136261
FNV_PRIME = 16777619


def _read_source_path(cache_path: Path) -> Optional[str]:
    try:
        with cache_path.open("rb") as f:
            # Skip magic and version
            header = f.read(8)
            if len(header) < 8:
                return None
            data = f.read(4)
            if len(data) != 4:
                return None
            stored = struct.unpack("<i", data)[0]
            if stored >= 0:
                return None
            path_bytes = f.read(-stored)
            if len(path_bytes) != -stored:
                return None
            return path_bytes.decode("utf-8")
    except OSError:
        return None


def hash_path(path: str) -> int:
    """Replicate the hash function used by Pscal's cache."""
    real = os.path.realpath(path)
    h = FNV_OFFSET
    for b in real.encode("utf-8"):
        h ^= b
        h = (h * FNV_PRIME) & 0xFFFFFFFF
    return h


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Find source file(s) matching a Pscal cache file."
    )
    parser.add_argument("cache_file", help="Path to a file in ~/.pscal/bc_cache")

    root_dir = str(Path("/").resolve())
    parser.add_argument(
        "search_dirs",
        nargs="*",
        default=[root_dir],
        help=(
            "Directories to recursively search for source files when no path is "
            f"embedded (default: {root_dir})"
        ),
    )
    args = parser.parse_args()

    cache_path = Path(args.cache_file).expanduser()
    if not cache_path.exists():
        raise SystemExit(f"Cache file not found: {cache_path}")

    src = _read_source_path(cache_path)
    if src:
        print(src)
        return

    if not cache_path.name.endswith(".bc"):
        raise SystemExit("Cache file should have a .bc extension")
    try:
        target_hash = int(cache_path.stem)
    except ValueError:
        raise SystemExit("Cache file name must be numeric like '<hash>.bc'")

    matches: list[str] = []
    for directory in args.search_dirs:
        base = Path(directory)
        if not base.is_dir():
            continue
        for root, dirs, files in os.walk(base, followlinks=False):
            if ".git" in dirs:
                dirs.remove(".git")
            for name in files:
                file_path = Path(root) / name
                abs_str = os.path.realpath(file_path)
                if hash_path(abs_str) == target_hash:
                    matches.append(abs_str)

    if matches:
        for m in matches:
            print(m)
    else:
        print("No matching source files found.")


if __name__ == "__main__":
    main()
