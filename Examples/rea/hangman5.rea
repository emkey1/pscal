// CRT routines like GotoXY and TextColor are available as built-ins,
// but color constants come from the CRT unit.
#import "crt";

// --- Game configuration ---
const int MAX_WRONG = 8;

// Layout rows relative to the top margin
const int HEADER_ROW = 1;
const int SUBTITLE_ROW = 2;
const int WORD_ROW = 4;
const int HANGMAN_ROW = 6;
const int GUESSBAR_ROW = 15;
const int GUESSED_ROW = 17;
const int PROMPT_ROW = 19;
const int MSG_ROW = 21;

const int GAME_HEIGHT = 22;
const int MAX_ELEMENT_WIDTH = 40;
const int HANGMAN_WIDTH = 12;
const int BORDER_PADDING = 2;

const char CornerTL = '╔';
const char CornerTR = '╗';
const char CornerBL = '╚';
const char CornerBR = '╝';
const char LineH = '═';
const char LineV = '║';

bool contains(str s, char c) {
  int i = 1;
  while (i <= length(s)) {
    if (s[i] == c) return true;
    i = i + 1;
  }
  return false;
}

str sortString(str s) {
  int i = 1;
  while (i <= length(s)) {
    int j = i + 1;
    while (j <= length(s)) {
      if (s[i] > s[j]) {
        char t = s[i];
        s[i] = s[j];
        s[j] = t;
      }
      j = j + 1;
    }
    i = i + 1;
  }
  return s;
}

// --- Word repository ---
class WordRepository {
  // store up to 2048 words loaded from the system dictionary
  str words[2048];
  int count;

  void WordRepository() {
    myself.count = 0;

    bool ok = false;
    if (paramcount() > 0) {
      ok = myself.load(paramstr(1));
    }
    if (!ok) {
      ok = myself.load("/usr/local/pscal/etc/words");
    }
    if (!ok) {
      ok = myself.load("etc/words");
    }
    if (!ok) {
      ok = myself.load("../etc/words");
    }
    if (!ok) {
      myself.load("../../etc/words");
    }
  }

  bool load(str path) {
    if (!fileexists(path)) {
      return false;
    }
    text f;
    assign(f, path);
    reset(f);
    str line;
    while (!eof(f) && myself.count < 2048) {
      readln(f, line);
      int wordLen = length(line);
      if (wordLen >= 6 && wordLen <= 9) {
        bool valid = true;
        str w = "";
        setlength(w, wordLen);
        int j = 1;
        while (j <= wordLen) {
          char ch = line[j];
          if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
            w[j] = toupper(ch);
          } else {
            valid = false;
          }
          j = j + 1;
        }
        if (valid) {
          myself.count = myself.count + 1;
          myself.words[myself.count] = w;
        }
      }
    }
    close(f);
    return myself.count > 0;
  }

  str randomWord() {
    int cnt = myself.count;
    if (cnt == 0) return "";
    int idx = random(cnt) + 1;
    return myself.words[idx];
  }
}

// --- View class handles all rendering ---
class HangmanView {
  int vHeaderRow, vSubtitleRow, vWordRow, vHangmanRow, vGuessBarRow, vGuessedRow, vPromptRow, vMsgRow;
  int borderTop, borderBottom, borderLeft, borderRight;
  int centerCol, hangmanCol, effectiveWidth;

  void HangmanView() {
    int cols = screencols();
    int rows = screenrows();
    int topMargin = int((rows - GAME_HEIGHT) / 2);

    myself.vHeaderRow = topMargin + HEADER_ROW;
    myself.vSubtitleRow = topMargin + SUBTITLE_ROW;
    myself.vWordRow = topMargin + WORD_ROW;
    myself.vHangmanRow = topMargin + HANGMAN_ROW;
    myself.vGuessBarRow = topMargin + GUESSBAR_ROW;
    myself.vGuessedRow = topMargin + GUESSED_ROW;
    myself.vPromptRow = topMargin + PROMPT_ROW;
    myself.vMsgRow = topMargin + MSG_ROW;

    myself.borderTop = topMargin;
    myself.borderBottom = topMargin + GAME_HEIGHT;
    myself.centerCol = int(cols / 2);
    myself.hangmanCol = myself.centerCol - int(HANGMAN_WIDTH / 2);
    myself.borderLeft = myself.centerCol - int(MAX_ELEMENT_WIDTH / 2) - BORDER_PADDING;
    myself.borderRight = myself.centerCol + int(MAX_ELEMENT_WIDTH / 2) + BORDER_PADDING;
    myself.effectiveWidth = myself.borderRight - myself.borderLeft - 1;
  }

  int centerPadding(str s) {
    int pad = int((myself.effectiveWidth - length(s)) / 2);
    if (pad < 0) pad = 0;
    return pad;
  }

  void drawBorder() {
    GotoXY(myself.borderLeft, myself.borderTop); write(CornerTL);
    GotoXY(myself.borderRight, myself.borderTop); write(CornerTR);
    GotoXY(myself.borderLeft, myself.borderBottom); write(CornerBL);
    GotoXY(myself.borderRight, myself.borderBottom); write(CornerBR);

    int x = myself.borderLeft + 1;
    while (x < myself.borderRight) {
      GotoXY(x, myself.borderTop); write(LineH);
      GotoXY(x, myself.borderBottom); write(LineH);
      x = x + 1;
    }

    int y = myself.borderTop + 1;
    while (y < myself.borderBottom) {
      GotoXY(myself.borderLeft, y); write(LineV);
      GotoXY(myself.borderRight, y); write(LineV);
      y = y + 1;
    }
  }

  void drawHangman(int wrong) {
    int r = myself.vHangmanRow;
    int c = myself.hangmanCol + 2;
    GotoXY(c, r); write(" +---+  ");
    r = r + 1;
    GotoXY(c, r); write(" |   |  ");
    r = r + 1;
    switch (wrong) {
      case 0:
        GotoXY(c, r); write("     |  "); r = r + 1;
        GotoXY(c, r); write("     |  "); r = r + 1;
        GotoXY(c, r); write("     |  "); r = r + 1;
        GotoXY(c, r); write("     |  "); r = r + 1;
        break;
      case 1:
        GotoXY(c, r); write(" O   |  "); r = r + 1;
        GotoXY(c, r); write("     |  "); r = r + 1;
        GotoXY(c, r); write("     |  "); r = r + 1;
        GotoXY(c, r); write("     |  "); r = r + 1;
        break;
      case 2:
        GotoXY(c, r); write(" O   |  "); r = r + 1;
        GotoXY(c, r); write(" |   |  "); r = r + 1;
        GotoXY(c, r); write("     |  "); r = r + 1;
        GotoXY(c, r); write("     |  "); r = r + 1;
        break;
      case 3:
        GotoXY(c, r); write(" O   |  "); r = r + 1;
        GotoXY(c, r); write("/|   |  "); r = r + 1;
        GotoXY(c, r); write("     |  "); r = r + 1;
        GotoXY(c, r); write("     |  "); r = r + 1;
        break;
      case 4:
        GotoXY(c, r); write(" O   |  "); r = r + 1;
        GotoXY(c, r); write("/|\\  |  "); r = r + 1;
        GotoXY(c, r); write("     |  "); r = r + 1;
        GotoXY(c, r); write("     |  "); r = r + 1;
        break;
      case 5:
        GotoXY(c, r); write(" O   |  "); r = r + 1;
        GotoXY(c, r); write("/|\\  |  "); r = r + 1;
        GotoXY(c, r); write("/    |  "); r = r + 1;
        GotoXY(c, r); write("     |  "); r = r + 1;
        break;
      case 6:
        GotoXY(c, r); write(" O   |  "); r = r + 1;
        GotoXY(c, r); write("/|\\  |  "); r = r + 1;
        GotoXY(c, r); write("/ \\  |  "); r = r + 1;
        GotoXY(c, r); write("     |  "); r = r + 1;
        break;
      case 7:
        GotoXY(c, r); write(" O   |"); r = r + 1;
        GotoXY(c, r); write("/|\\  |"); r = r + 1;
        GotoXY(c - 1, r); write("_/ \\  |"); r = r + 1;
        GotoXY(c, r); write("     |"); r = r + 1;
        break;
      default:
        GotoXY(c, r); write(" O   |"); r = r + 1;
        GotoXY(c, r); write("/|\\  |"); r = r + 1;
        GotoXY(c - 1, r); write("_/ \\_ |"); r = r + 1;
        GotoXY(c, r); write("     |"); r = r + 1;
        break;
    }
    GotoXY(c, r); write("=========");
  }

  void drawGuessesBar(int wrong) {
    int remaining = MAX_WRONG - wrong;
    int padding = int((myself.effectiveWidth - (14 + MAX_WRONG + 6)) / 2);
    if (padding < 0) padding = 0;
    GotoXY(myself.borderLeft + 1 + padding, myself.vGuessBarRow);
    int i = 1;
    write("Guesses Left: ");
    TextColor(LightGreen);
    while (i <= remaining) { write("#"); i = i + 1; }
    TextColor(LightRed);
    i = 1;
    while (i <= wrong) { write("#"); i = i + 1; }
    TextColor(White);
    write(" ["); write(remaining); write("/"); write(MAX_WRONG); write("]");
  }

  void render(str display, str guessed, int wrong) {
    ClrScr();
    myself.drawBorder();
    int pad;
    pad = myself.centerPadding("Welcome to Hangman!");
    GotoXY(myself.borderLeft + 1 + pad, myself.vHeaderRow); TextColor(LightGreen); writeln("Welcome to Hangman!"); TextColor(White);
    pad = myself.centerPadding("(Guess a letter or ? for hint)");
    GotoXY(myself.borderLeft + 1 + pad, myself.vSubtitleRow); writeln("(Guess a letter or ? for hint)");
    pad = myself.centerPadding(display);
    GotoXY(myself.borderLeft + 1 + pad, myself.vWordRow); writeln(display);
    myself.drawHangman(wrong);
    myself.drawGuessesBar(wrong);
    if (length(guessed) > 0) {
      str g = sortString(guessed);
      str msg = "Letters chosen so far: " + g;
      pad = myself.centerPadding(msg);
      GotoXY(myself.borderLeft + 1 + pad, myself.vGuessedRow); writeln(msg);
    }
  }

  bool showHint(str word, str display, bool hintUsed) {
    int pad;
    if (hintUsed) {
      pad = myself.centerPadding("Hint used already.");
      GotoXY(myself.borderLeft + 1 + pad, myself.vMsgRow); writeln("Hint used already.");
    } else {
      int hintIndex = -1;
      int attempts = 0;
      while (attempts < length(word) * 2 && hintIndex == -1) {
        int i = random(length(word)) + 1;
        if (display[i] == '_') hintIndex = i;
        attempts = attempts + 1;
      }
      if (hintIndex == -1) {
        pad = myself.centerPadding("No more hints available.");
        GotoXY(myself.borderLeft + 1 + pad, myself.vMsgRow); writeln("No more hints available.");
      } else {
        str hintMsg = "Hint: letter at position " + inttostr(hintIndex) + " is '" + word[hintIndex] + "'";
        pad = myself.centerPadding(hintMsg);
        GotoXY(myself.borderLeft + 1 + pad, myself.vMsgRow); writeln(hintMsg);
        hintUsed = true;
      }
    }
    pad = myself.centerPadding("Press Enter to continue...");
    GotoXY(myself.borderLeft + 1 + pad, myself.vMsgRow + 1); writeln("Press Enter to continue...");
    str pause; readln(pause);
    return hintUsed;
  }

  void showMessage(str msg) {
    int pad = myself.centerPadding(msg);
    GotoXY(myself.borderLeft + 1 + pad, myself.vMsgRow); writeln(msg);
  }
}

// --- Game logic ---
class HangmanGame {
  WordRepository repo;
  HangmanView view;
  str chosen;
  str display;
  str guessed;
  int wrong;
  bool hintUsed;
  int wins;
  int losses;

  void HangmanGame() {
    myself.repo = new WordRepository();
    myself.repo.WordRepository();
    myself.view = new HangmanView();
    myself.view.HangmanView();
    myself.chosen = "";
    myself.display = "";
    myself.guessed = "";
    myself.wins = 0;
    myself.losses = 0;
  }

  void startRound() {
    randomize();
    myself.chosen = myself.repo.randomWord();
    myself.display = "";
    int i = 1;
    while (i <= length(myself.chosen)) {
      myself.display = myself.display + "_";
      i = i + 1;
    }
    myself.guessed = "";
    myself.wrong = 0;
    myself.hintUsed = false;
  }

  bool handleGuess(char c) {
    bool hit = false;
    int i = 1;
    while (i <= length(myself.chosen)) {
      if (myself.chosen[i] == c) {
        myself.display[i] = c;
        hit = true;
      }
      i = i + 1;
    }
    if (!hit) myself.wrong = myself.wrong + 1;
    myself.guessed = myself.guessed + c;
    return myself.display == myself.chosen;
  }

  void playRound() {
    bool win = false;
    str msg;
    while (myself.wrong < MAX_WRONG && myself.display != myself.chosen) {
      myself.view.render(myself.display, myself.guessed, myself.wrong);
      int pad = myself.view.centerPadding("Enter a letter: ");
      GotoXY(myself.view.borderLeft + 1 + pad, myself.view.vPromptRow);
      write("Enter a letter: ");
      str line; readln(line);
      if (length(line) == 0) continue;
      char g = toupper(line[1]);
      if (g == '?') {
        myself.hintUsed = myself.view.showHint(myself.chosen, myself.display, myself.hintUsed);
        continue;
      }
      if (contains(myself.guessed, g)) {
        myself.view.showMessage("Already guessed.");
        continue;
      }
      win = myself.handleGuess(g);
    }

    myself.view.render(myself.display, myself.guessed, myself.wrong);
    if (myself.display == myself.chosen) {
      TextColor(Green);
      myself.view.showMessage("You guessed the word!");
      TextColor(White);
      myself.wins = myself.wins + 1;
    } else {
      TextColor(LightRed);
      msg = "Sorry, the word was " + myself.chosen;
      myself.view.showMessage(msg);
      TextColor(White);
      myself.losses = myself.losses + 1;
    }
    str scoreMsg = "Score: " + inttostr(myself.wins) + " wins / " + inttostr(myself.losses) + " losses";
    int pad = myself.view.centerPadding(scoreMsg);
    GotoXY(myself.view.borderLeft + 1 + pad, myself.view.vMsgRow + 1); writeln(scoreMsg);
    pad = myself.view.centerPadding("Press Enter...");
    GotoXY(myself.view.borderLeft + 1 + pad, myself.view.vMsgRow + 2); writeln("Press Enter...");
    str pause; readln(pause);
  }

  void play() {
    bool again = true;
    while (again) {
      myself.startRound();
      myself.playRound();
      // Clear previous prompt line and ask inside border
      GotoXY(myself.view.borderLeft + 1, myself.view.vMsgRow + 2);
      int i = 1;
      while (i <= myself.view.effectiveWidth) { write(" "); i = i + 1; }
      int pad = myself.view.centerPadding("Play again? (Y/N): ");
      GotoXY(myself.view.borderLeft + 1 + pad, myself.view.vMsgRow + 2);
      write("Play again? (Y/N): ");
      str ans; readln(ans);
      if (length(ans) == 0) { again = true; }
      else {
        char r = toupper(ans[1]);
        if (r == 'Y') again = true; else again = false;
      }
    }
  }
}

HangmanGame game = new HangmanGame();
game.HangmanGame();
game.play();
