#!/usr/bin/env rea
// SDL Multi Bouncing Balls 3D demo for Rea with a manual physics step.
// Renders a field of spheres bouncing inside a glass box using one face as the
// viewing window. Requires building Pscal with SDL support.

const int WindowWidth = 1280;
const int WindowHeight = 720;
const int TargetFPS = 60;
const int NumBalls = 120;
const float BoxWidth = 720.0;
const float BoxHeight = 420.0;
const float BoxDepth = 640.0;
const float WallElasticity = 1.08;
const float MinSpeed = 90.0;
const float MaxSpeed = 360.0;
const float VelocityDrag = 0.995;
const float CameraDistance = 720.0;
const int FrameMargin = 48;

float posX[NumBalls];
float posY[NumBalls];
float posZ[NumBalls];
float velX[NumBalls];
float velY[NumBalls];
float velZ[NumBalls];
float radii[NumBalls];
float screenX[NumBalls];
float screenY[NumBalls];
float screenRadius[NumBalls];
float depthShade[NumBalls];
int drawOrder[NumBalls];
int colorR[NumBalls];
int colorG[NumBalls];
int colorB[NumBalls];

float enforceSpeed(float value, float minSpeed, float maxSpeed) {
  float absVal = abs(value);
  if (absVal < minSpeed) {
    if (value < 0.0) {
      return -minSpeed;
    } else {
      return minSpeed;
    }
  }
  if (value > maxSpeed) return maxSpeed;
  if (value < -maxSpeed) return -maxSpeed;
  return value;
}

int FrameDelay;
bool quit;
bool paused;
float elapsedSeconds;

float randomUnit() {
  return random(10000) / 10000.0;
}

void bar(int left, int top, int right, int bottom) {
  if (left > right) {
    int temp = left;
    left = right;
    right = temp;
  }
  if (top > bottom) {
    int temp = top;
    top = bottom;
    bottom = temp;
  }
  int y = top;
  while (y <= bottom) {
    drawline(left, y, right, y);
    y = y + 1;
  }
}

void initDrawOrder() {
  int i = 0;
  while (i < NumBalls) {
    drawOrder[i] = i;
    i = i + 1;
  }
}

void sortDrawOrderByDepth() {
  int i = 1;
  while (i < NumBalls) {
    int currentIndex = drawOrder[i];
    float currentShade = depthShade[currentIndex];
    int j = i - 1;
    while (j >= 0 && depthShade[drawOrder[j]] > currentShade) {
      drawOrder[j + 1] = drawOrder[j];
      j = j - 1;
    }
    drawOrder[j + 1] = currentIndex;
    i = i + 1;
  }
}

void initBalls() {
  int i = 0;
  float halfWidth = BoxWidth * 0.5;
  float halfHeight = BoxHeight * 0.5;
  while (i < NumBalls) {
    float r = 12.0 + random(26);
    float availX = (BoxWidth - 2.0 * r);
    float availY = (BoxHeight - 2.0 * r);
    float availZ = (BoxDepth - 2.0 * r);
    if (availX < 4.0) availX = 4.0;
    if (availY < 4.0) availY = 4.0;
    if (availZ < 4.0) availZ = 4.0;
    radii[i] = r;
    posX[i] = -halfWidth + r + randomUnit() * availX;
    posY[i] = -halfHeight + r + randomUnit() * availY;
    posZ[i] = -r - randomUnit() * (BoxDepth - 2.0 * r);
    int speedRange = trunc(MaxSpeed - MinSpeed);
    float speed = MinSpeed + random(speedRange + 1) + randomUnit();
    float yaw = random(360);
    float pitch = random(121) - 60.0;
    float dirXY = cos(pitch);
    velX[i] = cos(yaw) * dirXY * speed;
    velY[i] = sin(pitch) * speed;
    velZ[i] = sin(yaw) * dirXY * speed;
    colorR[i] = 90 + random(150);
    colorG[i] = 90 + random(150);
    colorB[i] = 90 + random(150);
    screenRadius[i] = 0.0;
    screenX[i] = 0.0;
    screenY[i] = 0.0;
    depthShade[i] = 0.0;
    i = i + 1;
  }
  initDrawOrder();
}

void drawFrameOverlay() {
  int left = FrameMargin;
  int top = FrameMargin;
  int right = WindowWidth - FrameMargin;
  int bottom = WindowHeight - FrameMargin;
  setrgbcolor(24, 28, 42);
  bar(0, 0, WindowWidth, WindowHeight);
  setrgbcolor(40, 48, 70);
  bar(left - 6, top - 6, right + 6, bottom + 6);
  setrgbcolor(12, 16, 26);
  bar(left - 2, top - 2, right + 2, bottom + 2);
  setrgbcolor(18, 28, 42);
  bar(left, top, right, bottom);
  setrgbcolor(64, 84, 120);
  drawline(left, top, right, top);
  drawline(right, top, right, bottom);
  drawline(right, bottom, left, bottom);
  drawline(left, bottom, left, top);
  setrgbcolor(110, 130, 170);
  drawline(left, top, left + 120, top - 36);
  drawline(right, top, right + 120, top - 36);
  drawline(right, bottom, right + 120, bottom + 36);
  drawline(left, bottom, left + 120, bottom + 36);
}

void drawBalls() {
  int i = 0;
  int left = FrameMargin;
  int top = FrameMargin;
  int right = WindowWidth - FrameMargin;
  int bottom = WindowHeight - FrameMargin;
  while (i < NumBalls) {
    int ballIndex = drawOrder[i];
    float shade = depthShade[ballIndex];
    if (shade >= 0.0) {
      int sx = FrameMargin + trunc(screenX[ballIndex]);
      int sy = FrameMargin + trunc(screenY[ballIndex]);
      int sr = trunc(screenRadius[ballIndex]);
      if (sr < 1) sr = 1;
      if (sx >= left - sr && sx <= right + sr && sy >= top - sr && sy <= bottom + sr) {
        float glow = 0.35 + shade * 0.65;
        if (glow > 1.1) glow = 1.1;
        int r = trunc(colorR[ballIndex] * glow);
        int g = trunc(colorG[ballIndex] * glow);
        int b = trunc(colorB[ballIndex] * glow);
        if (r > 255) r = 255;
        if (g > 255) g = 255;
        if (b > 255) b = 255;
        setrgbcolor(r, g, b);
        fillcircle(sx, sy, sr);
        int rimR = r + 32;
        int rimG = g + 32;
        int rimB = b + 32;
        if (rimR > 255) rimR = 255;
        if (rimG > 255) rimG = 255;
        if (rimB > 255) rimB = 255;
        setrgbcolor(rimR, rimG, rimB);
        drawcircle(sx, sy, sr);
        int highlightR = rimR + 16;
        int highlightG = rimG + 16;
        int highlightB = rimB + 16;
        if (highlightR > 255) highlightR = 255;
        if (highlightG > 255) highlightG = 255;
        if (highlightB > 255) highlightB = 255;
        setrgbcolor(highlightR, highlightG, highlightB);
        int specX = sx - trunc(sr * 0.35);
        int specY = sy - trunc(sr * 0.35);
        int specRadius = trunc(sr * 0.25);
        if (specRadius < 1) specRadius = 1;
        drawcircle(specX, specY, specRadius);
      }
    }
    i = i + 1;
  }
}

void drawHud() {
  setrgbcolor(200, 215, 235);
  int textX = FrameMargin + 12;
  int hudTop = FrameMargin + 24;
  string label = "Multi Bouncing Balls 3D - Press Q to quit, Space to pause";
  outtextxy(textX, hudTop, label);
  string timeLabel = "Elapsed: " + formatfloat(elapsedSeconds, 1) + "s";
  outtextxy(textX, FrameMargin + 48, timeLabel);
}

void updateSimulation(float deltaTime) {
  if (paused) return;
  float halfWidth = BoxWidth * 0.5;
  float halfHeight = BoxHeight * 0.5;
  float nearPlane = 0.0;
  float backPlane = -BoxDepth;
  float screenWidth = WindowWidth - FrameMargin * 2;
  float screenHeight = WindowHeight - FrameMargin * 2;
  float viewScaleX = screenWidth / BoxWidth;
  float viewScaleY = screenHeight / BoxHeight;

  int i = 0;
  while (i < NumBalls) {
    float x = posX[i];
    float y = posY[i];
    float z = posZ[i];
    float vx = velX[i];
    float vy = velY[i];
    float vz = velZ[i];
    float r = radii[i];
    if (r <= 0.0) r = 1.0;

    float minX = -halfWidth + r;
    float maxX = halfWidth - r;
    float minY = -halfHeight + r;
    float maxY = halfHeight - r;
    float minZ = backPlane + r;
    float maxZ = nearPlane - r;

    vx = vx * VelocityDrag;
    vy = vy * VelocityDrag;
    vz = vz * VelocityDrag;

    x = x + vx * deltaTime;
    y = y + vy * deltaTime;
    z = z + vz * deltaTime;

    if (x < minX) {
      x = minX;
      vx = abs(vx) * WallElasticity;
      if (vx < MinSpeed) vx = MinSpeed;
    } else if (x > maxX) {
      x = maxX;
      vx = -abs(vx) * WallElasticity;
      if (-vx < MinSpeed) vx = -MinSpeed;
    }
    if (y < minY) {
      y = minY;
      vy = abs(vy) * WallElasticity;
      if (vy < MinSpeed) vy = MinSpeed;
    } else if (y > maxY) {
      y = maxY;
      vy = -abs(vy) * WallElasticity;
      if (-vy < MinSpeed) vy = -MinSpeed;
    }
    if (z < minZ) {
      z = minZ;
      vz = abs(vz) * WallElasticity;
      if (vz < MinSpeed) vz = MinSpeed;
    } else if (z > maxZ) {
      z = maxZ;
      vz = -abs(vz) * WallElasticity;
      if (-vz < MinSpeed) vz = -MinSpeed;
    }

    vx = enforceSpeed(vx, MinSpeed, MaxSpeed);
    vy = enforceSpeed(vy, MinSpeed, MaxSpeed);
    vz = enforceSpeed(vz, MinSpeed, MaxSpeed);

    posX[i] = x;
    posY[i] = y;
    posZ[i] = z;
    velX[i] = vx;
    velY[i] = vy;
    velZ[i] = vz;
    i = i + 1;
  }

  i = 0;
  while (i < NumBalls) {
    int j = i + 1;
    while (j < NumBalls) {
      float xi = posX[i];
      float yi = posY[i];
      float zi = posZ[i];
      float vxi = velX[i];
      float vyi = velY[i];
      float vzi = velZ[i];
      float ri = radii[i];
      float mi = ri * ri * ri;
      if (mi <= 0.0) mi = 1.0;

      float xj = posX[j];
      float yj = posY[j];
      float zj = posZ[j];
      float vxj = velX[j];
      float vyj = velY[j];
      float vzj = velZ[j];
      float rj = radii[j];
      float mj = rj * rj * rj;
      if (mj <= 0.0) mj = 1.0;

      float dx = xj - xi;
      float dy = yj - yi;
      float dz = zj - zi;
      float sumR = ri + rj;
      float distSq = dx * dx + dy * dy + dz * dz;
      if (distSq < sumR * sumR) {
        float dist = sqrt(distSq);
        float nx;
        float ny;
        float nz;
        if (dist > 0.000001) {
          nx = dx / dist;
          ny = dy / dist;
          nz = dz / dist;
        } else {
          nx = 1.0;
          ny = 0.0;
          nz = 0.0;
          dist = sumR;
        }

        float viN = vxi * nx + vyi * ny + vzi * nz;
        float vjN = vxj * nx + vyj * ny + vzj * nz;

        float viT_x = vxi - viN * nx;
        float viT_y = vyi - viN * ny;
        float viT_z = vzi - viN * nz;

        float vjT_x = vxj - vjN * nx;
        float vjT_y = vyj - vjN * ny;
        float vjT_z = vzj - vjN * nz;

        float newViN = (viN * (mi - mj) + 2.0 * mj * vjN) / (mi + mj);
        float newVjN = (vjN * (mj - mi) + 2.0 * mi * viN) / (mi + mj);

        vxi = viT_x + newViN * nx;
        vyi = viT_y + newViN * ny;
        vzi = viT_z + newViN * nz;

        vxj = vjT_x + newVjN * nx;
        vyj = vjT_y + newVjN * ny;
        vzj = vjT_z + newVjN * nz;

        float overlap = sumR - dist;
        if (overlap > 0.0) {
          float correction = overlap * 0.5;
          xi = xi - correction * nx;
          yi = yi - correction * ny;
          zi = zi - correction * nz;
          xj = xj + correction * nx;
          yj = yj + correction * ny;
          zj = zj + correction * nz;
        }

        vxi = enforceSpeed(vxi, MinSpeed, MaxSpeed);
        vyi = enforceSpeed(vyi, MinSpeed, MaxSpeed);
        vzi = enforceSpeed(vzi, MinSpeed, MaxSpeed);
        vxj = enforceSpeed(vxj, MinSpeed, MaxSpeed);
        vyj = enforceSpeed(vyj, MinSpeed, MaxSpeed);
        vzj = enforceSpeed(vzj, MinSpeed, MaxSpeed);

        posX[i] = xi;
        posY[i] = yi;
        posZ[i] = zi;
        velX[i] = vxi;
        velY[i] = vyi;
        velZ[i] = vzi;

        posX[j] = xj;
        posY[j] = yj;
        posZ[j] = zj;
        velX[j] = vxj;
        velY[j] = vyj;
        velZ[j] = vzj;
      }
      j = j + 1;
    }
    i = i + 1;
  }

  i = 0;
  while (i < NumBalls) {
    float x = posX[i];
    float y = posY[i];
    float z = posZ[i];
    float r = radii[i];
    if (z > nearPlane - r) {
      z = nearPlane - r;
      posZ[i] = z;
    }
    if (z < backPlane + r) {
      z = backPlane + r;
      posZ[i] = z;
    }

    float denom = CameraDistance - z;
    if (denom <= 0.000001) {
      depthShade[i] = -1.0;
      i = i + 1;
      continue;
    }
    float perspective = CameraDistance / denom;
    float sx = screenWidth * 0.5 + x * perspective * viewScaleX;
    float sy = screenHeight * 0.5 - y * perspective * viewScaleY;
    float sr = r * perspective * (viewScaleX + viewScaleY) * 0.5;
    if (sr < 1.0) sr = 1.0;

    float depthFactor = -z / BoxDepth;
    if (depthFactor < 0.0) depthFactor = 0.0;
    if (depthFactor > 1.0) depthFactor = 1.0;
    float shade = 0.25 + 0.75 * depthFactor;

    screenX[i] = sx;
    screenY[i] = sy;
    screenRadius[i] = sr;
    depthShade[i] = shade;
    i = i + 1;
  }

  sortDrawOrderByDepth();
  elapsedSeconds = elapsedSeconds + deltaTime;
}

void handleInput() {
  if (keypressed()) {
    char key = readkey();
    if (key == 'q' || key == 'Q') {
      quit = true;
    } else if (key == ' ') {
      paused = !paused;
    }
  }
}

void drawScene() {
  drawFrameOverlay();
  drawBalls();
  drawHud();
  updatescreen();
}

void initApp() {
  initgraph(WindowWidth, WindowHeight, "Rea Multi Bouncing Balls 3D");
  string systemFontPath = "/usr/local/Pscal/fonts/Roboto/static/Roboto-Regular.ttf";
  string repoFontPath1 = "fonts/Roboto/static/Roboto-Regular.ttf";
  string repoFontPath2 = "../../fonts/Roboto/static/Roboto-Regular.ttf";
  if (fileexists(systemFontPath)) {
    inittextsystem(systemFontPath, 18);
  } else if (fileexists(repoFontPath1)) {
    inittextsystem(repoFontPath1, 18);
  } else {
    inittextsystem(repoFontPath2, 18);
  }
  randomize();
  FrameDelay = trunc(1000 / TargetFPS);
  quit = false;
  paused = false;
  elapsedSeconds = 0.0;
  initBalls();
}

void run() {
  initApp();
  writeln("Multi Bouncing Balls 3D... Press Q to quit.");
  float deltaTime = 1.0 / TargetFPS;
  while (!quit) {
    handleInput();
    updateSimulation(deltaTime);
    drawScene();
    graphloop(FrameDelay);
  }
  closegraph();
  writeln("Demo finished.");
}

run();
