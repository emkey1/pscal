#!/usr/bin/env rea
// SDL Multi Bouncing Balls 3D demo rewritten to showcase rich Rea language features.
// This version leans on classes, inheritance, constructors, threadsafe random helpers,
// and the most advanced BouncingBalls3D builtin for per-pixel lighting hints.

const int WindowWidth = 1280;
const int WindowHeight = 720;
const float TargetFPS = 90.0;
const int NumBalls = 18;
const float BoxWidth = 720.0;
const float BoxHeight = 420.0;
const float BoxDepth = 320.0;
const float WallElasticity = 1.12;
const float MinSpeed = 120.0;
const float MaxSpeed = 680.0;
const float VelocityDrag = 0.993;
const float CameraDistance = 1820.0;
const float InitialCameraPitch = -14.0;
const float CameraOrbitSpeed = 75.0;
const float ManualYawSpeed = 160.0;
const float ManualPitchSpeed = 95.0;
const float MinCameraPitch = -58.0;
const float MaxCameraPitch = 28.0;

const int ScanCodeLeft = 80;  // SDL_SCANCODE_LEFT
const int ScanCodeRight = 79; // SDL_SCANCODE_RIGHT
const int ScanCodeUp = 82;    // SDL_SCANCODE_UP
const int ScanCodeDown = 81;  // SDL_SCANCODE_DOWN
const int ScanCodePageUp = 75;   // SDL_SCANCODE_PAGEUP
const int ScanCodePageDown = 78; // SDL_SCANCODE_PAGEDOWN

const int SphereStacks = 26;
const int SphereSlices = 48;
const float Pi = 3.141592653589793;

const int NumStars = 420;
const float StarInnerRadiusScale = 1.55;
const float StarOuterRadiusScale = 3.15;
const float LightStarSize = 24.0;
const float LightStarBrightness = 1.0;
const float LightStarTwinkleRate = 0.32;

const float LightDirX = -0.55;
const float LightDirY = -0.35;
const float LightDirZ = 0.78;
const float AmbientLevel = 0.18;

float elapsedSeconds;

float randomUnit() {
    return random(10000) / 10000.0;
}

class Vec3 {
    float x;
    float y;
    float z;

    void Vec3(float ix, float iy, float iz) {
        myself.x = ix;
        myself.y = iy;
        myself.z = iz;
    }

    void set(float nx, float ny, float nz) {
        myself.x = nx;
        myself.y = ny;
        myself.z = nz;
    }

    float length() {
        return sqrt(myself.x * myself.x + myself.y * myself.y + myself.z * myself.z);
    }
}

class CameraRig {
    float distance;
    float yaw;
    float pitch;
    float yawVelocity;
    float minPitch;
    float maxPitch;
    float autoOrbitSpeed;
    float manualYawSpeedValue;
    float manualPitchSpeedValue;

    void CameraRig(float dist, float initialYaw, float initialPitch,
            float autoSpeed, float manualYaw, float manualPitch,
            float minPitchDeg, float maxPitchDeg) {
        myself.distance = dist;
        myself.yaw = initialYaw;
        myself.pitch = initialPitch;
        myself.yawVelocity = autoSpeed;
        myself.autoOrbitSpeed = autoSpeed;
        myself.manualYawSpeedValue = manualYaw;
        myself.manualPitchSpeedValue = manualPitch;
        myself.minPitch = minPitchDeg;
        myself.maxPitch = maxPitchDeg;
    }

    void clampPitch() {
        if (myself.pitch < myself.minPitch) myself.pitch = myself.minPitch;
        if (myself.pitch > myself.maxPitch) myself.pitch = myself.maxPitch;
    }

    void updateAutoYaw(float deltaTime) {
        myself.yaw = myself.yaw + deltaTime * myself.yawVelocity;
        if (myself.yaw >= 360.0) myself.yaw = myself.yaw - 360.0;
        if (myself.yaw < 0.0) myself.yaw = myself.yaw + 360.0;
    }
}

class Renderable {
    void update(float deltaTime) {
        // Default implementation intentionally blank.
    }

    void draw() {
        // Default implementation intentionally blank.
    }
}

class SphereMesh extends Renderable {
    void drawUnit() {
        int stack = 0;
        while (stack < SphereStacks) {
            float phi0 = -Pi * 0.5 + Pi * stack / SphereStacks;
            float phi1 = -Pi * 0.5 + Pi * (stack + 1) / SphereStacks;
            float cosPhi0 = cos(phi0);
            float sinPhi0 = sin(phi0);
            float cosPhi1 = cos(phi1);
            float sinPhi1 = sin(phi1);

            GLBegin("triangle_strip");
            int slice = 0;
            while (slice <= SphereSlices) {
                float theta = 2.0 * Pi * slice / SphereSlices;
                float cosTheta = cos(theta);
                float sinTheta = sin(theta);

                float n0x = cosPhi0 * cosTheta;
                float n0y = sinPhi0;
                float n0z = cosPhi0 * sinTheta;
                float n1x = cosPhi1 * cosTheta;
                float n1y = sinPhi1;
                float n1z = cosPhi1 * sinTheta;

                GLNormal3f(n1x, n1y, n1z);
                GLVertex3f(n1x, n1y, n1z);

                GLNormal3f(n0x, n0y, n0z);
                GLVertex3f(n0x, n0y, n0z);

                slice = slice + 1;
            }
            GLEnd();
            stack = stack + 1;
        }
    }
}

class Starfield extends Renderable {
    float x[NumStars];
    float y[NumStars];
    float z[NumStars];
    float size[NumStars];
    float baseBrightness[NumStars];
    float twinkleRate[NumStars];
    float phase[NumStars];

    void Starfield() {
        // default constructor
    }

    void init() {
        float boxRadius = BoxWidth;
        if (BoxHeight > boxRadius) boxRadius = BoxHeight;
        if (BoxDepth > boxRadius) boxRadius = BoxDepth;
        float innerRadius = boxRadius * StarInnerRadiusScale;
        float cameraGuard = CameraDistance * 1.08;
        if (cameraGuard > innerRadius) innerRadius = cameraGuard;
        float outerRadius = boxRadius * StarOuterRadiusScale;
        if (outerRadius < innerRadius + 1.0) outerRadius = innerRadius + 1.0;

        Vec3 lightDir = new Vec3(LightDirX, LightDirY, LightDirZ);
        float lightLength = lightDir.length();
        if (lightLength < 0.00001) lightLength = 1.0;
        float highlightDistance = innerRadius + 0.78 * (outerRadius - innerRadius);
        float highlightScale = highlightDistance / lightLength;

        myself.x[0] = 0.0 - LightDirX * highlightScale;
        myself.y[0] = 0.0 - LightDirY * highlightScale;
        myself.z[0] = 0.0 - LightDirZ * highlightScale;
        myself.size[0] = LightStarSize;
        myself.baseBrightness[0] = LightStarBrightness;
        myself.twinkleRate[0] = LightStarTwinkleRate;
        myself.phase[0] = 0.0;

        int i = 1;
        while (i < NumStars) {
            float cosTheta = 2.0 * randomUnit() - 1.0;
            if (cosTheta > 1.0) cosTheta = 1.0;
            if (cosTheta < -1.0) cosTheta = -1.0;
            float sinSq = 1.0 - cosTheta * cosTheta;
            if (sinSq < 0.0) sinSq = 0.0;
            float sinTheta = sqrt(sinSq);
            float phi = randomUnit() * 2.0 * Pi;
            float dirX = sinTheta * cos(phi);
            float dirY = sinTheta * sin(phi);
            float dirZ = cosTheta;
            float distance = innerRadius + randomUnit() * (outerRadius - innerRadius);
            myself.x[i] = dirX * distance;
            myself.y[i] = dirY * distance;
            myself.z[i] = dirZ * distance;
            myself.size[i] = 5.0 + randomUnit() * 9.0;
            myself.baseBrightness[i] = 0.35 + randomUnit() * 0.55;
            myself.twinkleRate[i] = 0.6 + randomUnit() * 1.9;
            myself.phase[i] = randomUnit() * 2.0 * Pi;
            i = i + 1;
        }
    }

    void draw() {
        float time = elapsedSeconds;
        GLDisable("lighting");
        GLDepthTest(false);
        GLEnable("blend");
        GLBlendFunc("src_alpha", "one");
        GLBegin("lines");
        int i = 0;
        while (i < NumStars) {
            float sparklePhase = myself.phase[i] + time * myself.twinkleRate[i];
            float sparkle = 0.55 + 0.45 * sin(sparklePhase);
            if (sparkle < 0.0) sparkle = 0.0;
            float brightness = myself.baseBrightness[i] * sparkle;
            float alpha = 0.35 + 0.45 * sparkle;
            if (alpha > 1.0) alpha = 1.0;
            float s = myself.size[i];
            float depthSize = s * 0.55;
            GLColor4f(brightness, brightness, brightness + 0.12, alpha);
            GLVertex3f(myself.x[i] - s, myself.y[i], myself.z[i]);
            GLVertex3f(myself.x[i] + s, myself.y[i], myself.z[i]);
            GLVertex3f(myself.x[i], myself.y[i] - s, myself.z[i]);
            GLVertex3f(myself.x[i], myself.y[i] + s, myself.z[i]);
            GLVertex3f(myself.x[i], myself.y[i], myself.z[i] - depthSize);
            GLVertex3f(myself.x[i], myself.y[i], myself.z[i] + depthSize);
            i = i + 1;
        }
        GLEnd();
        GLBlendFunc("src_alpha", "one_minus_src_alpha");
        GLDisable("blend");
        GLDepthTest(true);
        GLEnable("lighting");
    }
}

class LightingRig extends Renderable {
    void setup() {
        GLClearDepth(1.0);
        GLDepthTest(true);
        GLEnable("lighting");
        GLEnable("light0");
        GLEnable("color_material");
        GLEnable("normalize");

        GLShadeModel("smooth");
        GLColorMaterial("front", "ambient_and_diffuse");

        float ambient = AmbientLevel;
        GLLightfv("light0", "ambient", ambient, ambient, ambient, 1.0);
        GLLightfv("light0", "diffuse", 0.90, 0.92, 0.95, 1.0);
        GLLightfv("light0", "specular", 0.85, 0.90, 0.95, 1.0);

        GLMaterialfv("front", "specular", 0.55, 0.60, 0.70, 1.0);
        GLMaterialf("front", "shininess", 42.0);
    }
}

class GlassArena extends Renderable {
    void draw() {
        float halfWidth = BoxWidth * 0.5;
        float halfHeight = BoxHeight * 0.5;
        float frontZ = -18.0;
        float backZ = -BoxDepth;
        float floorBackZ = backZ + 1.0;

        GLDisable("lighting");
        GLEnable("blend");
        GLBlendFunc("src_alpha", "one_minus_src_alpha");

        GLColor4f(0.08, 0.12, 0.20, 1.00);
        GLBegin("quads");
        GLVertex3f(-halfWidth, -halfHeight, frontZ);
        GLVertex3f(halfWidth, -halfHeight, frontZ);
        GLVertex3f(halfWidth, -halfHeight, floorBackZ);
        GLVertex3f(-halfWidth, -halfHeight, floorBackZ);
        GLEnd();

        int gridSteps = 14;
        int i = 0;
        GLColor4f(0.18, 0.26, 0.38, 0.30);
        GLBegin("lines");
        while (i <= gridSteps) {
            float t = (i * 1.0) / gridSteps;
            float x = -halfWidth + t * BoxWidth;
            GLVertex3f(x, -halfHeight + 0.4, frontZ);
            GLVertex3f(x, -halfHeight + 0.4, floorBackZ);
            float z = frontZ + t * (floorBackZ - frontZ);
            GLVertex3f(-halfWidth, -halfHeight + 0.4, z);
            GLVertex3f(halfWidth, -halfHeight + 0.4, z);
            i = i + 1;
        }
        GLEnd();

        GLDisable("blend");
        GLColor3f(0.32, 0.46, 0.66);

        GLBegin("line_loop");
        GLVertex3f(-halfWidth, halfHeight, frontZ);
        GLVertex3f(halfWidth, halfHeight, frontZ);
        GLVertex3f(halfWidth, -halfHeight, frontZ);
        GLVertex3f(-halfWidth, -halfHeight, frontZ);
        GLEnd();

        GLBegin("line_loop");
        GLVertex3f(-halfWidth, halfHeight, backZ);
        GLVertex3f(halfWidth, halfHeight, backZ);
        GLVertex3f(halfWidth, -halfHeight, backZ);
        GLVertex3f(-halfWidth, -halfHeight, backZ);
        GLEnd();

        GLBegin("lines");
        GLVertex3f(-halfWidth, halfHeight, frontZ);
        GLVertex3f(-halfWidth, halfHeight, backZ);
        GLVertex3f(halfWidth, halfHeight, frontZ);
        GLVertex3f(halfWidth, halfHeight, backZ);
        GLVertex3f(halfWidth, -halfHeight, frontZ);
        GLVertex3f(halfWidth, -halfHeight, backZ);
        GLVertex3f(-halfWidth, -halfHeight, frontZ);
        GLVertex3f(-halfWidth, -halfHeight, backZ);
        GLEnd();

        GLEnable("blend");
        GLColor4f(0.12, 0.18, 0.26, 0.26);
        GLBegin("quads");
        GLVertex3f(-halfWidth, halfHeight, backZ);
        GLVertex3f(halfWidth, halfHeight, backZ);
        GLVertex3f(halfWidth, -halfHeight, backZ);
        GLVertex3f(-halfWidth, -halfHeight, backZ);
        GLEnd();

        GLDisable("blend");

        GLEnable("lighting");
    }
}

class BallSystem extends Renderable {
    float posX[NumBalls];
    float posY[NumBalls];
    float posZ[NumBalls];
    float velX[NumBalls];
    float velY[NumBalls];
    float velZ[NumBalls];
    float radius[NumBalls];
    int colorR[NumBalls];
    int colorG[NumBalls];
    int colorB[NumBalls];
    float screenX[NumBalls];
    float screenY[NumBalls];
    float screenRadius[NumBalls];
    float depthShade[NumBalls];
    SphereMesh mesh;
    float minSpeedValue;
    float maxSpeedValue;
    float cameraDistanceValue;

    void BallSystem() {
        myself.mesh = new SphereMesh();
        myself.minSpeedValue = MinSpeed;
        myself.maxSpeedValue = MaxSpeed;
        myself.cameraDistanceValue = CameraDistance;
    }

    void configure(float newMinSpeed, float newMaxSpeed, float newCameraDistance) {
        myself.minSpeedValue = newMinSpeed;
        myself.maxSpeedValue = newMaxSpeed;
        myself.cameraDistanceValue = newCameraDistance;
    }

    void initBalls(float minSpeed, float maxSpeed) {
        int i = 0;
        float halfWidth = BoxWidth * 0.5;
        float halfHeight = BoxHeight * 0.5;
        while (i < NumBalls) {
            float r = 12.0 + random(36);
            float availX = BoxWidth - 2.0 * r;
            float availY = BoxHeight - 2.0 * r;
            float availZ = BoxDepth - 2.0 * r;
            if (availX < 4.0) availX = 4.0;
            if (availY < 4.0) availY = 4.0;
            if (availZ < 4.0) availZ = 4.0;

            myself.radius[i] = r;
            myself.posX[i] = -halfWidth + r + randomUnit() * availX;
            myself.posY[i] = -halfHeight + r + randomUnit() * availY;
            myself.posZ[i] = -r - randomUnit() * (BoxDepth - 2.0 * r);

            int speedRange = trunc(maxSpeed - minSpeed);
            float speed = minSpeed + random(speedRange + 1) + randomUnit();
            float yaw = random(360) * (Pi / 180.0);
            float pitch = (random(121) - 60.0) * (Pi / 180.0);
            float dirXY = cos(pitch);
            myself.velX[i] = cos(yaw) * dirXY * speed;
            myself.velY[i] = sin(pitch) * speed;
            myself.velZ[i] = sin(yaw) * dirXY * speed;

            myself.colorR[i] = 90 + random(150);
            myself.colorG[i] = 90 + random(150);
            myself.colorB[i] = 90 + random(150);

            myself.screenX[i] = 0.0;
            myself.screenY[i] = 0.0;
            myself.screenRadius[i] = 0.0;
            myself.depthShade[i] = -1.0;
            i = i + 1;
        }
    }

    void update(float deltaTime) {
        BouncingBalls3DStepUltra(NumBalls, deltaTime, BoxWidth, BoxHeight, BoxDepth,
            WallElasticity, myself.minSpeedValue, myself.maxSpeedValue, VelocityDrag,
            myself.cameraDistanceValue, WindowWidth, WindowHeight,
            myself.posX, myself.posY, myself.posZ,
            myself.velX, myself.velY, myself.velZ, myself.radius,
            myself.screenX, myself.screenY, myself.screenRadius,
            myself.depthShade);
    }

    void draw() {
        // Ensure the fixed-function lighting state is restored before drawing
        // the per-ball geometry. Some drivers keep `GL_LIGHTING` disabled after
        // blended overlays, which caused the sphere mesh to render fully black.
        // Reset the material tracking and disable texturing so the vertex
        // colors coming from the material show up reliably. This mirrors the
        // older working sample by explicitly disabling blending before the
        // sphere pass so driver-specific blending state cannot wash out the lit
        // geometry.
        GLEnable("lighting");
        GLEnable("light0");
        GLEnable("color_material");
        GLColorMaterial("front", "ambient_and_diffuse");
        GLShadeModel("smooth");
        GLEnable("normalize");
        GLDisable("texture_2d");
        GLDisable("blend");

        int i = 0;
        while (i < NumBalls) {
            myself.drawBall(i);
            i = i + 1;
        }
    }

    void drawBall(int index) {
        float baseR = myself.colorR[index] / 255.0;
        float baseG = myself.colorG[index] / 255.0;
        float baseB = myself.colorB[index] / 255.0;
        float shade = myself.depthShade[index];

        if (shade < 0.0) shade = 0.5;
        if (shade > 1.0) shade = 1.0;

        // Keep a generous ambient contribution so the mesh stays visible even if
        // the physics helper reports a very dark depth shade. This mirrors the
        // older procedural sample that always drew the base color without
        // additional lighting math.
        float brightness = 0.45 + 0.55 * shade;
        float litR = baseR * brightness;
        float litG = baseG * brightness;
        float litB = baseB * brightness;

        if (litR > 1.0) litR = 1.0;
        if (litG > 1.0) litG = 1.0;
        if (litB > 1.0) litB = 1.0;

        GLPushMatrix();
        GLTranslatef(myself.posX[index], myself.posY[index], myself.posZ[index]);
        GLScalef(myself.radius[index], myself.radius[index], myself.radius[index]);
        GLColor3f(litR, litG, litB);
        myself.mesh.drawUnit();
        GLPopMatrix();
    }
}

class DemoApp extends Renderable {
    CameraRig camera;
    Starfield stars;
    LightingRig lighting;
    GlassArena arena;
    BallSystem balls;
    bool quit;
    bool paused;
    float targetFpsValue;
    int frameDelay;
    float deltaTime;
    float minSpeedValue;
    float maxSpeedValue;
    float cameraDistanceValue;
    float elapsed;

    void DemoApp() {
        myself.camera = new CameraRig(CameraDistance, 0.0, InitialCameraPitch,
            CameraOrbitSpeed, ManualYawSpeed, ManualPitchSpeed,
            MinCameraPitch, MaxCameraPitch);
        myself.stars = new Starfield();
        myself.lighting = new LightingRig();
        myself.arena = new GlassArena();
        myself.balls = new BallSystem();
        myself.quit = false;
        myself.paused = false;
        myself.targetFpsValue = TargetFPS;
        myself.minSpeedValue = MinSpeed;
        myself.maxSpeedValue = MaxSpeed;
        myself.cameraDistanceValue = CameraDistance;
        myself.frameDelay = trunc(1000 / myself.targetFpsValue);
        myself.deltaTime = 1.0 / myself.targetFpsValue;
        myself.elapsed = 0.0;
        myself.balls.configure(myself.minSpeedValue, myself.maxSpeedValue, myself.cameraDistanceValue);
    }

    void configureGraphics() {
        InitGraph3D(WindowWidth, WindowHeight, "Rea Multi Bouncing Balls 3D Advanced", 24, 8);
        bool gpuAccelerated = GLIsHardwareAccelerated();
        if (gpuAccelerated) {
            writeln("OpenGL acceleration: hardware (GPU).");
        } else {
            writeln("OpenGL acceleration: software fallback.");
        }
        GLViewport(0, 0, WindowWidth, WindowHeight);
        GLSetSwapInterval(1);
        myself.lighting.setup();
    }

    void init() {
        randomize();
        myself.configureGraphics();
        float fpsBoost = 1.7;
        float speedBoost = 2.45;
        float cameraPull = 0.66;
        BouncingBalls3DAccelerate(myself.targetFpsValue, myself.frameDelay, myself.deltaTime,
            myself.minSpeedValue, myself.maxSpeedValue, myself.cameraDistanceValue,
            fpsBoost, speedBoost, cameraPull);
        myself.balls.configure(myself.minSpeedValue, myself.maxSpeedValue, myself.cameraDistanceValue);
        myself.balls.initBalls(myself.minSpeedValue, myself.maxSpeedValue);
        myself.stars.init();
        elapsedSeconds = 0.0;
        myself.camera.yaw = 0.0;
        myself.camera.pitch = InitialCameraPitch;
        myself.camera.distance = myself.cameraDistanceValue;
        myself.camera.yawVelocity = CameraOrbitSpeed;
        myself.quit = false;
        myself.paused = false;
    }

    void update(float dt) {
        if (myself.paused) return;
        myself.balls.configure(myself.minSpeedValue, myself.maxSpeedValue, myself.cameraDistanceValue);
        myself.balls.update(dt);
        myself.elapsed = myself.elapsed + dt;
        elapsedSeconds = myself.elapsed;
        myself.camera.updateAutoYaw(dt);
    }

    void drawScene() {
        GLClearColor(0.05, 0.07, 0.12, 1.0);
        GLClear();

        GLMatrixMode("projection");
        GLLoadIdentity();
        float aspect = WindowWidth * 1.0 / WindowHeight;
        GLPerspective(55.0, aspect, 24.0, 8000.0);

        GLMatrixMode("modelview");
        GLLoadIdentity();
        GLTranslatef(0.0, 0.0, -myself.camera.distance);
        GLRotatef(myself.camera.pitch, 1.0, 0.0, 0.0);
        GLRotatef(myself.camera.yaw, 0.0, 1.0, 0.0);

        GLLightfv("light0", "position", LightDirX, LightDirY, LightDirZ, 0.0);

        myself.stars.draw();
        myself.balls.draw();
        myself.arena.draw();

        GLSwapWindow();
    }

    void adjustCameraFromInput() {
        bool leftDown = IsKeyDown(ScanCodeLeft);
        bool rightDown = IsKeyDown(ScanCodeRight);
        bool upDown = IsKeyDown(ScanCodeUp);
        bool downDown = IsKeyDown(ScanCodeDown);
        bool closer = IsKeyDown(ScanCodePageDown);
        bool further = IsKeyDown(ScanCodePageUp);

        float yawInput = 0.0;
        if (leftDown) yawInput = yawInput - 1.0;
        if (rightDown) yawInput = yawInput + 1.0;
        if (yawInput == 0.0) {
            myself.camera.yawVelocity = myself.camera.autoOrbitSpeed;
        } else {
            myself.camera.yawVelocity = yawInput * myself.camera.manualYawSpeedValue;
        }

        if (upDown && !downDown) {
            myself.camera.pitch = myself.camera.pitch + myself.deltaTime * myself.camera.manualPitchSpeedValue;
        } else if (downDown && !upDown) {
            myself.camera.pitch = myself.camera.pitch - myself.deltaTime * myself.camera.manualPitchSpeedValue;
        }

        if (closer && !further) {
            myself.camera.distance = myself.camera.distance - 320.0 * myself.deltaTime;
            if (myself.camera.distance < 960.0) myself.camera.distance = 960.0;
        } else if (further && !closer) {
            myself.camera.distance = myself.camera.distance + 320.0 * myself.deltaTime;
            if (myself.camera.distance > 2800.0) myself.camera.distance = 2800.0;
        }

        myself.cameraDistanceValue = myself.camera.distance;
        myself.camera.clampPitch();
    }

    void handleInput() {
        myself.adjustCameraFromInput();
        if (keypressed()) {
            char key = readkey();
            switch (key) {
                case 'q':
                case 'Q':
                    myself.quit = true;
                    break;
                case ' ':
                    myself.paused = !myself.paused;
                    break;
                case 'r':
                case 'R':
                    myself.balls.initBalls(myself.minSpeedValue, myself.maxSpeedValue);
                    myself.elapsed = 0.0;
                    elapsedSeconds = 0.0;
                    break;
                default:
                    break;
            }
        }
    }

    void run() {
        myself.init();
        writeln("Multi Bouncing Balls 3D Ultra Advanced ... Press Q to quit, Space to pause, R to reseed.");
        while (!myself.quit) {
            if (QuitRequested()) {
                myself.quit = true;
                break;
            }
            myself.handleInput();
            myself.update(myself.deltaTime);
            myself.drawScene();
            GraphLoop(myself.frameDelay);
        }
        CloseGraph3D();
        writeln("Demo finished.");
    }
}

DemoApp app = new DemoApp();
app.run();
