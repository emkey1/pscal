#!/usr/bin/env rea
// SDL Multi Bouncing Balls 3D demo rendered with the OpenGL helpers.
// This version uses the fixed-function pipeline (lighting, materials,
// blending) instead of the 2D circle impostor trick.

const int WindowWidth = 1600;
const int WindowHeight = 1000;

float TargetFPS = 60.0;

const int NumBalls = 10;
const float BoxWidth = 720.0;
const float BoxHeight = 420.0;
const float BoxDepth = 300.0;
const float WallElasticity = 1.08;
float MinSpeed = 90.0;
float MaxSpeed = 360.0;
const float VelocityDrag = 0.995;

float CameraDistance = 1050.0;
const float CameraPitch = -12.0;
const float CameraOrbitSpeed = 85.0;

const int SphereStacks = 20;
const int SphereSlices = 36;
const float Pi = 3.1415926535;

const float LightDirX = -0.55;
const float LightDirY = -0.35;
const float LightDirZ = 0.78;
const float AmbientLevel = 0.18;

float posX[NumBalls];
float posY[NumBalls];
float posZ[NumBalls];
float velX[NumBalls];
float velY[NumBalls];
float velZ[NumBalls];
float radii[NumBalls];
float screenX[NumBalls];
float screenY[NumBalls];
float screenRadius[NumBalls];
float depthShade[NumBalls];
int colorR[NumBalls];
int colorG[NumBalls];
int colorB[NumBalls];

bool quit;
bool paused;
int FrameDelay;
float DeltaTime;
float elapsedSeconds;
float cameraYaw;

float randomUnit() {
    return random(10000) / 10000.0;
}

void initBalls() {
    int i = 0;
    float halfWidth = BoxWidth * 0.5;
    float halfHeight = BoxHeight * 0.5;
    while (i < NumBalls) {
        float r = 12.0 + random(26);
        float availX = BoxWidth - 2.0 * r;
        float availY = BoxHeight - 2.0 * r;
        float availZ = BoxDepth - 2.0 * r;
        if (availX < 4.0) availX = 4.0;
        if (availY < 4.0) availY = 4.0;
        if (availZ < 4.0) availZ = 4.0;

        radii[i] = r;
        posX[i] = -halfWidth + r + randomUnit() * availX;
        posY[i] = -halfHeight + r + randomUnit() * availY;
        posZ[i] = -r - randomUnit() * (BoxDepth - 2.0 * r);

        int speedRange = trunc(MaxSpeed - MinSpeed);
        float speed = MinSpeed + random(speedRange + 1) + randomUnit();
        float yaw = random(360) * (Pi / 180.0);
        float pitch = (random(121) - 60.0) * (Pi / 180.0);
        float dirXY = cos(pitch);
        velX[i] = cos(yaw) * dirXY * speed;
        velY[i] = sin(pitch) * speed;
        velZ[i] = sin(yaw) * dirXY * speed;

        colorR[i] = 90 + random(150);
        colorG[i] = 90 + random(150);
        colorB[i] = 90 + random(150);
        i = i + 1;
    }
}

void setupLighting() {
    GLClearDepth(1.0);
    GLDepthTest(true);
    GLEnable("lighting");
    GLEnable("light0");
    GLEnable("color_material");
    GLEnable("normalize");

    GLShadeModel("smooth");
    GLColorMaterial("front", "ambient_and_diffuse");

    float ambient = AmbientLevel;
    GLLightfv("light0", "ambient", ambient, ambient, ambient, 1.0);
    GLLightfv("light0", "diffuse", 0.90, 0.92, 0.95, 1.0);
    GLLightfv("light0", "specular", 0.85, 0.90, 0.95, 1.0);

    GLMaterialfv("front", "specular", 0.55, 0.60, 0.70, 1.0);
    GLMaterialf("front", "shininess", 42.0);
}

void drawUnitSphere() {
    int stack = 0;
    while (stack < SphereStacks) {
        float phi0 = -Pi * 0.5 + Pi * stack / SphereStacks;
        float phi1 = -Pi * 0.5 + Pi * (stack + 1) / SphereStacks;
        float cosPhi0 = cos(phi0);
        float sinPhi0 = sin(phi0);
        float cosPhi1 = cos(phi1);
        float sinPhi1 = sin(phi1);

        GLBegin("triangle_strip");
        int slice = 0;
        while (slice <= SphereSlices) {
            float theta = 2.0 * Pi * slice / SphereSlices;
            float cosTheta = cos(theta);
            float sinTheta = sin(theta);

            float n0x = cosPhi0 * cosTheta;
            float n0y = sinPhi0;
            float n0z = cosPhi0 * sinTheta;
            float n1x = cosPhi1 * cosTheta;
            float n1y = sinPhi1;
            float n1z = cosPhi1 * sinTheta;

            GLNormal3f(n1x, n1y, n1z);
            GLVertex3f(n1x, n1y, n1z);

            GLNormal3f(n0x, n0y, n0z);
            GLVertex3f(n0x, n0y, n0z);

            slice = slice + 1;
        }
        GLEnd();
        stack = stack + 1;
    }
}

void drawBall(int index) {
    float baseR = colorR[index] / 255.0;
    float baseG = colorG[index] / 255.0;
    float baseB = colorB[index] / 255.0;

    GLPushMatrix();
    GLTranslatef(posX[index], posY[index], posZ[index]);
    GLScalef(radii[index], radii[index], radii[index]);
    GLColor3f(baseR, baseG, baseB);
    drawUnitSphere();
    GLPopMatrix();
}

void drawBalls() {
    int i = 0;
    while (i < NumBalls) {
        drawBall(i);
        i = i + 1;
    }
}

void drawGlassBox() {
    float halfWidth = BoxWidth * 0.5;
    float halfHeight = BoxHeight * 0.5;
    float frontZ = -12.0;
    float backZ = -BoxDepth;

    GLDisable("lighting");
    GLEnable("blend");
    GLBlendFunc("src_alpha", "one_minus_src_alpha");

    GLColor4f(0.10, 0.18, 0.28, 0.45);
    GLBegin("quads");
        GLVertex3f(-halfWidth, halfHeight, backZ);
        GLVertex3f(halfWidth, halfHeight, backZ);
        GLVertex3f(halfWidth, -halfHeight, backZ);
        GLVertex3f(-halfWidth, -halfHeight, backZ);
    GLEnd();

    GLColor4f(0.08, 0.12, 0.20, 0.35);
    GLBegin("quads");
        GLVertex3f(-halfWidth, -halfHeight, frontZ);
        GLVertex3f(halfWidth, -halfHeight, frontZ);
        GLVertex3f(halfWidth, -halfHeight, backZ);
        GLVertex3f(-halfWidth, -halfHeight, backZ);
    GLEnd();

    int gridSteps = 12;
    int i = 0;
    GLColor4f(0.18, 0.26, 0.38, 0.30);
    GLBegin("lines");
        while (i <= gridSteps) {
            float t = (i * 1.0) / gridSteps;
            float x = -halfWidth + t * BoxWidth;
            GLVertex3f(x, -halfHeight + 0.2, frontZ);
            GLVertex3f(x, -halfHeight + 0.2, backZ);
            float z = frontZ + t * (backZ - frontZ);
            GLVertex3f(-halfWidth, -halfHeight + 0.2, z);
            GLVertex3f(halfWidth, -halfHeight + 0.2, z);
            i = i + 1;
        }
    GLEnd();

    GLDisable("blend");
    GLColor3f(0.32, 0.46, 0.66);

    GLBegin("line_loop");
        GLVertex3f(-halfWidth, halfHeight, frontZ);
        GLVertex3f(halfWidth, halfHeight, frontZ);
        GLVertex3f(halfWidth, -halfHeight, frontZ);
        GLVertex3f(-halfWidth, -halfHeight, frontZ);
    GLEnd();

    GLBegin("line_loop");
        GLVertex3f(-halfWidth, halfHeight, backZ);
        GLVertex3f(halfWidth, halfHeight, backZ);
        GLVertex3f(halfWidth, -halfHeight, backZ);
        GLVertex3f(-halfWidth, -halfHeight, backZ);
    GLEnd();

    GLBegin("lines");
        GLVertex3f(-halfWidth, halfHeight, frontZ);
        GLVertex3f(-halfWidth, halfHeight, backZ);
        GLVertex3f(halfWidth, halfHeight, frontZ);
        GLVertex3f(halfWidth, halfHeight, backZ);
        GLVertex3f(halfWidth, -halfHeight, frontZ);
        GLVertex3f(halfWidth, -halfHeight, backZ);
        GLVertex3f(-halfWidth, -halfHeight, frontZ);
        GLVertex3f(-halfWidth, -halfHeight, backZ);
    GLEnd();

    GLEnable("lighting");
}

void drawScene() {
    GLClearColor(0.05, 0.07, 0.12, 1.0);
    GLClear();

    GLMatrixMode("projection");
    GLLoadIdentity();
    float aspect = WindowWidth * 1.0 / WindowHeight;
    GLPerspective(55.0, aspect, 24.0, 8000.0);

    GLMatrixMode("modelview");
    GLLoadIdentity();
    GLTranslatef(0.0, 0.0, -CameraDistance);
    GLRotatef(CameraPitch, 1.0, 0.0, 0.0);
    GLRotatef(cameraYaw, 0.0, 1.0, 0.0);

    GLLightfv("light0", "position", LightDirX, LightDirY, LightDirZ, 0.0);

    drawGlassBox();
    drawBalls();

    GLSwapWindow();
}

void updateSimulation(float deltaTime) {
    if (paused) return;
    BouncingBalls3DStepUltra(NumBalls, deltaTime, BoxWidth, BoxHeight, BoxDepth,
        WallElasticity, MinSpeed, MaxSpeed, VelocityDrag,
        CameraDistance, WindowWidth, WindowHeight,
        posX, posY, posZ, velX, velY, velZ, radii,
        screenX, screenY, screenRadius, depthShade);
    elapsedSeconds = elapsedSeconds + deltaTime;
    cameraYaw = cameraYaw + deltaTime * CameraOrbitSpeed;
    if (cameraYaw >= 360.0) {
        cameraYaw = cameraYaw - 360.0;
    }
}

void handleInput() {
    if (keypressed()) {
        char key = readkey();
        if (key == 'q' || key == 'Q') {
            quit = true;
        } else if (key == ' ') {
            paused = !paused;
        }
    }
}

void initApp() {
    InitGraph3D(WindowWidth, WindowHeight, "Rea Multi Bouncing Balls 3D", 24, 8);
    GLViewport(0, 0, WindowWidth, WindowHeight);
    GLSetSwapInterval(1);
    setupLighting();

    FrameDelay = trunc(1000 / TargetFPS);
    DeltaTime = 1.0 / TargetFPS;

    float fpsBoost = 1.6;
    float speedBoost = 2.3;
    float cameraPull = 0.7;
    BouncingBalls3DAccelerate(TargetFPS, FrameDelay, DeltaTime,
        MinSpeed, MaxSpeed, CameraDistance,
        fpsBoost, speedBoost, cameraPull);

    randomize();
    initBalls();

    quit = false;
    paused = false;
    elapsedSeconds = 0.0;
    cameraYaw = 0.0;
}

void run() {
    initApp();
    writeln("Multi Bouncing Balls 3D (OpenGL) ... Press Q to quit, Space to pause.");
    while (!quit) {
        if (QuitRequested()) {
            quit = true;
            break;
        }
        handleInput();
        updateSimulation(DeltaTime);
        drawScene();
        GraphLoop(FrameDelay);
    }
    CloseGraph3D();
    writeln("Demo finished.");
}

run();
