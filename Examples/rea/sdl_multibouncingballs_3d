#!/usr/bin/env rea
// SDL Multi Bouncing Balls 3D demo for Rea with extended builtin acceleration.
// Renders a field of spheres bouncing inside a glass box using one face as the
// viewing window. Requires building Pscal with SDL support and the user
// extended builtins enabled so the BouncingBalls3DStep helper is available.

const int WindowWidth = 1280;
const int WindowHeight = 720;
const int TargetFPS = 60;
const int NumBalls = 120;
const float BoxWidth = 720.0;
const float BoxHeight = 420.0;
const float BoxDepth = 640.0;
const float WallElasticity = 1.08;
const float MinSpeed = 90.0;
const float MaxSpeed = 360.0;
const float VelocityDrag = 0.995;
const float CameraDistance = 720.0;
const int FrameMargin = 48;

float posX[NumBalls];
float posY[NumBalls];
float posZ[NumBalls];
float velX[NumBalls];
float velY[NumBalls];
float velZ[NumBalls];
float radii[NumBalls];
float screenX[NumBalls];
float screenY[NumBalls];
float screenRadius[NumBalls];
float depthShade[NumBalls];
int drawOrder[NumBalls];
int colorR[NumBalls];
int colorG[NumBalls];
int colorB[NumBalls];

int FrameDelay;
bool quit;
bool paused;
float elapsedSeconds;

float randomUnit() {
  return random(10000) / 10000.0;
}

void bar(int left, int top, int right, int bottom) {
  if (left > right) {
    int temp = left;
    left = right;
    right = temp;
  }
  if (top > bottom) {
    int temp = top;
    top = bottom;
    bottom = temp;
  }
  int y = top;
  while (y <= bottom) {
    drawline(left, y, right, y);
    y = y + 1;
  }
}

void initDrawOrder() {
  int i = 0;
  while (i < NumBalls) {
    drawOrder[i] = i;
    i = i + 1;
  }
}

void sortDrawOrderByDepth() {
  int i = 1;
  while (i < NumBalls) {
    int currentIndex = drawOrder[i];
    float currentShade = depthShade[currentIndex];
    int j = i - 1;
    while (j >= 0 && depthShade[drawOrder[j]] > currentShade) {
      drawOrder[j + 1] = drawOrder[j];
      j = j - 1;
    }
    drawOrder[j + 1] = currentIndex;
    i = i + 1;
  }
}

void initBalls() {
  int i = 0;
  float halfWidth = BoxWidth * 0.5;
  float halfHeight = BoxHeight * 0.5;
  while (i < NumBalls) {
    float r = 12.0 + random(26);
    float availX = (BoxWidth - 2.0 * r);
    float availY = (BoxHeight - 2.0 * r);
    float availZ = (BoxDepth - 2.0 * r);
    if (availX < 4.0) availX = 4.0;
    if (availY < 4.0) availY = 4.0;
    if (availZ < 4.0) availZ = 4.0;
    radii[i] = r;
    posX[i] = -halfWidth + r + randomUnit() * availX;
    posY[i] = -halfHeight + r + randomUnit() * availY;
    posZ[i] = -r - randomUnit() * (BoxDepth - 2.0 * r);
    int speedRange = trunc(MaxSpeed - MinSpeed);
    float speed = MinSpeed + random(speedRange + 1) + randomUnit();
    float yaw = random(360);
    float pitch = random(121) - 60.0;
    float dirXY = cos(pitch);
    velX[i] = cos(yaw) * dirXY * speed;
    velY[i] = sin(pitch) * speed;
    velZ[i] = sin(yaw) * dirXY * speed;
    colorR[i] = 90 + random(150);
    colorG[i] = 90 + random(150);
    colorB[i] = 90 + random(150);
    screenRadius[i] = 0.0;
    screenX[i] = 0.0;
    screenY[i] = 0.0;
    depthShade[i] = 0.0;
    i = i + 1;
  }
  initDrawOrder();
}

void drawFrameOverlay() {
  int left = FrameMargin;
  int top = FrameMargin;
  int right = WindowWidth - FrameMargin;
  int bottom = WindowHeight - FrameMargin;
  setrgbcolor(24, 28, 42);
  bar(0, 0, WindowWidth, WindowHeight);
  setrgbcolor(40, 48, 70);
  bar(left - 6, top - 6, right + 6, bottom + 6);
  setrgbcolor(12, 16, 26);
  bar(left - 2, top - 2, right + 2, bottom + 2);
  setrgbcolor(18, 28, 42);
  bar(left, top, right, bottom);
  setrgbcolor(64, 84, 120);
  drawline(left, top, right, top);
  drawline(right, top, right, bottom);
  drawline(right, bottom, left, bottom);
  drawline(left, bottom, left, top);
  setrgbcolor(110, 130, 170);
  drawline(left, top, left + 120, top - 36);
  drawline(right, top, right + 120, top - 36);
  drawline(right, bottom, right + 120, bottom + 36);
  drawline(left, bottom, left + 120, bottom + 36);
}

void drawBalls() {
  int i = 0;
  int left = FrameMargin;
  int top = FrameMargin;
  int right = WindowWidth - FrameMargin;
  int bottom = WindowHeight - FrameMargin;
  while (i < NumBalls) {
    int ballIndex = drawOrder[i];
    float shade = depthShade[ballIndex];
    if (shade >= 0.0) {
      int sx = FrameMargin + trunc(screenX[ballIndex]);
      int sy = FrameMargin + trunc(screenY[ballIndex]);
      int sr = trunc(screenRadius[ballIndex]);
      if (sr < 1) sr = 1;
      if (sx >= left - sr && sx <= right + sr && sy >= top - sr && sy <= bottom + sr) {
        float glow = 0.35 + shade * 0.65;
        if (glow > 1.1) glow = 1.1;
        int r = trunc(colorR[ballIndex] * glow);
        int g = trunc(colorG[ballIndex] * glow);
        int b = trunc(colorB[ballIndex] * glow);
        if (r > 255) r = 255;
        if (g > 255) g = 255;
        if (b > 255) b = 255;
        setrgbcolor(r, g, b);
        fillcircle(sx, sy, sr);
        int rimR = r + 32;
        int rimG = g + 32;
        int rimB = b + 32;
        if (rimR > 255) rimR = 255;
        if (rimG > 255) rimG = 255;
        if (rimB > 255) rimB = 255;
        setrgbcolor(rimR, rimG, rimB);
        drawcircle(sx, sy, sr);
        int highlightR = rimR + 16;
        int highlightG = rimG + 16;
        int highlightB = rimB + 16;
        if (highlightR > 255) highlightR = 255;
        if (highlightG > 255) highlightG = 255;
        if (highlightB > 255) highlightB = 255;
        setrgbcolor(highlightR, highlightG, highlightB);
        int specX = sx - trunc(sr * 0.35);
        int specY = sy - trunc(sr * 0.35);
        int specRadius = trunc(sr * 0.25);
        if (specRadius < 1) specRadius = 1;
        drawcircle(specX, specY, specRadius);
      }
    }
    i = i + 1;
  }
}

void drawHud() {
  setrgbcolor(200, 215, 235);
  int textX = FrameMargin + 12;
  int hudTop = FrameMargin + 24;
  string label = "Multi Bouncing Balls 3D - Press Q to quit, Space to pause";
  outtextxy(textX, hudTop, label);
  string timeLabel = "Elapsed: " + formatfloat(elapsedSeconds, 1) + "s";
  outtextxy(textX, FrameMargin + 48, timeLabel);
}

void updateSimulation(float deltaTime) {
  if (paused) return;
  bouncingballs3dstep(NumBalls, deltaTime, BoxWidth, BoxHeight, BoxDepth,
                      WallElasticity, MinSpeed, MaxSpeed, VelocityDrag,
                      CameraDistance, WindowWidth - FrameMargin * 2,
                      WindowHeight - FrameMargin * 2,
                      posX, posY, posZ,
                      velX, velY, velZ,
                      radii,
                      screenX, screenY, screenRadius, depthShade);
  sortDrawOrderByDepth();
  elapsedSeconds = elapsedSeconds + deltaTime;
}

void handleInput() {
  if (keypressed()) {
    char key = readkey();
    if (key == 'q' || key == 'Q') {
      quit = true;
    } else if (key == ' ') {
      paused = !paused;
    }
  }
}

void drawScene() {
  drawFrameOverlay();
  drawBalls();
  drawHud();
  updatescreen();
}

void initApp() {
  if (!hasextbuiltin("user", "BouncingBalls3DStep")) {
    writeln("Error: BouncingBalls3DStep extended builtin not available.");
    writeln("Rebuild with ENABLE_EXT_BUILTIN_USER=ON to run this demo.");
    halt();
  }
  initgraph(WindowWidth, WindowHeight, "Rea Multi Bouncing Balls 3D");
  string systemFontPath = "/usr/local/Pscal/fonts/Roboto/static/Roboto-Regular.ttf";
  string repoFontPath1 = "fonts/Roboto/static/Roboto-Regular.ttf";
  string repoFontPath2 = "../../fonts/Roboto/static/Roboto-Regular.ttf";
  if (fileexists(systemFontPath)) {
    inittextsystem(systemFontPath, 18);
  } else if (fileexists(repoFontPath1)) {
    inittextsystem(repoFontPath1, 18);
  } else {
    inittextsystem(repoFontPath2, 18);
  }
  randomize();
  FrameDelay = trunc(1000 / TargetFPS);
  quit = false;
  paused = false;
  elapsedSeconds = 0.0;
  initBalls();
}

void run() {
  initApp();
  writeln("Multi Bouncing Balls 3D... Press Q to quit.");
  float deltaTime = 1.0 / TargetFPS;
  while (!quit) {
    handleInput();
    updateSimulation(deltaTime);
    drawScene();
    graphloop(FrameDelay);
  }
  closegraph();
  writeln("Demo finished.");
}

run();
