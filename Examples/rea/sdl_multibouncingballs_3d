#!/usr/bin/env rea
// SDL Multi Bouncing Balls 3D demo for Rea with a manual physics step.
// Renders a field of spheres bouncing inside a glass box using one face as the
// viewing window. Requires building Pscal with SDL support.

const int WindowWidth = 1280;
const int WindowHeight = 720;
const int TargetFPS = 60;
const int NumBalls = 120;
const float BoxWidth = 720.0;
const float BoxHeight = 420.0;
const float BoxDepth = 640.0;
const float WallElasticity = 1.08;
const float MinSpeed = 90.0;
const float MaxSpeed = 360.0;
const float VelocityDrag = 0.995;
const float CameraDistance = 720.0;
const int FrameMargin = 48;

float posX[NumBalls];
float posY[NumBalls];
float posZ[NumBalls];
float velX[NumBalls];
float velY[NumBalls];
float velZ[NumBalls];
float radii[NumBalls];
float screenX[NumBalls];
float screenY[NumBalls];
float screenRadius[NumBalls];
float depthShade[NumBalls];
int drawOrder[NumBalls];
int colorR[NumBalls];
int colorG[NumBalls];
int colorB[NumBalls];

float enforceSpeed(float value, float minSpeed, float maxSpeed) {
  float absVal = abs(value);
  if (absVal < minSpeed) {
    if (value < 0.0) {
      return -minSpeed;
    } else {
      return minSpeed;
    }
  }
  if (value > maxSpeed) return maxSpeed;
  if (value < -maxSpeed) return -maxSpeed;
  return value;
}

int FrameDelay;
bool quit;
bool paused;
float elapsedSeconds;

float randomUnit() {
  return random(10000) / 10000.0;
}

void bar(int left, int top, int right, int bottom) {
  if (left > right) {
    int temp = left;
    left = right;
    right = temp;
  }
  if (top > bottom) {
    int temp = top;
    top = bottom;
    bottom = temp;
  }
  int y = top;
  while (y <= bottom) {
    drawline(left, y, right, y);
    y = y + 1;
  }
}

void initDrawOrder() {
  int i = 0;
  while (i < NumBalls) {
    drawOrder[i] = i;
    i = i + 1;
  }
}

void sortDrawOrderByDepth() {
  int i = 1;
  while (i < NumBalls) {
    int currentIndex = drawOrder[i];
    float currentShade = depthShade[currentIndex];
    int j = i - 1;
    while (j >= 0 && depthShade[drawOrder[j]] > currentShade) {
      drawOrder[j + 1] = drawOrder[j];
      j = j - 1;
    }
    drawOrder[j + 1] = currentIndex;
    i = i + 1;
  }
}

void initBalls() {
  int i = 0;
  float halfWidth = BoxWidth * 0.5;
  float halfHeight = BoxHeight * 0.5;
  while (i < NumBalls) {
    float r = 12.0 + random(26);
    float availX = (BoxWidth - 2.0 * r);
    float availY = (BoxHeight - 2.0 * r);
    float availZ = (BoxDepth - 2.0 * r);
    if (availX < 4.0) availX = 4.0;
    if (availY < 4.0) availY = 4.0;
    if (availZ < 4.0) availZ = 4.0;
    radii[i] = r;
    posX[i] = -halfWidth + r + randomUnit() * availX;
    posY[i] = -halfHeight + r + randomUnit() * availY;
    posZ[i] = -r - randomUnit() * (BoxDepth - 2.0 * r);
    int speedRange = trunc(MaxSpeed - MinSpeed);
    float speed = MinSpeed + random(speedRange + 1) + randomUnit();
    float yaw = random(360);
    float pitch = random(121) - 60.0;
    float dirXY = cos(pitch);
    velX[i] = cos(yaw) * dirXY * speed;
    velY[i] = sin(pitch) * speed;
    velZ[i] = sin(yaw) * dirXY * speed;
    colorR[i] = 90 + random(150);
    colorG[i] = 90 + random(150);
    colorB[i] = 90 + random(150);
    screenRadius[i] = 0.0;
    screenX[i] = 0.0;
    screenY[i] = 0.0;
    depthShade[i] = 0.0;
    i = i + 1;
  }
  initDrawOrder();
}

void drawFrameOverlay() {
  int left = FrameMargin;
  int top = FrameMargin;
  int right = WindowWidth - FrameMargin;
  int bottom = WindowHeight - FrameMargin;
  setrgbcolor(24, 28, 42);
  bar(0, 0, WindowWidth, WindowHeight);
  setrgbcolor(40, 48, 70);
  bar(left - 6, top - 6, right + 6, bottom + 6);
  setrgbcolor(12, 16, 26);
  bar(left - 2, top - 2, right + 2, bottom + 2);
  setrgbcolor(18, 28, 42);
  bar(left, top, right, bottom);
  setrgbcolor(64, 84, 120);
  drawline(left, top, right, top);
  drawline(right, top, right, bottom);
  drawline(right, bottom, left, bottom);
  drawline(left, bottom, left, top);
  setrgbcolor(110, 130, 170);
  drawline(left, top, left + 120, top - 36);
  drawline(right, top, right + 120, top - 36);
  drawline(right, bottom, right + 120, bottom + 36);
  drawline(left, bottom, left + 120, bottom + 36);
}

void drawBalls() {
  int i = 0;
  int left = FrameMargin;
  int top = FrameMargin;
  int right = WindowWidth - FrameMargin;
  int bottom = WindowHeight - FrameMargin;
  while (i < NumBalls) {
    int ballIndex = drawOrder[i];
    float closeness = depthShade[ballIndex];
    if (closeness >= 0.0) {
      int sx = FrameMargin + trunc(screenX[ballIndex]);
      int sy = FrameMargin + trunc(screenY[ballIndex]);
      int sr = trunc(screenRadius[ballIndex]);
      if (sr < 1) sr = 1;
      if (sx >= left - sr && sx <= right + sr && sy >= top - sr && sy <= bottom + sr) {
        float bodyIntensity = 0.55 + closeness * 0.45;
        float shadowIntensity = 0.35 + closeness * 0.25;
        int baseR = trunc(colorR[ballIndex] * bodyIntensity);
        int baseG = trunc(colorG[ballIndex] * bodyIntensity);
        int baseB = trunc(colorB[ballIndex] * bodyIntensity);
        int shadowR = trunc(colorR[ballIndex] * shadowIntensity);
        int shadowG = trunc(colorG[ballIndex] * shadowIntensity);
        int shadowB = trunc(colorB[ballIndex] * shadowIntensity);
        if (baseR > 255) baseR = 255;
        if (baseG > 255) baseG = 255;
        if (baseB > 255) baseB = 255;
        if (shadowR > 255) shadowR = 255;
        if (shadowG > 255) shadowG = 255;
        if (shadowB > 255) shadowB = 255;

        int shadowOffsetX = trunc(sr * 0.18);
        int shadowOffsetY = trunc(sr * 0.22);
        int shadowRadius = trunc(sr * 1.05);
        setrgbcolor(shadowR, shadowG, shadowB);
        fillcircle(sx + shadowOffsetX, sy + shadowOffsetY, shadowRadius);

        setrgbcolor(baseR, baseG, baseB);
        fillcircle(sx, sy, sr);

        int layers = 4;
        int layer = 1;
        while (layer <= layers) {
          float t = layer / float(layers + 1);
          float layerScale = 1.0 - t * 0.45;
          int layerRadius = trunc(sr * layerScale);
          if (layerRadius < 1) layerRadius = 1;
          float highlightBoost = 0.75 + (1.0 - t) * 0.25;
          int layerR = trunc(baseR * highlightBoost);
          int layerG = trunc(baseG * highlightBoost);
          int layerB = trunc(baseB * highlightBoost);
          if (layerR > 255) layerR = 255;
          if (layerG > 255) layerG = 255;
          if (layerB > 255) layerB = 255;
          int offsetX = trunc(-sr * 0.28 * (1.0 - t));
          int offsetY = trunc(-sr * 0.32 * (1.0 - t));
          setrgbcolor(layerR, layerG, layerB);
          fillcircle(sx + offsetX, sy + offsetY, layerRadius);
          layer = layer + 1;
        }

        int outlineR = baseR + 28;
        int outlineG = baseG + 28;
        int outlineB = baseB + 28;
        if (outlineR > 255) outlineR = 255;
        if (outlineG > 255) outlineG = 255;
        if (outlineB > 255) outlineB = 255;
        setrgbcolor(outlineR, outlineG, outlineB);
        drawcircle(sx, sy, sr);

        int highlightRadius = trunc(sr * 0.22);
        if (highlightRadius < 1) highlightRadius = 1;
        int highlightX = sx - trunc(sr * 0.4);
        int highlightY = sy - trunc(sr * 0.45);
        int highlightR = baseR + trunc(90 * (0.6 + closeness * 0.4));
        int highlightG = baseG + trunc(90 * (0.6 + closeness * 0.4));
        int highlightB = baseB + trunc(90 * (0.6 + closeness * 0.4));
        if (highlightR > 255) highlightR = 255;
        if (highlightG > 255) highlightG = 255;
        if (highlightB > 255) highlightB = 255;
        setrgbcolor(highlightR, highlightG, highlightB);
        fillcircle(highlightX, highlightY, highlightRadius);
      }
    }
    i = i + 1;
  }
}

void drawHud() {
  setrgbcolor(200, 215, 235);
  int textX = FrameMargin + 12;
  int hudTop = FrameMargin + 24;
  string label = "Multi Bouncing Balls 3D - Press Q to quit, Space to pause";
  outtextxy(textX, hudTop, label);
  string timeLabel = "Elapsed: " + formatfloat(elapsedSeconds, 1) + "s";
  outtextxy(textX, FrameMargin + 48, timeLabel);
}

void updateSimulation(float deltaTime) {
  if (paused) return;
  float screenWidth = WindowWidth - FrameMargin * 2;
  float screenHeight = WindowHeight - FrameMargin * 2;
  BouncingBalls3DStep(NumBalls,
                      deltaTime,
                      BoxWidth,
                      BoxHeight,
                      BoxDepth,
                      WallElasticity,
                      MinSpeed,
                      MaxSpeed,
                      VelocityDrag,
                      CameraDistance,
                      screenWidth,
                      screenHeight,
                      posX,
                      posY,
                      posZ,
                      velX,
                      velY,
                      velZ,
                      radii,
                      screenX,
                      screenY,
                      screenRadius,
                      depthShade);

  int i = 0;
  while (i < NumBalls) {
    if (depthShade[i] >= 0.0) {
      float depth = (depthShade[i] - 0.25) / 0.75;
      if (depth < 0.0) depth = 0.0;
      if (depth > 1.0) depth = 1.0;
      float proximity = 1.0 - depth;
      float depthScale = 0.65 + 0.9 * proximity;
      float sr = screenRadius[i] * depthScale;
      if (sr < 1.0) sr = 1.0;
      screenRadius[i] = sr;
      depthShade[i] = proximity;
    }
    i = i + 1;
  }

  sortDrawOrderByDepth();
  elapsedSeconds = elapsedSeconds + deltaTime;
}

void handleInput() {
  if (keypressed()) {
    char key = readkey();
    if (key == 'q' || key == 'Q') {
      quit = true;
    } else if (key == ' ') {
      paused = !paused;
    }
  }
}

void drawScene() {
  drawFrameOverlay();
  drawBalls();
  drawHud();
  updatescreen();
}

void initApp() {
  initgraph(WindowWidth, WindowHeight, "Rea Multi Bouncing Balls 3D");
  string systemFontPath = "/usr/local/Pscal/fonts/Roboto/static/Roboto-Regular.ttf";
  string repoFontPath1 = "fonts/Roboto/static/Roboto-Regular.ttf";
  string repoFontPath2 = "../../fonts/Roboto/static/Roboto-Regular.ttf";
  if (fileexists(systemFontPath)) {
    inittextsystem(systemFontPath, 18);
  } else if (fileexists(repoFontPath1)) {
    inittextsystem(repoFontPath1, 18);
  } else {
    inittextsystem(repoFontPath2, 18);
  }
  randomize();
  FrameDelay = trunc(1000 / TargetFPS);
  quit = false;
  paused = false;
  elapsedSeconds = 0.0;
  initBalls();
}

void run() {
  initApp();
  writeln("Multi Bouncing Balls 3D... Press Q to quit.");
  float deltaTime = 1.0 / TargetFPS;
  while (!quit) {
    handleInput();
    updateSimulation(deltaTime);
    drawScene();
    graphloop(FrameDelay);
  }
  closegraph();
  writeln("Demo finished.");
}

run();
