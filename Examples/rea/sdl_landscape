#!/usr/bin/env rea
// Object oriented landscape demo for the Rea front end. The demo shows how the
// new class system can be used to organize SDL/OpenGL programs by splitting the
// terrain generator, renderer, and camera into dedicated types.

const int WindowWidth = 1280;
const int WindowHeight = 720;
const int TerrainSize = 128;
const int VertexStride = TerrainSize + 1;
const int VertexCount = VertexStride * VertexStride;
const int ThreadCount = 4;
const float TileScale = 1.2;
const int NoiseOctaves = 5;
const float HeightScale = 32.0;
const float EyeHeight = 4.5;
const float MoveSpeed = 18.0;
const float MaxPitch = 75.0;
const float MouseYawSensitivity = 0.20;
const float MousePitchSensitivity = 0.15;
const float DegreesToRadians = 0.017453292519943295;
const int ScanCodeW = 26; // SDL_SCANCODE_W
const int ScanCodeS = 22; // SDL_SCANCODE_S
const float BaseFrequency = 0.035;

bool hasDigit(str s) {
  int i = 1;
  while (i <= length(s)) {
    char ch = s[i];
    if (ch >= '0' && ch <= '9') return true;
    i = i + 1;
  }
  return false;
}

int parseIntegerFromString(str s, int fallback) {
  int len = length(s);
  int idx = 1;
  while (idx <= len) {
    char ch = s[idx];
    if ((ch >= '0' && ch <= '9') || ch == '+' || ch == '-') break;
    idx = idx + 1;
  }
  if (idx > len) return fallback;
  int sign = 1;
  if (s[idx] == '+') {
    idx = idx + 1;
  } else if (s[idx] == '-') {
    sign = -1;
    idx = idx + 1;
  }
  int value = 0;
  bool any = false;
  while (idx <= len) {
    char ch = s[idx];
    if (ch >= '0' && ch <= '9') {
      any = true;
      value = value * 10 + (ch - '0');
    } else {
      break;
    }
    idx = idx + 1;
  }
  if (!any) return fallback;
  return value * sign;
}

int extractSeedFromArgs(int fallback) {
  int count = paramcount();
  if (count == 0) return fallback;
  int i = 1;
  while (i <= count) {
    str arg = paramstr(i);
    if (hasDigit(arg)) {
      return parseIntegerFromString(arg, fallback);
    }
    i = i + 1;
  }
  return fallback;
}

class HeightField {
  float heights[VertexCount];
  float minHeight;
  float maxHeight;
  float normalizationScale;

  void HeightField() {
    int idx = 0;
    while (idx < VertexCount) {
      my.heights[idx] = 0.0;
      idx = idx + 1;
    }
    my.minHeight = 0.0;
    my.maxHeight = 0.0;
    my.normalizationScale = 0.0;
  }

  int index(int x, int z) { return z * VertexStride + x; }

  void resetExtents() {
    my.minHeight = 1e9;
    my.maxHeight = -1e9;
  }

  void updateExtents(float value) {
    if (value < my.minHeight) my.minHeight = value;
    if (value > my.maxHeight) my.maxHeight = value;
  }

  void updateExtentsRange(float minValue, float maxValue) {
    if (minValue < my.minHeight) my.minHeight = minValue;
    if (maxValue > my.maxHeight) my.maxHeight = maxValue;
  }

  void finalizeExtents() {
    if (my.minHeight > my.maxHeight) {
      my.minHeight = 0.0;
      my.maxHeight = 0.0;
    }
    float span = my.maxHeight - my.minHeight;
    if (span <= 0.0001) {
      my.maxHeight = my.minHeight + 0.001;
      span = my.maxHeight - my.minHeight;
    }
    if (span <= 0.0001) {
      my.normalizationScale = 0.0;
    } else {
      my.normalizationScale = 1.0 / span;
    }
  }

  float rawHeight(int x, int z) {
    if (x < 0) x = 0;
    if (x > TerrainSize) x = TerrainSize;
    if (z < 0) z = 0;
    if (z > TerrainSize) z = TerrainSize;
    return my.heights[my.index(x, z)];
  }

  float heightByFlatIndex(int idx) {
    return my.heights[idx];
  }

  float normalizedHeight(float h) {
    if (my.normalizationScale <= 0.0) return 0.0;
    float t = (h - my.minHeight) * my.normalizationScale;
    if (t < 0.0) t = 0.0;
    if (t > 1.0) t = 1.0;
    return t;
  }

  float heightAt(float gx, float gz) {
    if (gx < 0.0) gx = 0.0;
    if (gx > TerrainSize) gx = TerrainSize;
    if (gz < 0.0) gz = 0.0;
    if (gz > TerrainSize) gz = TerrainSize;
    int x0 = floor(gx);
    int z0 = floor(gz);
    int x1 = x0 + 1;
    int z1 = z0 + 1;
    if (x1 > TerrainSize) x1 = TerrainSize;
    if (z1 > TerrainSize) z1 = TerrainSize;
    float h00 = my.rawHeight(x0, z0);
    float h10 = my.rawHeight(x1, z0);
    float h01 = my.rawHeight(x0, z1);
    float h11 = my.rawHeight(x1, z1);
    float tx = gx - x0;
    float tz = gz - z0;
    float hx0 = h00 + (h10 - h00) * tx;
    float hx1 = h01 + (h11 - h01) * tx;
    return hx0 + (hx1 - hx0) * tz;
  }

  void build(int seed) {}
}

class FbmHeightField extends HeightField {
  int seed;
  float sliceMin[ThreadCount];
  float sliceMax[ThreadCount];

  void FbmHeightField() {
    super();
    my.seed = 0;
    int worker = 0;
    while (worker < ThreadCount) {
      my.sliceMin[worker] = 0.0;
      my.sliceMax[worker] = 0.0;
      worker = worker + 1;
    }
  }

  float baseNoise(int x, int z) {
    int n = x * 374761393 + z * 668265263 + my.seed * 362437;
    n = n % 2147483647;
    if (n < 0) n = n + 2147483647;
    float value = n / 2147483647.0;
    return value * 2.0 - 1.0;
  }

  float fade(float t) { return t * t * (3.0 - 2.0 * t); }

  float valueNoise(float x, float z) {
    int xi = floor(x);
    int zi = floor(z);
    float xf = x - xi;
    float zf = z - zi;
    float v00 = my.baseNoise(xi, zi);
    float v10 = my.baseNoise(xi + 1, zi);
    float v01 = my.baseNoise(xi, zi + 1);
    float v11 = my.baseNoise(xi + 1, zi + 1);
    float u = my.fade(xf);
    float v = my.fade(zf);
    float i1 = v00 + (v10 - v00) * u;
    float i2 = v01 + (v11 - v01) * u;
    return i1 + (i2 - i1) * v;
  }

  float fbm(float x, float z) {
    float amplitude = 1.0;
    float frequency = 1.0;
    float sum = 0.0;
    float total = 0.0;
    int octave = 0;
    while (octave < NoiseOctaves) {
      sum = sum + my.valueNoise(x * frequency, z * frequency) * amplitude;
      total = total + amplitude;
      amplitude = amplitude * 0.5;
      frequency = frequency * 2.0;
      octave = octave + 1;
    }
    if (total == 0.0) return 0.0;
    return sum / total;
  }

  void buildSlice(int startZ, int endZ, int workerIdx) {
    if (workerIdx < 0 || workerIdx >= ThreadCount) return;
    float localMin = 1e9;
    float localMax = -1e9;
    int z = startZ;
    while (z <= endZ) {
      int x = 0;
      while (x <= TerrainSize) {
        float sampleX = (x + my.seed * 0.13) * BaseFrequency;
        float sampleZ = (z + my.seed * 0.29) * BaseFrequency;
        float h = my.fbm(sampleX, sampleZ) * HeightScale;
        int idx = my.index(x, z);
        my.heights[idx] = h;
        if (h < localMin) localMin = h;
        if (h > localMax) localMax = h;
        x = x + 1;
      }
      z = z + 1;
    }
    my.sliceMin[workerIdx] = localMin;
    my.sliceMax[workerIdx] = localMax;
  }

  void build(int newSeed) {
    my.seed = newSeed;
    my.resetExtents();

    int tids[ThreadCount];
    int worker = 0;
    while (worker < ThreadCount) {
      tids[worker] = -1;
      my.sliceMin[worker] = 1e9;
      my.sliceMax[worker] = -1e9;
      worker = worker + 1;
    }

    int totalRows = TerrainSize + 1;
    int rowsPerThread = totalRows / ThreadCount;
    int extraRows = totalRows % ThreadCount;
    int assigned = 0;
    worker = 0;
    while (worker < ThreadCount) {
      int rows = rowsPerThread;
      if (extraRows > 0) {
        rows = rows + 1;
        extraRows = extraRows - 1;
      }
      int startZ = assigned;
      int endZ = startZ + rows - 1;
      if (rows <= 0) {
        endZ = startZ - 1;
      }
      if (endZ > TerrainSize) endZ = TerrainSize;
      if (startZ <= endZ && startZ <= TerrainSize) {
        tids[worker] = spawn my.buildSlice(startZ, endZ, worker);
      }
      assigned = assigned + rows;
      worker = worker + 1;
    }

    worker = 0;
    while (worker < ThreadCount) {
      if (tids[worker] >= 0) {
        join tids[worker];
      }
      worker = worker + 1;
    }

    worker = 0;
    while (worker < ThreadCount) {
      if (tids[worker] >= 0) {
        my.updateExtentsRange(my.sliceMin[worker], my.sliceMax[worker]);
      }
      worker = worker + 1;
    }

    my.finalizeExtents();
  }
}

class ColorRGB {
  float r;
  float g;
  float b;

  void ColorRGB() {
    my.r = 0.0;
    my.g = 0.0;
    my.b = 0.0;
  }

  void set(float red, float green, float blue) {
    my.r = red;
    my.g = green;
    my.b = blue;
  }
}

class TerrainPalette {
  void TerrainPalette() {}

  void colorForNormalized(float t, ColorRGB result) {
    float r;
    float g;
    float b;
    if (t < 0.35) {
      float w = t / 0.35;
      r = 0.0;
      g = 0.28 + 0.35 * w;
      b = 0.45 + 0.4 * w;
    } else if (t < 0.6) {
      float w = (t - 0.35) / 0.25;
      r = 0.15 + 0.25 * w;
      g = 0.42 + 0.35 * w;
      b = 0.18 + 0.08 * w;
    } else if (t < 0.85) {
      float w = (t - 0.6) / 0.25;
      r = 0.52 + 0.2 * w;
      g = 0.40 + 0.18 * w;
      b = 0.30 + 0.15 * w;
    } else {
      float w = (t - 0.85) / 0.15;
      if (w < 0.0) w = 0.0;
      if (w > 1.0) w = 1.0;
      float c = 0.82 + 0.18 * w;
      r = c;
      g = c;
      b = c;
    }
    result.set(r, g, b);
  }
}

class TerrainMesh {
  HeightField field;
  TerrainPalette palette;
  float vertexHeights[VertexCount];
  float vertexColorR[VertexCount];
  float vertexColorG[VertexCount];
  float vertexColorB[VertexCount];
  float worldXCoords[VertexStride];
  float worldZCoords[VertexStride];
  ColorRGB scratchColor;

  void TerrainMesh(HeightField source, TerrainPalette pal) {
    my.field = source;
    my.palette = pal;
    my.scratchColor = new ColorRGB();
    my.precomputeWorldCoordinates();
  }

  void setField(HeightField source) {
    my.field = source;
  }

  void precomputeWorldCoordinates() {
    float half = TerrainSize * 0.5;
    int i = 0;
    while (i < VertexStride) {
      float world = (i - half) * TileScale;
      my.worldXCoords[i] = world;
      my.worldZCoords[i] = world;
      i = i + 1;
    }
  }

  void refresh() {
    if (my.field == nil) return;
    int idx = 0;
    while (idx < VertexCount) {
      float h = my.field.heightByFlatIndex(idx);
      my.vertexHeights[idx] = h;
      float t = my.field.normalizedHeight(h);
      my.palette.colorForNormalized(t, my.scratchColor);
      my.vertexColorR[idx] = my.scratchColor.r;
      my.vertexColorG[idx] = my.scratchColor.g;
      my.vertexColorB[idx] = my.scratchColor.b;
      idx = idx + 1;
    }
  }

  void draw() {
    int z = 0;
    while (z < TerrainSize) {
      GLBegin("triangle_strip");
      float worldZ0 = my.worldZCoords[z];
      float worldZ1 = my.worldZCoords[z + 1];
      int rowIndex = z * VertexStride;
      int nextRowIndex = (z + 1) * VertexStride;
      int x = 0;
      while (x <= TerrainSize) {
        int idx0 = rowIndex + x;
        int idx1 = nextRowIndex + x;
        float worldX = my.worldXCoords[x];
        GLColor3f(my.vertexColorR[idx0], my.vertexColorG[idx0], my.vertexColorB[idx0]);
        GLVertex3f(worldX, my.vertexHeights[idx0], worldZ0);
        GLColor3f(my.vertexColorR[idx1], my.vertexColorG[idx1], my.vertexColorB[idx1]);
        GLVertex3f(worldX, my.vertexHeights[idx1], worldZ1);
        x = x + 1;
      }
      GLEnd();
      z = z + 1;
    }
  }
}

class FlyCamera {
  HeightField field;
  float camX;
  float camZ;
  float camY;
  float yaw;
  float pitch;
  int lastMouseX;
  int lastMouseY;
  bool hasMouseSample;

  void FlyCamera(HeightField source) {
    my.field = source;
    my.camX = TerrainSize * 0.5;
    my.camZ = TerrainSize * 0.5;
    my.yaw = 135.0;
    my.pitch = -20.0;
    my.camY = 0.0;
    my.lastMouseX = 0;
    my.lastMouseY = 0;
    my.hasMouseSample = false;
    my.snapToTerrain();
  }

  void setField(HeightField source) {
    my.field = source;
    my.snapToTerrain();
  }

  void setOrientation(float newYaw, float newPitch) {
    my.yaw = newYaw;
    my.pitch = newPitch;
    my.clampAngles();
  }

  void primeMouseSample() {
    int mouseX = 0;
    int mouseY = 0;
    int mouseButtons = 0;
    getmousestate(mouseX, mouseY, mouseButtons);
    my.lastMouseX = mouseX;
    my.lastMouseY = mouseY;
    my.hasMouseSample = true;
  }

  void clampAngles() {
    while (my.yaw >= 360.0) my.yaw = my.yaw - 360.0;
    while (my.yaw < 0.0) my.yaw = my.yaw + 360.0;
    if (my.pitch > MaxPitch) my.pitch = MaxPitch;
    if (my.pitch < -MaxPitch) my.pitch = -MaxPitch;
  }

  void clampPosition() {
    if (my.camX < 1.0) my.camX = 1.0;
    if (my.camX > TerrainSize - 1) my.camX = TerrainSize - 1;
    if (my.camZ < 1.0) my.camZ = 1.0;
    if (my.camZ > TerrainSize - 1) my.camZ = TerrainSize - 1;
  }

  void snapToTerrain() {
    if (my.field == nil) {
      my.camY = EyeHeight;
    } else {
      my.camY = my.field.heightAt(my.camX, my.camZ) + EyeHeight;
    }
  }

  void resetToCenter() {
    my.camX = TerrainSize * 0.5;
    my.camZ = TerrainSize * 0.5;
    my.snapToTerrain();
  }

  void update(float dt) {
    if (dt > 0.1) dt = 0.1;
    int mouseX = 0;
    int mouseY = 0;
    int mouseButtons = 0;
    getmousestate(mouseX, mouseY, mouseButtons);
    if (!my.hasMouseSample) {
      my.lastMouseX = mouseX;
      my.lastMouseY = mouseY;
      my.hasMouseSample = true;
    } else {
      int deltaX = mouseX - my.lastMouseX;
      int deltaY = mouseY - my.lastMouseY;
      my.lastMouseX = mouseX;
      my.lastMouseY = mouseY;
      if (deltaX != 0 || deltaY != 0) {
        int maxDeltaX = WindowWidth / 2;
        int maxDeltaY = WindowHeight / 2;
        if (deltaX >= -maxDeltaX && deltaX <= maxDeltaX &&
            deltaY >= -maxDeltaY && deltaY <= maxDeltaY) {
          my.yaw = my.yaw - deltaX * MouseYawSensitivity;
          my.pitch = my.pitch - deltaY * MousePitchSensitivity;
        }
      }
    }

    bool forward = IsKeyDown(ScanCodeS);
    bool backward = IsKeyDown(ScanCodeW);

    float moveForward = 0.0;
    if (forward) moveForward = moveForward + 1.0;
    if (backward) moveForward = moveForward - 1.0;
    if (moveForward != 0.0) {
      float speed = MoveSpeed * dt * moveForward;
      float yawRadians = my.yaw * DegreesToRadians;
      float forwardX = sin(yawRadians);
      float forwardZ = cos(yawRadians);
      float deltaX = forwardX * (speed / TileScale);
      float deltaZ = forwardZ * (speed / TileScale);
      my.camX = my.camX + deltaX;
      my.camZ = my.camZ + deltaZ;
    }

    my.clampAngles();
    my.clampPosition();
    my.snapToTerrain();
  }

  void applyViewTransform() {
    GLRotatef(-my.pitch, 1.0, 0.0, 0.0);
    GLRotatef(-my.yaw, 0.0, 1.0, 0.0);
    float half = TerrainSize * 0.5;
    float worldX = (my.camX - half) * TileScale;
    float worldZ = (my.camZ - half) * TileScale;
    GLTranslatef(-worldX, -my.camY, -worldZ);
  }
}

class GameApp {
  bool running;
  int lastTicks;

  void GameApp() {
    my.running = true;
    my.lastTicks = 0;
  }

  void onInitialize() {}
  void onShutdown() {}
  void handleInput() {}
  void update(float dt) {}
  void render() {}

  void stop() {
    my.running = false;
  }

  void run() {
    my.running = true;
    my.onInitialize();
    my.lastTicks = getticks();
    while (my.running) {
      my.handleInput();
      if (!my.running) break;
      if (QuitRequested()) break;
      int now = getticks();
      float dt = (now - my.lastTicks) / 1000.0;
      my.lastTicks = now;
      if (dt < 0.0) dt = 0.0;
      if (dt > 0.2) dt = 0.2;
      my.update(dt);
      my.render();
      GraphLoop(1);
    }
    my.onShutdown();
  }
}

class LandscapeDemo extends GameApp {
  FbmHeightField terrain;
  TerrainPalette palette;
  TerrainMesh mesh;
  FlyCamera camera;
  int seed;

  void LandscapeDemo(int initialSeed) {
    super();
    my.seed = initialSeed;
    my.terrain = new FbmHeightField();
    my.palette = new TerrainPalette();
    my.mesh = new TerrainMesh(my.terrain, my.palette);
    my.camera = new FlyCamera(my.terrain);
    my.rebuildTerrain(initialSeed);
  }

  void rebuildTerrain(int newSeed) {
    my.seed = newSeed;
    my.terrain.build(newSeed);
    my.mesh.setField(my.terrain);
    my.mesh.refresh();
    my.camera.setField(my.terrain);
    my.camera.resetToCenter();
    writeln("Generated landscape for seed ", my.seed, ".");
  }

  void onInitialize() {
    InitGraph3D(WindowWidth, WindowHeight, "Rea Terrain", 24, 8);
    GLViewport(0, 0, WindowWidth, WindowHeight);
    GLClearDepth(1.0);
    GLDepthTest(true);
    GLSetSwapInterval(1);
    writeln("Controls: W/S to move, mouse to look. N/P change seed, R randomizes, Q or Esc exits.");
    my.camera.primeMouseSample();
  }

  void onShutdown() {
    CloseGraph3D();
  }

  void handleInput() {
    int key = pollkey();
    while (key != 0) {
      if (key == 'q' || key == 'Q' || key == 27) {
        my.stop();
        return;
      } else if (key == 'n' || key == 'N') {
        my.rebuildTerrain(my.seed + 1);
      } else if (key == 'p' || key == 'P') {
        my.rebuildTerrain(my.seed - 1);
      } else if (key == 'r' || key == 'R') {
        int tickSeed = getticks();
        if (tickSeed == 0) tickSeed = my.seed + 7;
        my.rebuildTerrain(tickSeed);
      }
      key = pollkey();
    }
  }

  void update(float dt) {
    my.camera.update(dt);
  }

  void render() {
    GLClearColor(0.36, 0.55, 0.78, 1.0);
    GLClear();

    GLMatrixMode("projection");
    GLLoadIdentity();
    float aspect = WindowWidth / float(WindowHeight);
    GLPerspective(68.0, aspect, 0.1, 320.0);

    GLMatrixMode("modelview");
    GLLoadIdentity();
    my.camera.applyViewTransform();

    my.mesh.draw();
    GLSwapWindow();
  }
}

int main() {
  int defaultSeed = 1337;
  int seed = extractSeedFromArgs(defaultSeed);
  LandscapeDemo demo = new LandscapeDemo(seed);
  demo.run();
  return 0;
}
