#!/usr/bin/env rea
// Spotify dataset + SQLite demo for the Rea front end.
// Downloads the CSV if necessary, imports it into SQLite, and offers
// interactive queries that surface interesting insights.

const str DATA_URL = "https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-01-21/spotify_songs.csv";
const str CSV_PATH = "spotify_songs.csv";
const str DB_PATH = "spotify_songs.sqlite";
const int EXPECTED_FIELD_COUNT = 23;

bool ensureDataset(str path);
bool downloadDataset(str url, str path);
bool setupDatabase(int db);
int importSpotifyCsv(str path, int db);
bool bindField(int stmt, int index, str value);
str repeatChar(char ch, int count);
str padRight(str value, int width);
str padLeft(str value, int width);
void showTopArtists(int db);
void showGenreOverview(int db);
void showDanceableTracks(int db);
void showReleaseYearSummary(int db);
void showGenreBreakdown(int db);
void runMenu(int db);

bool ensureDataset(str path) {
  if (fileexists(path)) {
    writeln("Found existing dataset at ", path, ".");
    return true;
  }
  writeln("Dataset not found locally. Downloading from network ...");
  return downloadDataset(DATA_URL, path);
}

bool downloadDataset(str url, str path) {
  int session = httpsession();
  if (session < 0) {
    writeln("Unable to allocate an HTTP session.");
    return false;
  }
  httpsetoption(session, "timeout_ms", 10000);

  mstream out = mstreamcreate();
  int status = httprequest(session, "GET", url, nil, out);
  if (status != 200) {
    writeln("HTTP request failed with status ", status, ".");
    int errCode = httperrorcode(session);
    str errMsg = httplasterror(session);
    if (errCode != 0) {
      writeln("HTTP error code: ", errCode);
    }
    if (errMsg != "") {
      writeln("HTTP error message: ", errMsg);
    }
    mstreamfree(out);
    httpclose(session);
    return false;
  }

  str body = mstreambuffer(out);
  mstreamfree(out);
  httpclose(session);

  text f;
  assign(f, path);
  rewrite(f);
  int err = ioresult();
  if (err != 0) {
    writeln("Failed to open ", path, " for writing (error ", err, ").");
    return false;
  }

  write(f, body);
  err = ioresult();
  if (err != 0) {
    writeln("Failed while writing dataset (error ", err, ").");
    close(f);
    ioresult();
    return false;
  }

  close(f);
  err = ioresult();
  if (err != 0) {
    writeln("Failed while closing dataset file (error ", err, ").");
    return false;
  }

  writeln("Saved dataset to ", path, " (", length(body), " bytes).");
  return true;
}

str repeatChar(char ch, int count) {
  if (count <= 0) {
    return "";
  }
  str result;
  setlength(result, count);
  int i = 0;
  while (i < count) {
    result[i + 1] = ch;
    i = i + 1;
  }
  return result;
}

str padRight(str value, int width) {
  int len = length(value);
  if (len >= width) {
    if (len == width) {
      return value;
    }
    str truncated;
    setlength(truncated, width);
    int i = 0;
    while (i < width) {
      truncated[i + 1] = value[i + 1];
      i = i + 1;
    }
    return truncated;
  }
  return value + repeatChar(' ', width - len);
}

str padLeft(str value, int width) {
  int len = length(value);
  if (len >= width) {
    if (len == width) {
      return value;
    }
    str truncated;
    setlength(truncated, width);
    int start = len - width + 1;
    int i = 0;
    while (i < width) {
      truncated[i + 1] = value[start + i];
      i = i + 1;
    }
    return truncated;
  }
  return repeatChar(' ', width - len) + value;
}

bool setupDatabase(int db) {
  int rc = SqliteExec(db, "DROP TABLE IF EXISTS spotify_songs;");
  if (rc != 0) {
    writeln("Failed to drop prior table: ", SqliteErrMsg(db));
    return false;
  }

  rc = SqliteExec(db,
    "CREATE TABLE spotify_songs ("
    " track_id TEXT NOT NULL,"
    " track_name TEXT NOT NULL,"
    " track_artist TEXT NOT NULL,"
    " track_popularity INTEGER,"
    " track_album_id TEXT,"
    " track_album_name TEXT,"
    " track_album_release_date TEXT,"
    " playlist_name TEXT,"
    " playlist_id TEXT,"
    " playlist_genre TEXT,"
    " playlist_subgenre TEXT,"
    " danceability REAL,"
    " energy REAL,"
    " key INTEGER,"
    " loudness REAL,"
    " mode INTEGER,"
    " speechiness REAL,"
    " acousticness REAL,"
    " instrumentalness REAL,"
    " liveness REAL,"
    " valence REAL,"
    " tempo REAL,"
    " duration_ms INTEGER,"
    " PRIMARY KEY (track_id, playlist_id)"
    ");");
  if (rc != 0) {
    writeln("Failed to create table: ", SqliteErrMsg(db));
    return false;
  }

  rc = SqliteExec(db, "CREATE INDEX idx_spotify_artist ON spotify_songs(track_artist);");
  if (rc != 0) {
    writeln("Warning: failed to create artist index: ", SqliteErrMsg(db));
  }

  rc = SqliteExec(db, "CREATE INDEX idx_spotify_genre ON spotify_songs(playlist_genre);");
  if (rc != 0) {
    writeln("Warning: failed to create genre index: ", SqliteErrMsg(db));
  }

  rc = SqliteExec(db, "CREATE INDEX idx_spotify_release ON spotify_songs(track_album_release_date);");
  if (rc != 0) {
    writeln("Warning: failed to create release date index: ", SqliteErrMsg(db));
  }

  return true;
}

int importSpotifyCsv(str path, int db) {
  text f;
  assign(f, path);
  reset(f);
  int err = ioresult();
  if (err != 0) {
    writeln("Unable to open ", path, " (error ", err, ").");
    return -1;
  }

  if (eof(f)) {
    writeln("Dataset file was empty.");
    close(f);
    ioresult();
    return -1;
  }

  str header;
  readln(f, header);

  // Fields are stored using zero-based indexing; the array is sized to
  // hold exactly the expected column count.
  str fields[EXPECTED_FIELD_COUNT];
  str line;
  int lineNumber = 1;
  int inserted = 0;
  int skipped = 0;

  int stmt = SqlitePrepare(db,
    "INSERT INTO spotify_songs ("
    " track_id, track_name, track_artist, track_popularity, track_album_id,"
    " track_album_name, track_album_release_date, playlist_name, playlist_id,"
    " playlist_genre, playlist_subgenre, danceability, energy, key, loudness,"
    " mode, speechiness, acousticness, instrumentalness, liveness, valence,"
    " tempo, duration_ms"
    ") VALUES ("
    " ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14, ?15,"
    " ?16, ?17, ?18, ?19, ?20, ?21, ?22, ?23);");
  if (stmt < 0) {
    writeln("Failed to prepare insert statement: ", SqliteErrMsg(db));
    close(f);
    ioresult();
    return -1;
  }

  bool ok = true;
  while (!eof(f)) {
    readln(f, line);
    lineNumber = lineNumber + 1;
    if (line == "") {
      continue;
    }
    // Parse the CSV line in place to populate the local fields array.
    int resetIndex = 0;
    while (resetIndex < EXPECTED_FIELD_COUNT) {
      fields[resetIndex] = "";
      resetIndex = resetIndex + 1;
    }

    int len = length(line);
    int idx = 1;
    int fieldCount = 0;
    bool inQuotes = false;
    str current = "";

    while (idx <= len) {
      char ch = line[idx];
      if (inQuotes) {
        if (ch == '"') {
          if (idx < len && line[idx + 1] == '"') {
            current = current + "\"";
            idx = idx + 1;
          } else {
            inQuotes = false;
          }
        } else {
          current = current + ch;
        }
      } else {
        if (ch == '"') {
          inQuotes = true;
        } else if (ch == ',') {
          if (fieldCount < EXPECTED_FIELD_COUNT) {
            fields[fieldCount] = current;
          }
          fieldCount = fieldCount + 1;
          current = "";
        } else {
          current = current + ch;
        }
      }
      idx = idx + 1;
    }

    if (fieldCount < EXPECTED_FIELD_COUNT) {
      fields[fieldCount] = current;
    }
    fieldCount = fieldCount + 1;
    if (fieldCount != EXPECTED_FIELD_COUNT) {
      writeln("Skipping line ", lineNumber, ": expected ", EXPECTED_FIELD_COUNT,
              " fields but saw ", fieldCount, ".");
      skipped = skipped + 1;
      continue;
    }

    bool missingRequired =
      fields[0] == "" || fields[1] == "" || fields[2] == "" || fields[8] == "";
    if (missingRequired) {
      writeln("Skipping line ", lineNumber,
              ": required fields (track_id, track_name, track_artist, playlist_id) "
              "must be present.");
      skipped = skipped + 1;
      continue;
    }

    int i = 0;
    while (i < EXPECTED_FIELD_COUNT && ok) {
      ok = bindField(stmt, i + 1, fields[i]);
      i = i + 1;
    }
    if (!ok) {
      break;
    }

    int rc = SqliteStep(stmt);
    bool handled = false;
    bool constraintViolation = rc == 19;
    if (rc == 101) {
      inserted = inserted + 1;
      handled = true;
    } else if (rc == 19) {
      writeln("Skipping line ", lineNumber,
              ": duplicate track/playlist combination (track_id=", fields[0],
              ", playlist_id=", fields[8], ").");
      skipped = skipped + 1;
      handled = true;
    } else {
      writeln("Insert failed at line ", lineNumber, ": rc=", rc, " msg=", SqliteErrMsg(db));
      ok = false;
    }

    if (!handled) {
      break;
    }

    rc = SqliteReset(stmt);
    if (constraintViolation && rc == 19) {
      rc = 0;
    }
    if (rc != 0) {
      writeln("SqliteReset failed with rc=", rc, ".");
      ok = false;
      break;
    }
    rc = SqliteClearBindings(stmt);
    if (rc != 0) {
      writeln("SqliteClearBindings failed with rc=", rc, ".");
      ok = false;
      break;
    }
  }

  close(f);
  ioresult();

  int finalizeRc = SqliteFinalize(stmt);
  if (finalizeRc != 0) {
    writeln("SqliteFinalize returned rc=", finalizeRc, ".");
    ok = false;
  }

  writeln("Import summary: ", inserted, " valid rows, ", skipped, " skipped.");

  if (!ok) {
    return -1;
  }
  return inserted;
}

bool bindField(int stmt, int index, str value) {
  int rc;
  if (value == "") {
    rc = SqliteBindNull(stmt, index);
  } else {
    rc = SqliteBindText(stmt, index, value);
  }
  if (rc != 0) {
    writeln("Failed to bind parameter ", index, " (rc=", rc, ").");
    return false;
  }
  return true;
}

void showTopArtists(int db) {
  writeln();
  writeln("Top artists by track count:");
  int stmt = SqlitePrepare(db,
    "SELECT track_artist, track_count,"
    " printf('%.1f', avg_popularity) AS avg_popularity_str"
    " FROM ("
    "   SELECT track_artist,"
    "          COUNT(*) AS track_count,"
    "          AVG(CAST(track_popularity AS REAL)) AS avg_popularity"
    "   FROM spotify_songs"
    "   GROUP BY track_artist"
    " )"
    " ORDER BY track_count DESC, avg_popularity DESC"
    " LIMIT 10;");
  if (stmt < 0) {
    writeln("Query preparation failed: ", SqliteErrMsg(db));
    return;
  }
  writeln(padRight("Artist", 32), " ", padLeft("Tracks", 10), " ", padLeft("Avg Popularity", 16));
  writeln(padRight(repeatChar('-', 32), 32), " ", padLeft(repeatChar('-', 10), 10), " ", padLeft(repeatChar('-', 16), 16));
  int rc = SqliteStep(stmt);
  while (rc == 100) {
    str artist = SqliteColumnText(stmt, 0);
    int trackCount = SqliteColumnInt(stmt, 1);
    str avgPopularity = SqliteColumnText(stmt, 2);
    writeln(padRight(artist, 32), " ", padLeft(inttostr(trackCount), 10), " ", padLeft(avgPopularity, 16));
    rc = SqliteStep(stmt);
  }
  if (rc != 101) {
    writeln("Query ended with rc=", rc, " msg=", SqliteErrMsg(db));
  }
  SqliteFinalize(stmt);
}

void showGenreOverview(int db) {
  writeln();
  writeln("Playlist genres ranked by energy and popularity:");
  int stmt = SqlitePrepare(db,
    "SELECT playlist_genre, track_count,"
    " printf('%.1f', avg_popularity) AS avg_popularity_str,"
    " printf('%.3f', avg_danceability) AS avg_danceability_str,"
    " printf('%.3f', avg_energy) AS avg_energy_str"
    " FROM ("
    "   SELECT playlist_genre,"
    "          COUNT(*) AS track_count,"
    "          AVG(CAST(track_popularity AS REAL)) AS avg_popularity,"
    "          AVG(CAST(danceability AS REAL)) AS avg_danceability,"
    "          AVG(CAST(energy AS REAL)) AS avg_energy"
    "   FROM spotify_songs"
    "   GROUP BY playlist_genre"
    " )"
    " ORDER BY avg_energy DESC, avg_popularity DESC;");
  if (stmt < 0) {
    writeln("Query preparation failed: ", SqliteErrMsg(db));
    return;
  }
  writeln(padRight("Genre", 16), " ", padLeft("Tracks", 10), " ", padLeft("Avg Popularity", 16),
         " ", padLeft("Avg Danceability", 18), " ", padLeft("Avg Energy", 14));
  writeln(padRight(repeatChar('-', 16), 16), " ", padLeft(repeatChar('-', 10), 10), " ", padLeft(repeatChar('-', 16), 16),
         " ", padLeft(repeatChar('-', 18), 18), " ", padLeft(repeatChar('-', 14), 14));
  int rc = SqliteStep(stmt);
  while (rc == 100) {
    str genre = SqliteColumnText(stmt, 0);
    int trackCount = SqliteColumnInt(stmt, 1);
    str avgPopularity = SqliteColumnText(stmt, 2);
    str avgDance = SqliteColumnText(stmt, 3);
    str avgEnergy = SqliteColumnText(stmt, 4);
    writeln(padRight(genre, 16), " ", padLeft(inttostr(trackCount), 10), " ", padLeft(avgPopularity, 16),
           " ", padLeft(avgDance, 18), " ", padLeft(avgEnergy, 14));
    rc = SqliteStep(stmt);
  }
  if (rc != 101) {
    writeln("Query ended with rc=", rc, " msg=", SqliteErrMsg(db));
  }
  SqliteFinalize(stmt);
}

void showDanceableTracks(int db) {
  writeln();
  writeln("Most danceable tracks in the dataset:");
  int stmt = SqlitePrepare(db,
    "SELECT track_name, track_artist,"
    " printf('%.3f', CAST(danceability AS REAL)) AS danceability,"
    " printf('%.3f', CAST(energy AS REAL)) AS energy,"
    " printf('%.1f', CAST(track_popularity AS REAL)) AS popularity"
    " FROM spotify_songs"
    " ORDER BY CAST(danceability AS REAL) DESC, CAST(track_popularity AS REAL) DESC"
    " LIMIT 10;");
  if (stmt < 0) {
    writeln("Query preparation failed: ", SqliteErrMsg(db));
    return;
  }
  writeln(padRight("Track", 40), " ", padRight("Artist", 24), " ", padLeft("Danceability", 12),
         " ", padLeft("Energy", 10), " ", padLeft("Popularity", 12));
  writeln(padRight(repeatChar('-', 40), 40), " ", padRight(repeatChar('-', 24), 24), " ", padLeft(repeatChar('-', 12), 12),
         " ", padLeft(repeatChar('-', 10), 10), " ", padLeft(repeatChar('-', 12), 12));
  int rc = SqliteStep(stmt);
  while (rc == 100) {
    str name = SqliteColumnText(stmt, 0);
    str artist = SqliteColumnText(stmt, 1);
    str dance = SqliteColumnText(stmt, 2);
    str energy = SqliteColumnText(stmt, 3);
    str pop = SqliteColumnText(stmt, 4);
    writeln(padRight(name, 40), " ", padRight(artist, 24), " ", padLeft(dance, 12),
           " ", padLeft(energy, 10), " ", padLeft(pop, 12));
    rc = SqliteStep(stmt);
  }
  if (rc != 101) {
    writeln("Query ended with rc=", rc, " msg=", SqliteErrMsg(db));
  }
  SqliteFinalize(stmt);
}

void showReleaseYearSummary(int db) {
  writeln();
  writeln("Years with the most releases in this snapshot:");
  int stmt = SqlitePrepare(db,
    "SELECT release_year, track_count, printf('%.1f', avg_popularity) AS avg_popularity_str"
    " FROM ("
    "   SELECT substr(track_album_release_date, 1, 4) AS release_year,"
    "          COUNT(*) AS track_count,"
    "          AVG(CAST(track_popularity AS REAL)) AS avg_popularity"
    "   FROM spotify_songs"
    "   WHERE length(track_album_release_date) >= 4"
    "   GROUP BY release_year"
    " )"
    " WHERE release_year != ''"
    " ORDER BY track_count DESC, release_year DESC"
    " LIMIT 10;");
  if (stmt < 0) {
    writeln("Query preparation failed: ", SqliteErrMsg(db));
    return;
  }
  writeln(padRight("Year", 8), " ", padLeft("Tracks", 12), " ", padLeft("Avg Popularity", 18));
  writeln(padRight(repeatChar('-', 8), 8), " ", padLeft(repeatChar('-', 12), 12), " ", padLeft(repeatChar('-', 18), 18));
  int rc = SqliteStep(stmt);
  while (rc == 100) {
    str year = SqliteColumnText(stmt, 0);
    int trackCount = SqliteColumnInt(stmt, 1);
    str avgPopularity = SqliteColumnText(stmt, 2);
    writeln(padRight(year, 8), " ", padLeft(inttostr(trackCount), 12), " ", padLeft(avgPopularity, 18));
    rc = SqliteStep(stmt);
  }
  if (rc != 101) {
    writeln("Query ended with rc=", rc, " msg=", SqliteErrMsg(db));
  }
  SqliteFinalize(stmt);
}

void showGenreBreakdown(int db) {
  writeln();
  writeln("Enter a playlist genre (e.g., pop, latin, rock). Leave empty to cancel:");
  str genre;
  readln(genre);
  if (genre == "") {
    writeln("No genre entered. Returning to menu.");
    return;
  }

  int stmt = SqlitePrepare(db,
    "SELECT playlist_subgenre, track_count,"
    " printf('%.1f', avg_popularity) AS avg_popularity_str,"
    " printf('%.3f', avg_danceability) AS avg_danceability_str,"
    " printf('%.3f', avg_energy) AS avg_energy_str"
    " FROM ("
    "   SELECT playlist_subgenre,"
    "          COUNT(*) AS track_count,"
    "          AVG(CAST(track_popularity AS REAL)) AS avg_popularity,"
    "          AVG(CAST(danceability AS REAL)) AS avg_danceability,"
    "          AVG(CAST(energy AS REAL)) AS avg_energy"
    "   FROM spotify_songs"
    "   WHERE playlist_genre = ?1"
    "   GROUP BY playlist_subgenre"
    " )"
    " ORDER BY track_count DESC, avg_popularity DESC"
    " LIMIT 15;");
  if (stmt < 0) {
    writeln("Query preparation failed: ", SqliteErrMsg(db));
    return;
  }

  int bindRc = SqliteBindText(stmt, 1, genre);
  if (bindRc != 0) {
    writeln("Failed to bind genre parameter (rc=", bindRc, ").");
    SqliteFinalize(stmt);
    return;
  }

  writeln("Breakdown for playlist genre '", genre, "':");
  writeln(padRight("Subgenre", 28), " ", padLeft("Tracks", 10), " ", padLeft("Avg Popularity", 16),
         " ", padLeft("Avg Danceability", 18), " ", padLeft("Avg Energy", 14));
  writeln(padRight(repeatChar('-', 28), 28), " ", padLeft(repeatChar('-', 10), 10), " ", padLeft(repeatChar('-', 16), 16),
         " ", padLeft(repeatChar('-', 18), 18), " ", padLeft(repeatChar('-', 14), 14));
  bool any = false;
  int rc = SqliteStep(stmt);
  while (rc == 100) {
    any = true;
    str subgenre = SqliteColumnText(stmt, 0);
    int trackCount = SqliteColumnInt(stmt, 1);
    str avgPopularity = SqliteColumnText(stmt, 2);
    str avgDance = SqliteColumnText(stmt, 3);
    str avgEnergy = SqliteColumnText(stmt, 4);
    writeln(padRight(subgenre, 28), " ", padLeft(inttostr(trackCount), 10), " ", padLeft(avgPopularity, 16),
           " ", padLeft(avgDance, 18), " ", padLeft(avgEnergy, 14));
    rc = SqliteStep(stmt);
  }
  if (rc != 101) {
    writeln("Query ended with rc=", rc, " msg=", SqliteErrMsg(db));
  } else if (!any) {
    writeln("No matches for playlist genre '", genre, "'.");
  }

  SqliteFinalize(stmt);
}

void runMenu(int db) {
  bool keepGoing = true;
  while (keepGoing) {
    writeln();
    writeln("Choose an insight to display:");
    writeln("  1) Top artists by track count");
    writeln("  2) Playlist genre overview");
    writeln("  3) Most danceable tracks");
    writeln("  4) Release year summary");
    writeln("  5) Playlist subgenre breakdown");
    writeln("  q) Quit");
    write("Enter choice: ");
    str choice;
    readln(choice);
    if (choice == "1") {
      showTopArtists(db);
    } else if (choice == "2") {
      showGenreOverview(db);
    } else if (choice == "3") {
      showDanceableTracks(db);
    } else if (choice == "4") {
      showReleaseYearSummary(db);
    } else if (choice == "5") {
      showGenreBreakdown(db);
    } else if (choice == "q" || choice == "Q" || choice == "quit" || choice == "exit") {
      keepGoing = false;
    } else {
      writeln("Unrecognised choice. Please try again.");
    }
  }
}

int main() {
  writeln("Spotify + SQLite demo (Rea front end).");
  if (!hasextbuiltin("sqlite", "SqliteOpen")) {
    writeln("This build of Rea does not include the SQLite extended built-ins.");
    writeln("Rebuild with ENABLE_EXT_BUILTIN_SQLITE=ON to run this demo.");
    return 1;
  }

  if (!ensureDataset(CSV_PATH)) {
    writeln("Unable to ensure dataset availability. Exiting.");
    return 1;
  }

  int db = SqliteOpen(DB_PATH);
  if (db < 0) {
    writeln("Failed to open SQLite database at ", DB_PATH, ".");
    return 1;
  }

  if (!setupDatabase(db)) {
    SqliteClose(db);
    return 1;
  }

  writeln("Importing Spotify tracks into SQLite ...");
  int inserted = importSpotifyCsv(CSV_PATH, db);
  if (inserted < 0) {
    writeln("Import failed. See messages above for details.");
    SqliteClose(db);
    return 1;
  }
  writeln("Imported ", inserted, " rows into spotify_songs.");

  runMenu(db);

  int closeRc = SqliteClose(db);
  if (closeRc != 0) {
    writeln("Warning: SqliteClose returned rc=", closeRc, ".");
  }
  writeln("Goodbye!");
  return 0;
}
