// Interactive Mandelbrot demo for the Rea front end.
// Left click to zoom in, right click to zoom out, Q to quit.
// Requires SDL support in the Pscal build.

class MandelbrotApp {
  const int Width = 1200;
  const int Height = 900;
  const int MaxIterations = 200;
  const int BytesPerPixel = 4;
  const double ZoomFactor = 2.0;
  const int ButtonLeft = 1;
  const int ButtonRight = 4;
  const int KEY_LEFT = 1073741904;
  const int KEY_RIGHT = 1073741903;
  const int KEY_UP = 1073741906;
  const int KEY_DOWN = 1073741905;

  byte pixels[Width * Height * BytesPerPixel];
  double minRe;
  double maxRe;
  double minIm;
  double maxIm;
  int textureID;
  bool quit;
  int prevButtons;

  void init() {
    minRe = -2.0;
    maxRe = 1.0;
    minIm = -1.2;
    maxIm = minIm + (maxRe - minRe) * Height / Width;
    initgraph(Width, Height, "Mandelbrot in Rea");
    textureID = createtexture(Width, Height);
    if (textureID < 0) {
      printf("Error: unable to create texture.\n");
      halt();
    }
    quit = false;
    prevButtons = 0;
  }

  void compute() {
    int row[Width];
    double reFactor = (maxRe - minRe) / (Width - 1);
    double imFactor = (maxIm - minIm) / (Height - 1);
    int idx;
    int x, y, n, R, G, B;
    double c_im;
    for (y = 0; y < Height; y++) {
      c_im = maxIm - y * imFactor;
      mandelbrotrow(minRe, reFactor, c_im, MaxIterations, Width - 1, &row);
      idx = y * Width * BytesPerPixel;
      for (x = 0; x < Width; x++) {
        n = row[x];
        if (n == MaxIterations) { R = G = B = 0; }
        else {
          R = (n * 5) % 256;
          G = (n * 7 + 85) % 256;
          B = (n * 11 + 170) % 256;
        }
        pixels[idx + 0] = R;
        pixels[idx + 1] = G;
        pixels[idx + 2] = B;
        pixels[idx + 3] = 255;
        idx = idx + BytesPerPixel;
      }
    }
    updatetexture(textureID, pixels);
    cleardevice();
    rendercopy(textureID);
    updatescreen();
  }

  void zoom(int px, int py, double factor) {
    double reFactor = (maxRe - minRe) / (Width - 1);
    double imFactor = (maxIm - minIm) / (Height - 1);
    double centerRe = minRe + (px + 0.5) * reFactor;
    double centerIm = maxIm - (py + 0.5) * imFactor;
    double widthRe = (maxRe - minRe) * factor;
    double heightIm = (maxIm - minIm) * factor;
    minRe = centerRe - widthRe / 2.0;
    maxRe = centerRe + widthRe / 2.0;
    minIm = centerIm - heightIm / 2.0;
    maxIm = centerIm + heightIm / 2.0;
  }

  void handleInput() {
    graphloop(1);
    int key = pollkey();
    if (key != 0) {
      if (key == 'q' || key == 'Q') { quit = true; return; }
      double widthRe = (maxRe - minRe);
      double heightIm = (maxIm - minIm);
      double dx = widthRe * 0.5;
      double dy = heightIm * 0.5;
      if (key == KEY_LEFT) { minRe -= dx; maxRe -= dx; }
      else if (key == KEY_RIGHT) { minRe += dx; maxRe += dx; }
      else if (key == KEY_UP) { minIm += dy; maxIm += dy; }
      else if (key == KEY_DOWN) { minIm -= dy; maxIm -= dy; }
    }
    int x = 0, y = 0, b = 0;
    getmousestate(&x, &y, &b);
    if ((b & ButtonLeft) != 0 && (prevButtons & ButtonLeft) == 0) {
      zoom(x, y, 1.0 / ZoomFactor);
    } else if ((b & ButtonRight) != 0 && (prevButtons & ButtonRight) == 0) {
      zoom(x, y, ZoomFactor);
    }
    prevButtons = b;
  }

  void run() {
    init();
    while (!quit) {
      compute();
      handleInput();
    }
    destroytexture(textureID);
    closegraph();
  }
}

MandelbrotApp app = new MandelbrotApp();
app.run();

