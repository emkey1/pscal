#!/usr/bin/env rea
// Interactive Mandelbrot demo for the Rea front end.
// Left click to zoom in, right click to zoom out, Q to quit.
// Requires SDL support in the Pscal build.

class MandelbrotApp {
  const int Width = 800;
  const int Height = 600;
  const int MaxIterations = 100;
  const int BytesPerPixel = 4;
  const int ScreenUpdateInterval = 1;
  // Minimum rows between UI texture updates; actual threshold adapts to image size and thread count.
  const int UpdateQuantum = 4;
  const double ZoomFactor = 2.0;
  const int ButtonLeft = 1;
  const int ButtonRight = 4;
  const int ThreadCount = 4;
  const int KEY_LEFT = 1073741904;
  const int KEY_RIGHT = 1073741903;
  const int KEY_UP = 1073741906;
  const int KEY_DOWN = 1073741905;

  byte pixels[Width * Height * BytesPerPixel];
  double minRe;
  double maxRe;
  double minIm;
  double maxIm;
  double reFactor;
  double imFactor;
  int textureID;
  bool quit;
  bool cancel;
  bool computing;
  int prevButtons;
  bool rowDone[Height];
  int threadStart[ThreadCount];
  int threadEnd[ThreadCount];
  int rowMutex;
  int quitMutex;
  int tids[ThreadCount];
  int lastUpdatedRows;
  int pollCounter;

  void init() {
    printf("[int] init: begin\n");
    myself.minRe = -2.0;
    myself.maxRe = 1.0;
    myself.minIm = -1.2;
    double widthSpan = myself.maxRe - myself.minRe;
    double aspect = double(myself.Height) / double(myself.Width);
    myself.maxIm = myself.minIm + widthSpan * aspect;
    initgraph(myself.Width, myself.Height, "Rea Mandelbrot");
    string systemFontPath = "/usr/local/Pscal/fonts/Roboto/static/Roboto-Regular.ttf";
    string repoFontPath1 = "fonts/Roboto/static/Roboto-Regular.ttf";
    string repoFontPath2 = "../../fonts/Roboto/static/Roboto-Regular.ttf";
    if (fileexists(systemFontPath)) {
      inittextsystem(systemFontPath, 18);
    } else if (fileexists(repoFontPath1)) {
      inittextsystem(repoFontPath1, 18);
    } else {
      inittextsystem(repoFontPath2, 18);
    }
    printf("[int] init: initgraph done (%dx%d)\n", myself.Width, myself.Height);
    myself.textureID = createtexture(myself.Width, myself.Height);
    if (myself.textureID < 0) {
      printf("[int] Error: unable to create texture.\n");
      halt();
    }
    printf("[int] init: texture created id=%d\n", myself.textureID);
    myself.quit = false;
    myself.cancel = false;
    myself.computing = false;
    myself.prevButtons = 0;
    myself.rowMutex = mutex();
    myself.quitMutex = mutex();
    int i;
    for (i = 0; i < myself.ThreadCount; i = i + 1) { myself.tids[i] = -1; }
    myself.lastUpdatedRows = 0;
    myself.pollCounter = 0;
  }

  int getQuit() {
    bool q;
    lock(myself.quitMutex);
    q = myself.quit;
    unlock(myself.quitMutex);
    return q;
  }

  bool getCancel() {
    bool c;
    lock(myself.rowMutex);
    c = myself.cancel;
    unlock(myself.rowMutex);
    return c;
  }

  void setCancel(bool v) {
    lock(myself.rowMutex);
    myself.cancel = v;
    unlock(myself.rowMutex);
  }

  void setQuit(bool v) {
    lock(myself.quitMutex);
    myself.quit = v;
    unlock(myself.quitMutex);
  }

  void computeRows(int startY, int endY) {
    int row[Width];
    int x, y, n, R, G, B, idx;
    double c_im;
    for (y = startY; y <= endY && !myself.getQuit() && !myself.getCancel(); y = y + 1) {
      c_im = myself.maxIm - y * myself.imFactor;
      mandelbrotrow(myself.minRe, myself.reFactor, c_im, myself.MaxIterations, myself.Width - 1, row);
      idx = y * myself.Width * myself.BytesPerPixel;
      for (x = 0; x < myself.Width; x = x + 1) {
        n = row[x];
        if (n == myself.MaxIterations) { R = G = B = 0; }
        else {
          R = (n * 5) % 256;
          G = (n * 7 + 85) % 256;
          B = (n * 11 + 170) % 256;
        }
        myself.pixels[idx + 0] = char(R);
        myself.pixels[idx + 1] = char(G);
        myself.pixels[idx + 2] = char(B);
        myself.pixels[idx + 3] = char(255);
        idx = idx + myself.BytesPerPixel;
      }
      lock(myself.rowMutex);
      myself.rowDone[y] = true;
      unlock(myself.rowMutex);
    }
  }

  // Generic worker entrypoint that receives its slice index.
  void computeRowsWorker(int idx) {
    if (idx < 0 || idx >= myself.ThreadCount) return;
    myself.computeRows(myself.threadStart[idx], myself.threadEnd[idx]);
  }

  void startCompute() {
    int tid[ThreadCount];
    int i, y;
    // Avoid clearing the entire buffer up-front; rows overwrite their regions as they complete.
    double widthSpan = myself.maxRe - myself.minRe;
    double aspect = double(myself.Height) / double(myself.Width);
    myself.maxIm = myself.minIm + widthSpan * aspect;
    double heightSpan = myself.maxIm - myself.minIm;
    myself.reFactor = widthSpan / double(myself.Width - 1);
    myself.imFactor = heightSpan / double(myself.Height - 1);
    for (i = 0; i < myself.Height; i = i + 1) { myself.rowDone[i] = false; }

    int rowsPerThread = myself.Height / myself.ThreadCount;
    int extra = myself.Height % myself.ThreadCount;
    int startY = 0;
    for (i = 0; i < myself.ThreadCount; i = i + 1) {
      int endY = startY + rowsPerThread - 1;
      if (extra > 0) { endY = endY + 1; extra = extra - 1; }
      myself.threadStart[i] = startY;
      myself.threadEnd[i] = endY;
      startY = endY + 1;
    }

    for (i = 0; i < myself.ThreadCount; i = i + 1) {
      myself.tids[i] = spawn myself.computeRowsWorker(i);
    }
    myself.computing = true;
  }

  void pollCompute() {
    int y;
    int doneCount;
    bool done;
    int adaptiveQuantum;
    bool initialFrame;
    bool periodicTick;
    bool shouldUpdate;
    if (!myself.computing) return;
    y = 0;
    doneCount = 0;
    while (y < myself.Height) {
      lock(myself.rowMutex);
      done = myself.rowDone[y];
      unlock(myself.rowMutex);
      if (done) doneCount = doneCount + 1;
      y = y + 1;
    }
    adaptiveQuantum = (myself.Height / (myself.ThreadCount * 8));
    if (adaptiveQuantum < myself.UpdateQuantum) adaptiveQuantum = myself.UpdateQuantum;
    initialFrame = (doneCount > 0 && myself.lastUpdatedRows == 0);
    myself.pollCounter = myself.pollCounter + 1;
    periodicTick = ((myself.pollCounter & 3) == 0);
    shouldUpdate = (initialFrame || (periodicTick && (doneCount > myself.lastUpdatedRows)) || (doneCount == myself.Height));
    if (shouldUpdate) {
      updatetexture(myself.textureID, myself.pixels);
      cleardevice(); rendercopy(myself.textureID); outtextxy(8, 8, "Rendering..."); updatescreen();
      myself.lastUpdatedRows = doneCount;
    }
    // Finalize when all rows are done or cancelled
    if ((doneCount == myself.Height) || myself.getCancel()) {
      if (doneCount > myself.lastUpdatedRows) {
        updatetexture(myself.textureID, myself.pixels);
        cleardevice(); rendercopy(myself.textureID); outtextxy(8, 8, "Rendering..."); updatescreen();
        myself.lastUpdatedRows = doneCount;
      }
      myself.joinAndResetThreads();
      myself.computing = false;
      myself.lastUpdatedRows = 0;
    }
  }

  void joinAndResetThreads() {
    int i;
    for (i = 0; i < myself.ThreadCount; i = i + 1) {
      if (myself.tids[i] >= 0) {
        join myself.tids[i];
        myself.tids[i] = -1;
      }
    }
  }

  void zoom(int px, int py, double factor) {
    double reFactor = (myself.maxRe - myself.minRe) / double(myself.Width - 1);
    double imFactor = (myself.maxIm - myself.minIm) / double(myself.Height - 1);
    double centerRe = myself.minRe + (px + 0.5) * reFactor;
    double centerIm = myself.maxIm - (py + 0.5) * imFactor;
    double widthRe = (myself.maxRe - myself.minRe) * factor;
    double heightIm = (myself.maxIm - myself.minIm) * factor;
    myself.minRe = centerRe - widthRe / 2.0;
    myself.maxRe = centerRe + widthRe / 2.0;
    myself.minIm = centerIm - heightIm / 2.0;
    myself.maxIm = centerIm + heightIm / 2.0;
  }

  bool handleInput() {
    graphloop(0);
    bool changed = false;
    int key = pollkey();
    if (key != 0) {
      if (key == 'q' || key == 'Q') { myself.setQuit(true); return false; }
      double widthRe = (myself.maxRe - myself.minRe);
      double heightIm = (myself.maxIm - myself.minIm);
      double dx = widthRe * 0.5;
      double dy = heightIm * 0.5;
      if (key == myself.KEY_LEFT) { myself.minRe -= dx; myself.maxRe -= dx; changed = true; }
      else if (key == myself.KEY_RIGHT) { myself.minRe += dx; myself.maxRe += dx; changed = true; }
      else if (key == myself.KEY_UP) { myself.minIm += dy; myself.maxIm += dy; changed = true; }
      else if (key == myself.KEY_DOWN) { myself.minIm -= dy; myself.maxIm -= dy; changed = true; }
    }
    int x = 0;
    int y = 0;
    int b = 0;
    int inside = 0;
    getmousestate(x, y, b, inside);
    if (inside == 0) {
      b = 0;
    }
    int winW = getmaxx() + 1;
    int winH = getmaxy() + 1;
    if (winW > 0 && winH > 0) {
      if (x >= winW) x = winW - 1;
      if (y >= winH) y = winH - 1;
      if (winW != myself.Width) { x = (x * myself.Width) / winW; if (x >= myself.Width) x = myself.Width - 1; }
      if (winH != myself.Height) { y = (y * myself.Height) / winH; if (y >= myself.Height) y = myself.Height - 1; }
    }
    if ((b & myself.ButtonLeft) != 0 && (myself.prevButtons & myself.ButtonLeft) == 0) {
      myself.zoom(x, y, 1.0 / myself.ZoomFactor);
      changed = true;
    } else if ((b & myself.ButtonRight) != 0 && (myself.prevButtons & myself.ButtonRight) == 0) {
      myself.zoom(x, y, myself.ZoomFactor);
      changed = true;
    }
    myself.prevButtons = b;
    return changed;
  }

  void run() {
    myself.init();
    bool needRender = true;
    while (!myself.getQuit()) {
      if (needRender && !myself.computing) {
        myself.startCompute();
        needRender = false;
      }
      // Poll ongoing compute to keep UI responsive
      myself.pollCompute();
      // Small yield to avoid a tight loop hogging CPU and to give SDL a chance to paint
      delay(1);
      // Handle input and restart compute on changes
      if (myself.handleInput()) {
        // Cancel any ongoing compute and restart
        myself.setCancel(true);
        if (myself.computing) {
          int i;
          for (i = 0; i < myself.ThreadCount; i = i + 1) { if (myself.tids[i] >= 0) { join myself.tids[i]; myself.tids[i] = -1; } }
          myself.computing = false;
        }
        myself.setCancel(false);
        needRender = true;
        // Immediate visual feedback
        updatetexture(myself.textureID, myself.pixels);
        cleardevice(); rendercopy(myself.textureID); updatescreen();
      }
    }
    // Cleanup
    if (myself.computing) {
      int i;
      for (i = 0; i < myself.ThreadCount; i = i + 1) { if (myself.tids[i] >= 0) { join myself.tids[i]; myself.tids[i] = -1; } }
    }
    destroytexture(myself.textureID);
    quittextsystem();
    closegraph();
  }
}

MandelbrotApp app = new MandelbrotApp();
app.run();
