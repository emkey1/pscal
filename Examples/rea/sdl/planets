#!/usr/bin/env rea
// SDL Solar System Simulation in Rea using OOP and threads.
// Each planet runs in its own thread and the frame rate is throttled.

const int NumPlanets = 8;
const int NumAsteroids = 200;

bool quit = false;
int posMutex = mutex();
float earthMonths = 0.0;

str trimTrailingSlashes(str path) {
  int len = length(path);
  while (len > 1 && path[len] == '/') {
    path = copy(path, 1, len - 1);
    len = len - 1;
  }
  if (len == 0) return "";
  return path;
}

str stripLeadingCurrent(str path) {
  while (length(path) >= 2 && copy(path, 1, 2) == "./") {
    if (length(path) == 2) {
      return "";
    }
    path = copy(path, 3, length(path) - 2);
  }
  return path;
}

str normalizePath(str path) {
  if (length(path) == 0) return "";
  if (path[1] == '/') return trimTrailingSlashes(path);
  str cleaned = stripLeadingCurrent(path);
  str pwd = getenv("PWD");
  if (length(pwd) == 0) {
    return trimTrailingSlashes(cleaned);
  }
  str base = trimTrailingSlashes(pwd);
  if (length(cleaned) == 0) {
    return base;
  }
  if (length(base) == 0) {
    return trimTrailingSlashes(cleaned);
  }
  if (length(base) == 1 && base[1] == '/') {
    return trimTrailingSlashes(base + cleaned);
  }
  return trimTrailingSlashes(base + '/' + cleaned);
}

str pathDirname(str path) {
  if (length(path) == 0) return "";
  str cleaned = trimTrailingSlashes(path);
  int len = length(cleaned);
  if (len == 0) return "";
  if (len == 1 && cleaned[1] == '/') return "/";
  int i = len;
  while (i > 0 && cleaned[i] != '/') i = i - 1;
  if (i <= 0) return "";
  if (i == 1) return "/";
  return trimTrailingSlashes(copy(cleaned, 1, i - 1));
}

str pathJoin(str base, str rel) {
  if (length(rel) == 0) return trimTrailingSlashes(base);
  if (length(base) == 0) return rel;
  str normalizedBase = trimTrailingSlashes(base);
  if (rel[1] == '/') {
    if (length(normalizedBase) == 1 && normalizedBase[1] == '/') {
      return rel;
    }
    return normalizedBase + rel;
  }
  if (length(normalizedBase) == 1 && normalizedBase[1] == '/') {
    return normalizedBase + rel;
  }
  return normalizedBase + '/' + rel;
}

bool pathExists(str path) {
  if (length(path) == 0) return false;
  if (fileexists(path)) return true;
  return false;
}

str defaultInstallRoot() {
  str scriptPath = normalizePath(paramstr(0));
  if (length(scriptPath) == 0) return "";
  str dir = pathDirname(scriptPath);
  if (length(dir) == 0) return "";
  dir = pathDirname(dir);
  if (length(dir) == 0) return "";
  dir = pathDirname(dir);
  if (length(dir) == 0) return "";
  dir = pathDirname(dir);
  return dir;
}

str resolveInstallRoot(str resourceRel) {
  str override = normalizePath(getenv("PSCAL_INSTALL_ROOT"));
  if (length(override) > 0) {
    if (length(resourceRel) == 0 || pathExists(pathJoin(override, resourceRel))) {
      return override;
    }
  }

  str candidate = defaultInstallRoot();
  if (length(candidate) > 0) {
    if (length(resourceRel) == 0 || pathExists(pathJoin(candidate, resourceRel))) {
      return candidate;
    }
  }

  str fallback = normalizePath("/opt/pscal");
  if (length(resourceRel) == 0 || pathExists(pathJoin(fallback, resourceRel))) {
    return fallback;
  }
  fallback = normalizePath("/usr/local/pscal");
  if (length(resourceRel) == 0 || pathExists(pathJoin(fallback, resourceRel))) {
    return fallback;
  }

  if (length(candidate) > 0) return candidate;
  if (length(override) > 0) return override;
  return fallback;
}

class Planet {
  int orbit;
  int size;

  float speed; // radians per update

  int r;
  int g;
  int b;
  float angle;
  float posX;
  float posY;
  int centerX;
  int centerY;
  int tid;
  int isEarth;

    Planet init(int o, int s, float spdDeg, int red, int green, int blue, int cx, int cy) {
      myself.orbit = o;
      myself.size = s;
      // Store angular speed in radians for precise updates even below 1 degree
      myself.speed = spdDeg * 0.017453292519943295; // degrees -> radians
      myself.r = red;
      myself.g = green;
      myself.b = blue;
      myself.centerX = cx;
      myself.centerY = cy;
      myself.isEarth = 0;
      // Initialize angle in radians as well
      myself.angle = random(360) * 0.017453292519943295;
      myself.posX = cx + cos(myself.angle) * o;
      myself.posY = cy + sin(myself.angle) * o;
      return myself;
    }

    void updateWorker() {
      while (!quit) {
        myself.angle = myself.angle + myself.speed;
        if (myself.angle >= 6.283185307179586) myself.angle = myself.angle - 6.283185307179586; // 2*pi
        float px = myself.centerX + cos(myself.angle) * myself.orbit;
        float py = myself.centerY + sin(myself.angle) * myself.orbit;
        lock(posMutex);
        myself.posX = px;
        myself.posY = py;
        if (myself.isEarth) {
          earthMonths = earthMonths + (myself.speed / 6.283185307179586) * 12;
        }
        unlock(posMutex);
        delay(16);
      }
    }

    void start() {
      myself.tid = spawn myself.updateWorker();
    }

    // Wait for the worker thread to finish. "join" is a reserved keyword in
    // Rea, so give the method a more explicit name to avoid confusion with the
    // built-in thread operation.
    void joinThread() {
      join myself.tid;
    }

    void draw() {
      setrgbcolor(myself.r, myself.g, myself.b);
      fillcircle(trunc(myself.posX), trunc(myself.posY), myself.size);
    }
  }

class SolarSystemApp {
  const int WindowWidth = 1280;
  const int WindowHeight = 1024;
  const int TargetFPS = 60;
  const float AUScale = 15.7; // pixels per astronomical unit
  const int AUOffset = 20;    // base offset so Mercury clears the sun
  const int OrbitSpacing = 2; // extra padding between successive orbits

    int FrameDelay;
    int centerX;
    int centerY;
    Planet planets[NumPlanets + 1];
    float asteroidAngle[NumAsteroids + 1];
    float asteroidSpeed[NumAsteroids + 1];
    int asteroidRadius[NumAsteroids + 1];

  void SolarSystemApp() {
    // no special initialization needed beyond defaults
  }

  void initPlanets() {
    int orbit;
    int extra = 0;
    // Mercury - 0.39 AU
    orbit = trunc(AUOffset + AUScale * 0.39 + extra);
    myself.planets[1] = new Planet(); myself.planets[1].init(orbit, 1, 4.7, 169, 169, 169, myself.centerX, myself.centerY);
    extra = extra + OrbitSpacing;
    // Venus - 0.72 AU
    orbit = trunc(AUOffset + AUScale * 0.72 + extra);
    myself.planets[2] = new Planet(); myself.planets[2].init(orbit, 2, 3.5, 218, 165,  32, myself.centerX, myself.centerY);
    extra = extra + OrbitSpacing;
    // Earth - 1.00 AU
    orbit = trunc(AUOffset + AUScale * 1.00 + extra);
    myself.planets[3] = new Planet(); myself.planets[3].init(orbit, 3, 3.0,   0, 102, 255, myself.centerX, myself.centerY);
    myself.planets[3].isEarth = 1;
    extra = extra + OrbitSpacing;
    // Mars - 1.52 AU
    orbit = trunc(AUOffset + AUScale * 1.52 + extra);
    myself.planets[4] = new Planet(); myself.planets[4].init(orbit, 2, 2.4, 188,  39,  50, myself.centerX, myself.centerY);
    extra = extra + OrbitSpacing;
    // Jupiter - 5.20 AU
    orbit = trunc(AUOffset + AUScale * 5.20 + extra);
    myself.planets[5] = new Planet(); myself.planets[5].init(orbit,18, 1.3, 205, 133,  63, myself.centerX, myself.centerY);
    extra = extra + OrbitSpacing;
    // Saturn - 9.58 AU
    orbit = trunc(AUOffset + AUScale * 9.58 + extra);
    myself.planets[6] = new Planet(); myself.planets[6].init(orbit,16, 0.9, 210, 180, 140, myself.centerX, myself.centerY);
    extra = extra + OrbitSpacing;
    // Uranus - 19.20 AU
    orbit = trunc(AUOffset + AUScale * 19.20 + extra);
    myself.planets[7] = new Planet(); myself.planets[7].init(orbit,12, 0.7, 173, 216, 230, myself.centerX, myself.centerY);
    extra = extra + OrbitSpacing;
    // Neptune - 30.05 AU
    orbit = trunc(AUOffset + AUScale * 30.05 + extra);
    myself.planets[8] = new Planet(); myself.planets[8].init(orbit,12, 0.5,  65, 105, 225, myself.centerX, myself.centerY);
  }

  void initAsteroids() {
    int i = 1;
    while (i <= NumAsteroids) {
      // Asteroid belt spans approximately 2.2 to 3.2 astronomical units
      // from the Sun, so pick a radius within that AU range scaled to
      // screen coordinates.
      int inner = trunc(AUOffset + AUScale * 2.2);
      int outer = trunc(AUOffset + AUScale * 3.2);
      myself.asteroidRadius[i] = inner + random(outer - inner);
      myself.asteroidAngle[i] = random(360) * 0.017453292519943295;
      myself.asteroidSpeed[i] = (0.1 + random(5) * 0.05) * 0.017453292519943295;
      i = i + 1;
    }
  }

  void startThreads() {
    int i = 1;
    while (i <= NumPlanets) {
      myself.planets[i].start();
      i = i + 1;
    }
  }

  void draw() {
    lock(posMutex);
    cleardevice();
    setrgbcolor(255, 255, 0); // Sun
    fillcircle(myself.centerX, myself.centerY, 12);
    setrgbcolor(169, 169, 169);
    int a = 1;
    while (a <= NumAsteroids) {
      myself.asteroidAngle[a] = myself.asteroidAngle[a] + myself.asteroidSpeed[a];
      if (myself.asteroidAngle[a] >= 6.283185307179586) {
        myself.asteroidAngle[a] = myself.asteroidAngle[a] - 6.283185307179586;
      }
      int ax = trunc(myself.centerX + cos(myself.asteroidAngle[a]) * myself.asteroidRadius[a]);
      int ay = trunc(myself.centerY + sin(myself.asteroidAngle[a]) * myself.asteroidRadius[a]);
      fillcircle(ax, ay, 1);
      a = a + 1;
    }
    int i = 1;
    while (i <= NumPlanets) {
      myself.planets[i].draw();
      i = i + 1;
    }
    str monthStr = "Earth months elapsed: " + inttostr(trunc(earthMonths));
    outtextxy(getmaxx() - 220, 16, monthStr);
    unlock(posMutex);
    updatescreen();
  }

  void joinThreads() {
    int i = 1;
    while (i <= NumPlanets) {
      myself.planets[i].joinThread();
      i = i + 1;
    }
  }

  void run() {
    initgraph(WindowWidth, WindowHeight, "Rea SDL Solar System");
    myself.centerX = getmaxx() / 2;
    myself.centerY = getmaxy() / 2;
    str installRoot;
    installRoot = resolveInstallRoot("/fonts/Roboto/static/Roboto-Regular.ttf");
    inittextsystem(pathJoin(installRoot, "/fonts/Roboto/static/Roboto-Regular.ttf"), 16);
    randomize();
    myself.FrameDelay = trunc(1000 / TargetFPS);
    myself.initPlanets();
    myself.initAsteroids();
    // Start planet worker threads using the current object instance
    myself.startThreads();
    writeln("Solar system simulation running. Press Q to quit.");
    while (!quit) {
      if (keypressed()) {
        char c = readkey();
        if (toupper(c) == 'Q') quit = true;
      }
      // Draw all planets based on their updated positions
      myself.draw();
      // Use the object's frame delay to pace the main loop and yield time to
      // planet worker threads, ensuring smooth motion.
      graphloop(myself.FrameDelay);
    }
    // Wait for all planet worker threads to finish before shutting down
    myself.joinThreads();
    closegraph();
    writeln("Simulation finished.");
  }
}

SolarSystemApp app = new SolarSystemApp();
app.run();
