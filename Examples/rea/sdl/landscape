#!/usr/bin/env rea
// Procedural landscape demo for the Rea front end. Generates a deterministic
// height field from a seed, renders it with the SDL/OpenGL helpers, and lets
// the user walk with either WASD or the arrow keys while steering the camera
// with the mouse.

const int WindowWidth = 1280;
const int WindowHeight = 1024;
const int TerrainSize = 192;
const int VertexStride = TerrainSize + 1;
const int VertexCount = VertexStride * VertexStride;
const float TileScale = 1.2;
const float InvTileScale = 1.0 / TileScale;
const float InvTwoTileScale = 0.5 * InvTileScale;
const int NoiseOctaves = 5;
const float HeightScale = 16.0;
const float EyeHeight = 6.5;
const float MoveSpeed = 18.0;
const float MaxPitch = 75.0;
const float MouseYawSensitivity = 0.30;
const float MousePitchSensitivity = 0.15;
const float KeyTurnSpeed = 90.0;
const float DegreesToRadians = 0.017453292519943295;
const float Pi = 3.141592653589793;
const float TwoPi = 6.283185307179586;
const int CloudCount = 14;
const int CloudPuffSegments = 24;
const float SunDistance = 220.0;
const float SunCoreRadius = 18.0;
const float SunHaloRadius = 34.0;
const int SunHaloSegments = 96;
const int SunGlowSegments = 96;
const int SunCoreSegments = 48;
const int LensFlareCount = 4;
const int ScanCodeW = 26; // SDL_SCANCODE_W
const int ScanCodeS = 22; // SDL_SCANCODE_S
const int ScanCodeA = 4;  // SDL_SCANCODE_A
const int ScanCodeD = 7;  // SDL_SCANCODE_D
const int ScanCodeUp = 82;    // SDL_SCANCODE_UP
const int ScanCodeDown = 81;  // SDL_SCANCODE_DOWN
const int ScanCodeLeft = 80;  // SDL_SCANCODE_LEFT
const int ScanCodeRight = 79; // SDL_SCANCODE_RIGHT

bool envFlagEnabled(str name) {
  return getenvint(name, 0) != 0;
}

bool extendedBuiltinsDisabled() {
  if (envFlagEnabled("REA_LANDSCAPE_FORCE_SOFTWARE")) return true;
  if (envFlagEnabled("REA_LANDSCAPE_DISABLE_EXT")) return true;
  return false;
}

bool fastDrawEnabledByDefault() {
  if (envFlagEnabled("REA_LANDSCAPE_DISABLE_FAST_DRAW")) return false;
  if (envFlagEnabled("REA_LANDSCAPE_FORCE_FAST_DRAW")) return true;
  if (envFlagEnabled("REA_LANDSCAPE_ENABLE_FAST_DRAW")) return true;
  return true;
}

bool hasDigit(str s) {
  int i = 1;
  while (i <= length(s)) {
    char ch = s[i];
    if (ch >= '0' && ch <= '9') return true;
    i = i + 1;
  }
  return false;
}

int parseIntegerFromString(str s, int fallback) {
  int len = length(s);
  int idx = 1;
  while (idx <= len) {
    char ch = s[idx];
    if ((ch >= '0' && ch <= '9') || ch == '+' || ch == '-') break;
    idx = idx + 1;
  }
  if (idx > len) return fallback;
  int sign = 1;
  if (s[idx] == '+') {
    idx = idx + 1;
  } else if (s[idx] == '-') {
    sign = -1;
    idx = idx + 1;
  }
  int value = 0;
  bool any = false;
  while (idx <= len) {
    char ch = s[idx];
    if (ch >= '0' && ch <= '9') {
      any = true;
      value = value * 10 + (ch - '0');
    } else {
      break;
    }
    idx = idx + 1;
  }
  if (!any) return fallback;
  return value * sign;
}

float absf(float value) {
  if (value < 0.0) return -value;
  return value;
}

bool floatIsFinite(float value) {
  if (!(value == value)) return false;
  float magnitude = absf(value);
  if (magnitude > 1e12) return false;
  return true;
}

bool floatWithinTolerance(float a, float b, float tolerance) {
  float diff = a - b;
  diff = absf(diff);
  return diff <= tolerance;
}

bool hasDigit(str s) {
  int i = 1;
  while (i <= length(s)) {
    char ch = s[i];
    if (ch >= '0' && ch <= '9') return true;
    i = i + 1;
  }
  return false;
}

int extractSeedFromArgs(int fallback) {
  int count = paramcount();
  if (count == 0) return fallback;
  int i = 1;
  while (i <= count) {
    str arg = paramstr(i);
    if (hasDigit(arg)) {
      return parseIntegerFromString(arg, fallback);
    }
    i = i + 1;
  }
  return fallback;
}

class TerrainField {
  float heights[VertexCount];
  float minHeight;
  float maxHeight;
  float normalizationScale;
  int seed;

  void TerrainField() {
    my.seed = 0;
    my.minHeight = 0.0;
    my.maxHeight = 0.0;
    my.normalizationScale = 0.0;
    int total = VertexCount;
    int i = 0;
    while (i < total) {
      my.heights[i] = 0.0;
      i = i + 1;
    }
  }

  int index(int x, int z) { return z * (TerrainSize + 1) + x; }

  float baseNoise(int x, int z) {
    int n = x * 374761393 + z * 668265263 + my.seed * 362437;
    n = n % 2147483647;
    if (n < 0) n = n + 2147483647;
    float value = n / 2147483647.0;
    return value * 2.0 - 1.0;
  }

  float fade(float t) { return t * t * (3.0 - 2.0 * t); }

  float valueNoise(float x, float z) {
    int xi = floor(x);
    int zi = floor(z);
    float xf = x - xi;
    float zf = z - zi;
    float v00 = my.baseNoise(xi, zi);
    float v10 = my.baseNoise(xi + 1, zi);
    float v01 = my.baseNoise(xi, zi + 1);
    float v11 = my.baseNoise(xi + 1, zi + 1);
    float u = my.fade(xf);
    float v = my.fade(zf);
    float i1 = v00 + (v10 - v00) * u;
    float i2 = v01 + (v11 - v01) * u;
    return i1 + (i2 - i1) * v;
  }

  float fbm(float x, float z) {
    float amplitude = 1.0;
    float frequency = 1.0;
    float sum = 0.0;
    float total = 0.0;
    int octave = 0;
    while (octave < NoiseOctaves) {
      sum = sum + my.valueNoise(x * frequency, z * frequency) * amplitude;
      total = total + amplitude;
      amplitude = amplitude * 0.5;
      frequency = frequency * 2.0;
      octave = octave + 1;
    }
    if (total == 0.0) return 0.0;
    return sum / total;
  }
  bool tryBuildFast(int s) {
    if (!hasextbuiltin("user", "LandscapeBuildHeightField")) {
      return false;
    }
    float minHeight = 0.0;
    float maxHeight = 9.0;
    float normalizationScale = 0.0;
    landscapebuildheightfield(my.heights,
                              s,
                              TerrainSize,
                              VertexStride,
                              HeightScale,
                              NoiseOctaves,
                              minHeight,
                              maxHeight,
                              normalizationScale);
    my.minHeight = minHeight;
    my.maxHeight = maxHeight;
    my.normalizationScale = normalizationScale;
    if (!floatIsFinite(my.minHeight) || !floatIsFinite(my.maxHeight) ||
        !floatIsFinite(my.normalizationScale)) {
      return false;
    }
    if (my.minHeight > my.maxHeight) {
      return false;
    }
    int total = VertexCount;
    if (total <= 0) {
      return false;
    }
    float computedMin = my.heights[0];
    float computedMax = my.heights[0];
    int idx = 0;
    while (idx < total) {
      float sample = my.heights[idx];
      if (!floatIsFinite(sample)) {
        return false;
      }
      if (sample < computedMin) computedMin = sample;
      if (sample > computedMax) computedMax = sample;
      idx = idx + 1;
    }
    if (!floatWithinTolerance(computedMin, my.minHeight, 0.01) ||
        !floatWithinTolerance(computedMax, my.maxHeight, 0.01)) {
      return false;
    }
    float span = computedMax - computedMin;
    if (span <= 0.0001) {
      if (absf(my.normalizationScale) > 0.0001) {
        return false;
      }
    } else {
      float expectedScale = 1.0 / span;
      if (!floatWithinTolerance(expectedScale, my.normalizationScale, 0.01)) {
        return false;
      }
    }
    return true;
  }

  void build(int s) {
    my.seed = s;
    if (my.tryBuildFast(s)) {
      return;
    }
    my.minHeight = 1e9;
    my.maxHeight = -1e9;
    float baseFrequency = 0.035;
    int z = 0;
    while (z <= TerrainSize) {
      int x = 0;
      while (x <= TerrainSize) {
        float sampleX = (x + s * 0.13) * baseFrequency;
        float sampleZ = (z + s * 0.29) * baseFrequency;
        float h = my.fbm(sampleX, sampleZ) * HeightScale;
        int idx = my.index(x, z);
        my.heights[idx] = h;
        if (h < my.minHeight) my.minHeight = h;
        if (h > my.maxHeight) my.maxHeight = h;
        x = x + 1;
      }
      z = z + 1;
    }
    float span = my.maxHeight - my.minHeight;
    if (span <= 0.0001) {
      my.maxHeight = my.minHeight + 0.001;
      span = my.maxHeight - my.minHeight;
    }
    if (span <= 0.0001) {
      my.normalizationScale = 0.0;
    } else {
      my.normalizationScale = 1.0 / span;
    }
  }

  float rawHeight(int x, int z) {
    if (x < 0) x = 0;
    if (x > TerrainSize) x = TerrainSize;
    if (z < 0) z = 0;
    if (z > TerrainSize) z = TerrainSize;
    return my.heights[my.index(x, z)];
  }

  float heightByFlatIndex(int idx) {
    return my.heights[idx];
  }

  float normalized(float h) {
    if (my.normalizationScale <= 0.0) return 0.0;
    float t = (h - my.minHeight) * my.normalizationScale;
    if (t < 0.0) t = 0.0;
    if (t > 1.0) t = 1.0;
    return t;
  }

  float heightAt(float gx, float gz) {
    if (gx < 0.0) gx = 0.0;
    if (gx > TerrainSize) gx = TerrainSize;
    if (gz < 0.0) gz = 0.0;
    if (gz > TerrainSize) gz = TerrainSize;
    int x0 = floor(gx);
    int z0 = floor(gz);
    int x1 = x0 + 1;
    int z1 = z0 + 1;
    if (x1 > TerrainSize) x1 = TerrainSize;
    if (z1 > TerrainSize) z1 = TerrainSize;
    float h00 = my.rawHeight(x0, z0);
    float h10 = my.rawHeight(x1, z0);
    float h01 = my.rawHeight(x0, z1);
    float h11 = my.rawHeight(x1, z1);
    float tx = gx - x0;
    float tz = gz - z0;
    float hx0 = h00 + (h10 - h00) * tx;
    float hx1 = h01 + (h11 - h01) * tx;
    return hx0 + (hx1 - hx0) * tz;
  }
}

class LandscapeDemo {
  TerrainField field;
  int seed;
  float camX;
  float camZ;
  float camY;
  float yaw;
  float pitch;
  int lastTicks;
  bool running;
  int lastMouseX;
  int lastMouseY;
  bool hasMouseSample;
  float vertexHeights[VertexCount];
  float vertexColorR[VertexCount];
  float vertexColorG[VertexCount];
  float vertexColorB[VertexCount];
  float vertexNormalX[VertexCount];
  float vertexNormalY[VertexCount];
  float vertexNormalZ[VertexCount];
  float worldXCoords[VertexStride];
  float worldZCoords[VertexStride];
  float waterPhaseOffset[VertexCount];
  float waterSecondaryOffset[VertexCount];
  float waterSparkleOffset[VertexCount];
  float sunDirX;
  float sunDirY;
  float sunDirZ;
  float waterHeight;
  float waterNormalizedLevel;
  float elapsedSeconds;
  bool allowExtendedBuiltins;
  bool fastTerrainAvailable;
  bool fastWaterAvailable;
  bool fastDrawEnabled;
  bool useFastTerrain;
  bool useFastWater;
  bool useFastWorldCoords;
  bool useFastWaterOffsets;
  bool useFastVertexBake;
  float cloudAzimuth[CloudCount];
  float cloudElevation[CloudCount];
  float cloudDistance[CloudCount];
  float cloudScale[CloudCount];
  float cloudSpeed[CloudCount];
  float cloudBrightness[CloudCount];
  float cloudRoll[CloudCount];
  int cloudPuffCount[CloudCount];
  float cloudPrimaryRadius[CloudCount];
  float cloudVerticalRadius[CloudCount];
  float cloudClusterSpread[CloudCount];
  float cloudCircleCos[CloudPuffSegments + 1];
  float cloudCircleSin[CloudPuffSegments + 1];
  float sunHaloCos[SunHaloSegments + 1];
  float sunHaloSin[SunHaloSegments + 1];
  float sunHaloJitter[SunHaloSegments + 1];
  float sunGlowScale[SunGlowSegments + 1];
  float sunCoreCos[SunCoreSegments + 1];
  float sunCoreSin[SunCoreSegments + 1];
  float lensOffsets[LensFlareCount];
  float lensSizes[LensFlareCount];
  float lensColorR[LensFlareCount];
  float lensColorG[LensFlareCount];
  float lensColorB[LensFlareCount];
  float lensAlpha[LensFlareCount];

  void LandscapeDemo(int initialSeed) {
    my.field = new TerrainField();
    my.seed = initialSeed;
    bool disableExt = extendedBuiltinsDisabled();
    my.allowExtendedBuiltins = !disableExt;
    if (disableExt) {
      writeln("Extended landscape builtins disabled by environment override.");
    }
    my.useFastWorldCoords = false;
    if (my.allowExtendedBuiltins && my.tryPrecomputeWorldCoordinates()) {
      my.useFastWorldCoords = true;
    } else {
      my.precomputeWorldCoordinates();
    }
    my.useFastWaterOffsets = false;
    if (my.allowExtendedBuiltins && my.tryPrecomputeWaterOffsets()) {
      my.useFastWaterOffsets = true;
    } else {
      my.precomputeWaterOffsets();
    }
    my.fastTerrainAvailable = my.allowExtendedBuiltins &&
                              hasextbuiltin("user", "LandscapeDrawTerrain");
    my.fastWaterAvailable = my.allowExtendedBuiltins &&
                             hasextbuiltin("user", "LandscapeDrawWater");
    my.fastDrawEnabled = false;
    my.useFastTerrain = false;
    my.useFastWater = false;
    if (my.allowExtendedBuiltins && fastDrawEnabledByDefault()) {
      str reason = "default configuration";
      if (envFlagEnabled("REA_LANDSCAPE_FORCE_FAST_DRAW") ||
          envFlagEnabled("REA_LANDSCAPE_ENABLE_FAST_DRAW")) {
        reason = "environment override";
      }
      my.enableFastDraw(reason);
    }
    my.elapsedSeconds = 0.0;
    my.waterNormalizedLevel = 0.36;
    float sunX = 0.45;
    float sunY = 0.82;
    float sunZ = 0.33;
    float invLen = 1.0 / sqrt(sunX * sunX + sunY * sunY + sunZ * sunZ);
    my.sunDirX = sunX * invLen;
    my.sunDirY = sunY * invLen;
    my.sunDirZ = sunZ * invLen;
    my.field.build(initialSeed);
    my.initializeSkyElements();
    my.updateVertexData();
    my.camX = TerrainSize * 0.5;
    my.camZ = TerrainSize * 0.5;
    my.camY = my.field.heightAt(my.camX, my.camZ) + EyeHeight;
    my.yaw = 135.0;
    my.pitch = -20.0;
    my.lastTicks = getticks();
    my.running = true;
    my.lastMouseX = 0;
    my.lastMouseY = 0;
    my.hasMouseSample = false;
    my.useFastVertexBake = false;
  }

  void enableFastDraw(str reason) {
    if (!my.allowExtendedBuiltins) {
      writeln("Cannot enable fast draw: extended builtins have been disabled.");
      my.fastDrawEnabled = false;
      my.useFastTerrain = false;
      my.useFastWater = false;
      return;
    }
    if (!my.fastTerrainAvailable && !my.fastWaterAvailable) {
      writeln("Fast draw builtins are not available on this runtime.");
      my.fastDrawEnabled = false;
      my.useFastTerrain = false;
      my.useFastWater = false;
      return;
    }
    my.fastDrawEnabled = true;
    my.useFastTerrain = my.fastTerrainAvailable;
    my.useFastWater = my.fastWaterAvailable;
    writeln("Fast draw enabled (", reason, ").");
    if (!my.fastTerrainAvailable || !my.fastWaterAvailable) {
      if (my.fastTerrainAvailable && !my.fastWaterAvailable) {
        writeln("  Note: water rendering will continue to use the software path.");
      } else if (!my.fastTerrainAvailable && my.fastWaterAvailable) {
        writeln("  Note: terrain rendering will continue to use the software path.");
      }
    }
  }

  void disableFastDraw(str reason) {
    if (!my.fastDrawEnabled) return;
    my.fastDrawEnabled = false;
    my.useFastTerrain = false;
    my.useFastWater = false;
    writeln("Fast draw disabled (", reason, ").");
  }

  void toggleFastDraw() {
    if (my.fastDrawEnabled) {
      my.disableFastDraw("toggled");
    } else {
      my.enableFastDraw("toggled");
    }
  }

  bool tryPrecomputeWorldCoordinates() {
    if (!hasextbuiltin("user", "LandscapePrecomputeWorldCoords")) {
      return false;
    }
    landscapeprecomputeworldcoords(my.worldXCoords,
                                   my.worldZCoords,
                                   TileScale,
                                   TerrainSize,
                                   VertexStride);
    float half = TerrainSize * 0.5;
    float expectedMin = (0.0 - half) * TileScale;
    float expectedMax = (TerrainSize - half) * TileScale;
    float minSample = my.worldXCoords[0];
    float maxSample = my.worldXCoords[TerrainSize];
    if (!(minSample == minSample) || !(maxSample == maxSample)) {
      return false;
    }
    float diffMin = minSample - expectedMin;
    if (diffMin < 0.0) diffMin = -diffMin;
    float diffMax = maxSample - expectedMax;
    if (diffMax < 0.0) diffMax = -diffMax;
    if (diffMin > 0.0005 || diffMax > 0.0005) {
      return false;
    }
    return true;
  }

  void precomputeWorldCoordinates() {
    float half = TerrainSize * 0.5;
    int i = 0;
    while (i < VertexStride) {
      float world = (i - half) * TileScale;
      my.worldXCoords[i] = world;
      my.worldZCoords[i] = world;
      i = i + 1;
    }
  }

  bool tryPrecomputeWaterOffsets() {
    if (!hasextbuiltin("user", "LandscapePrecomputeWaterOffsets")) {
      return false;
    }
    landscapeprecomputewateroffsets(my.waterPhaseOffset,
                                    my.waterSecondaryOffset,
                                    my.waterSparkleOffset,
                                    TerrainSize,
                                    VertexStride);
    if (TerrainSize >= 1) {
      int checkIdx = 1;
      float expectedPhase = 0.18;
      float phase = my.waterPhaseOffset[checkIdx];
      float secondary = my.waterSecondaryOffset[checkIdx];
      if (!(phase == phase) || !(secondary == secondary)) {
        return false;
      }
      float phaseDiff = phase - expectedPhase;
      if (phaseDiff < 0.0) phaseDiff = -phaseDiff;
      float expectedSecondary = 0.05;
      float secondaryDiff = secondary - expectedSecondary;
      if (secondaryDiff < 0.0) secondaryDiff = -secondaryDiff;
      if (phaseDiff > 0.0005 || secondaryDiff > 0.0005) {
        return false;
      }
    }
    return true;
  }

  void precomputeWaterOffsets() {
    int z = 0;
    while (z <= TerrainSize) {
      int rowIndex = z * VertexStride;
      float zPhase = z * 0.12;
      float zSecondary = z * 0.21;
      float zSparkle = z * 0.22;
      int x = 0;
      while (x <= TerrainSize) {
        int idx = rowIndex + x;
        my.waterPhaseOffset[idx] = x * 0.18 + zPhase;
        my.waterSecondaryOffset[idx] = x * 0.05 + zSecondary;
        my.waterSparkleOffset[idx] = x * 0.22 + zSparkle;
        x = x + 1;
      }
      z = z + 1;
    }
  }

  float skyRandom(int index, int salt) {
    int xSeed = index * 97 + salt * 193 + my.seed * 37;
    int zSeed = index * 131 + salt * 167 + my.seed * 59;
    float noise = my.field.baseNoise(xSeed, zSeed);
    return noise * 0.5 + 0.5;
  }

  void initCircleLut(float cosTable[], float sinTable[], int segments) {
    int i = 0;
    float step = TwoPi / segments;
    while (i <= segments) {
      float angle = i * step;
      cosTable[i] = cos(angle);
      sinTable[i] = sin(angle);
      i = i + 1;
    }
  }

  void initializeSkyElements() {
    my.initCircleLut(my.cloudCircleCos, my.cloudCircleSin, CloudPuffSegments);
    my.initCircleLut(my.sunHaloCos, my.sunHaloSin, SunHaloSegments);
    my.initCircleLut(my.sunCoreCos, my.sunCoreSin, SunCoreSegments);
    int haloIndex = 0;
    while (haloIndex <= SunHaloSegments) {
      float angle = haloIndex * (TwoPi / SunHaloSegments);
      my.sunHaloJitter[haloIndex] = 0.92 + sin(angle * 4.0) * 0.04;
      haloIndex = haloIndex + 1;
    }
    int glowIndex = 0;
    while (glowIndex <= SunGlowSegments) {
      float angle = glowIndex * (TwoPi / SunGlowSegments);
      my.sunGlowScale[glowIndex] = 0.90 + cos(angle * 3.0) * 0.05;
      glowIndex = glowIndex + 1;
    }
    my.lensOffsets[0] = -0.32;
    my.lensSizes[0] = 0.85;
    my.lensColorR[0] = 1.0;
    my.lensColorG[0] = 0.78;
    my.lensColorB[0] = 0.46;
    my.lensAlpha[0] = 0.42;
    my.lensOffsets[1] = 0.18;
    my.lensSizes[1] = 1.55;
    my.lensColorR[1] = 0.98;
    my.lensColorG[1] = 0.74;
    my.lensColorB[1] = 0.52;
    my.lensAlpha[1] = 0.30;
    my.lensOffsets[2] = 0.58;
    my.lensSizes[2] = 0.65;
    my.lensColorR[2] = 0.76;
    my.lensColorG[2] = 0.84;
    my.lensColorB[2] = 1.0;
    my.lensAlpha[2] = 0.26;
    my.lensOffsets[3] = 0.92;
    my.lensSizes[3] = 1.95;
    my.lensColorR[3] = 0.90;
    my.lensColorG[3] = 0.82;
    my.lensColorB[3] = 0.60;
    my.lensAlpha[3] = 0.18;
    int i = 0;
    while (i < CloudCount) {
      float azNoise = my.skyRandom(i, 11);
      float elevNoise = my.skyRandom(i, 23);
      float distNoise = my.skyRandom(i, 41);
      float scaleNoise = my.skyRandom(i, 61);
      float speedNoise = my.skyRandom(i, 83);
      float brightNoise = my.skyRandom(i, 101);
      float rollNoise = my.skyRandom(i, 121);
      float puffNoise = my.skyRandom(i, 151);
      my.cloudAzimuth[i] = azNoise * TwoPi;
      my.cloudElevation[i] = 0.16 + elevNoise * 0.20;
      my.cloudDistance[i] = 150.0 + distNoise * 90.0;
      my.cloudScale[i] = 15.0 + scaleNoise * 20.0;
      my.cloudSpeed[i] = 0.002 + speedNoise * 0.006;
      my.cloudBrightness[i] = 0.68 + brightNoise * 0.26;
      my.cloudRoll[i] = rollNoise * TwoPi;
      my.cloudPuffCount[i] = 3 + floor(puffNoise * 4.0);
      if (my.cloudPuffCount[i] < 3) my.cloudPuffCount[i] = 3;
      my.cloudPrimaryRadius[i] = 0.50 + my.skyRandom(i, 167) * 0.32;
      my.cloudVerticalRadius[i] = 0.34 + my.skyRandom(i, 181) * 0.28;
      my.cloudClusterSpread[i] = 0.32 + my.skyRandom(i, 193) * 0.55;
      i = i + 1;
    }
  }

  float saturate(float value) {
    if (value < 0.0) return 0.0;
    if (value > 1.0) return 1.0;
    return value;
  }

  float lerp(float a, float b, float t) { return a + (b - a) * t; }

  void computeVertexNormals() {
    int z = 0;
    while (z <= TerrainSize) {
      int x = 0;
      while (x <= TerrainSize) {
        float left = my.field.rawHeight(x - 1, z);
        float right = my.field.rawHeight(x + 1, z);
        float down = my.field.rawHeight(x, z - 1);
        float up = my.field.rawHeight(x, z + 1);
        float dx = (right - left) * InvTwoTileScale;
        float dz = (up - down) * InvTwoTileScale;
        float nx = -dx;
        float ny = 1.0;
        float nz = -dz;
        float length = sqrt(nx * nx + ny * ny + nz * nz);
        if (length <= 0.0001) length = 1.0;
        nx = nx / length;
        ny = ny / length;
        nz = nz / length;
        int idx = z * VertexStride + x;
        my.vertexNormalX[idx] = nx;
        my.vertexNormalY[idx] = ny;
        my.vertexNormalZ[idx] = nz;
        x = x + 1;
      }
      z = z + 1;
    }
  }

  bool tryBakeVertexData(float waterLevel) {
    if (!hasextbuiltin("user", "LandscapeBakeVertexData")) {
      return false;
    }
    // Ensure the water height slot is initialised with a numeric value so the
    // native helper accepts it as a VAR parameter. We use an out-of-range
    // sentinel so we can detect if the builtin failed to write a result.
    my.waterHeight = -1.0e30;
    landscapebakevertexdata(my.field.heights,
                            my.vertexHeights,
                            my.vertexNormalX,
                            my.vertexNormalY,
                            my.vertexNormalZ,
                            my.vertexColorR,
                            my.vertexColorG,
                            my.vertexColorB,
                            my.waterHeight,
                            my.field.minHeight,
                              my.field.maxHeight,
                              my.field.normalizationScale,
                              waterLevel,
                            TileScale,
                            TerrainSize,
                            VertexStride);
    if (!floatIsFinite(my.waterHeight) || my.waterHeight <= -1.0e29) {
      return false;
    }
    int total = VertexCount;
    int idx = 0;
    while (idx < total) {
      float height = my.vertexHeights[idx];
      float normalX = my.vertexNormalX[idx];
      float normalY = my.vertexNormalY[idx];
      float normalZ = my.vertexNormalZ[idx];
      float colorR = my.vertexColorR[idx];
      float colorG = my.vertexColorG[idx];
      float colorB = my.vertexColorB[idx];
      if (!floatIsFinite(height) ||
          !floatIsFinite(normalX) ||
          !floatIsFinite(normalY) ||
          !floatIsFinite(normalZ) ||
          !floatIsFinite(colorR) ||
          !floatIsFinite(colorG) ||
          !floatIsFinite(colorB)) {
        return false;
      }
      float expectedHeight = my.field.heightByFlatIndex(idx);
      if (!floatIsFinite(expectedHeight) ||
          !floatWithinTolerance(height, expectedHeight, 0.05)) {
        return false;
      }
      float normalLenSq = normalX * normalX + normalY * normalY + normalZ * normalZ;
      if (!floatIsFinite(normalLenSq) || normalLenSq <= 0.0001) {
        return false;
      }
      float normalLen = sqrt(normalLenSq);
      if (!floatIsFinite(normalLen) || normalLen <= 0.01 || normalLen > 10.0) {
        return false;
      }
      if (colorR < -0.01 || colorR > 1.01 ||
          colorG < -0.01 || colorG > 1.01 ||
          colorB < -0.01 || colorB > 1.01) {
        return false;
      }
      idx = idx + 1;
    }
    if (my.waterHeight < my.field.minHeight - 50.0 ||
        my.waterHeight > my.field.maxHeight + 50.0) {
      return false;
    }
    return true;
  }

  void updateVertexData() {
    my.useFastVertexBake = false;
    if (my.allowExtendedBuiltins &&
        my.tryBakeVertexData(my.waterNormalizedLevel)) {
      my.useFastVertexBake = true;
      return;
    }
    my.computeVertexNormals();
    float span = my.field.maxHeight - my.field.minHeight;
    if (span <= 0.0001) span = 1.0;
    my.waterHeight = my.field.minHeight + span * my.waterNormalizedLevel;
    int idx = 0;
    while (idx < VertexCount) {
      float h = my.field.heightByFlatIndex(idx);
      my.vertexHeights[idx] = h;
      float t = my.field.normalized(h);
      float r;
      float g;
      float b;
      bool underwater = t < my.waterNormalizedLevel;
      if (underwater) {
        float depth = (my.waterNormalizedLevel - t) / my.waterNormalizedLevel;
        if (depth < 0.0) depth = 0.0;
        if (depth > 1.0) depth = 1.0;
        float shore = 1.0 - depth;
        r = 0.05 + 0.08 * depth + 0.10 * shore;
        g = 0.32 + 0.36 * depth + 0.18 * shore;
        b = 0.52 + 0.40 * depth + 0.12 * shore;
      } else if (t < my.waterNormalizedLevel + 0.06) {
        float w = (t - my.waterNormalizedLevel) / 0.06;
        r = 0.36 + 0.14 * w;
        g = 0.34 + 0.20 * w;
        b = 0.20 + 0.09 * w;
      } else if (t < 0.62) {
        float w = (t - (my.waterNormalizedLevel + 0.06)) / 0.16;
        r = 0.24 + 0.18 * w;
        g = 0.46 + 0.32 * w;
        b = 0.22 + 0.12 * w;
      } else if (t < 0.82) {
        float w = (t - 0.62) / 0.20;
        r = 0.46 + 0.26 * w;
        g = 0.40 + 0.22 * w;
        b = 0.30 + 0.20 * w;
      } else {
        float w = (t - 0.82) / 0.18;
        if (w < 0.0) w = 0.0;
        if (w > 1.0) w = 1.0;
        float base = 0.84 + 0.14 * w;
        r = base;
        g = base;
        b = base;
        float frost = my.saturate((t - 0.88) / 0.12);
        float sunSpark = 0.75 + 0.25 * frost;
        r = my.lerp(r, sunSpark, frost * 0.4);
        g = my.lerp(g, sunSpark, frost * 0.4);
        b = my.lerp(b, sunSpark, frost * 0.6);
      }

      if (!underwater) {
        float slope = 1.0 - my.vertexNormalY[idx];
        if (slope < 0.0) slope = 0.0;
        if (slope > 1.0) slope = 1.0;
        float cool = my.saturate((0.58 - t) * 3.5);
        g = g + cool * 0.04;
        b = b + cool * 0.06;
        float alpine = my.saturate((t - 0.68) * 2.2);
        r = my.lerp(r, r * 0.92, alpine * 0.3);
        g = my.lerp(g, g * 0.90, alpine * 0.26);
        b = my.lerp(b, b * 1.05, alpine * 0.24);
        float slopeTint = slope * 0.6;
        r = my.lerp(r, r * 0.78, slopeTint);
        g = my.lerp(g, g * 0.74, slopeTint);
        b = my.lerp(b, b * 0.86, slopeTint);
      }

      r = my.saturate(r);
      g = my.saturate(g);
      b = my.saturate(b);

      my.vertexColorR[idx] = r;
      my.vertexColorG[idx] = g;
      my.vertexColorB[idx] = b;
      idx = idx + 1;
    }
  }

  void drawSunBillboard(float rightX,
                        float rightY,
                        float rightZ,
                        float upX,
                        float upY,
                        float upZ,
                        float forwardX,
                        float forwardY,
                        float forwardZ) {
    float sunX = my.sunDirX * SunDistance;
    float sunY = my.sunDirY * SunDistance;
    float sunZ = my.sunDirZ * SunDistance;
    float outerRadius = SunHaloRadius * 1.45;
    float innerHaloRadius = SunHaloRadius * 1.05;
    float glowRadius = SunHaloRadius * 0.82;
    float dayFactor = my.saturate(0.35 + my.sunDirY * 0.9);
    float haloCool = my.lerp(0.32, 0.56, dayFactor);
    float haloWarm = my.lerp(0.78, 1.0, dayFactor);
    float glowAlpha = my.lerp(0.42, 0.62, dayFactor);

    GLBegin("triangle_strip");
    int i = 0;
    while (i <= SunHaloSegments) {
      float cosA = my.sunHaloCos[i];
      float sinA = my.sunHaloSin[i];
      float jitter = my.sunHaloJitter[i];
      float outerX = rightX * (cosA * outerRadius) + upX * (sinA * outerRadius);
      float outerY = rightY * (cosA * outerRadius) + upY * (sinA * outerRadius);
      float outerZ = rightZ * (cosA * outerRadius) + upZ * (sinA * outerRadius);
      float innerX = rightX * (cosA * innerHaloRadius) +
                     upX * (sinA * innerHaloRadius);
      float innerY = rightY * (cosA * innerHaloRadius) +
                     upY * (sinA * innerHaloRadius);
      float innerZ = rightZ * (cosA * innerHaloRadius) +
                     upZ * (sinA * innerHaloRadius);
      GLColor4f(haloCool, haloCool + 0.14, my.saturate(haloCool + 0.32), 0.0);
      GLVertex3f(sunX + outerX, sunY + outerY, sunZ + outerZ);
      GLColor4f(haloWarm, my.lerp(0.78, 0.92, dayFactor), 0.62 + dayFactor * 0.18,
                0.16 * jitter);
      GLVertex3f(sunX + innerX, sunY + innerY, sunZ + innerZ);
      i = i + 1;
    }
    GLEnd();

    GLBegin("triangle_fan");
    GLColor4f(1.0, 0.97 + dayFactor * 0.02, 0.86 + dayFactor * 0.08, glowAlpha);
    GLVertex3f(sunX, sunY, sunZ);
    i = 0;
    while (i <= SunGlowSegments) {
      float cosA = my.sunHaloCos[i];
      float sinA = my.sunHaloSin[i];
      float rimScale = my.sunGlowScale[i];
      float offsetX = rightX * (cosA * glowRadius * rimScale) +
                      upX * (sinA * glowRadius * rimScale);
      float offsetY = rightY * (cosA * glowRadius * rimScale) +
                      upY * (sinA * glowRadius * rimScale);
      float offsetZ = rightZ * (cosA * glowRadius * rimScale) +
                      upZ * (sinA * glowRadius * rimScale);
      GLColor4f(1.0, 0.92 + dayFactor * 0.05, 0.70 + dayFactor * 0.16, 0.20);
      GLVertex3f(sunX + offsetX, sunY + offsetY, sunZ + offsetZ);
      i = i + 1;
    }
    GLEnd();

    GLBegin("triangle_fan");
    GLColor4f(1.0, 1.0, 0.94, 0.95);
    GLVertex3f(sunX, sunY, sunZ);
    i = 0;
    while (i <= SunCoreSegments) {
      float cosA = my.sunCoreCos[i];
      float sinA = my.sunCoreSin[i];
      float offsetX = rightX * (cosA * SunCoreRadius * 0.9) +
                      upX * (sinA * SunCoreRadius * 0.9);
      float offsetY = rightY * (cosA * SunCoreRadius * 0.9) +
                      upY * (sinA * SunCoreRadius * 0.9);
      float offsetZ = rightZ * (cosA * SunCoreRadius * 0.9) +
                      upZ * (sinA * SunCoreRadius * 0.9);
      GLColor4f(1.0, 0.95 + dayFactor * 0.04, 0.70 + dayFactor * 0.22, 0.42);
      GLVertex3f(sunX + offsetX, sunY + offsetY, sunZ + offsetZ);
      i = i + 1;
    }
    GLEnd();

    float sunViewForward = my.sunDirX * forwardX +
                           my.sunDirY * forwardY +
                           my.sunDirZ * forwardZ;
    float sunViewRight = my.sunDirX * rightX +
                         my.sunDirY * rightY +
                         my.sunDirZ * rightZ;
    float sunViewUp = my.sunDirX * upX + my.sunDirY * upY + my.sunDirZ * upZ;
    float axisLen = sqrt(sunViewRight * sunViewRight + sunViewUp * sunViewUp);
    float axisRight = 0.0;
    float axisUp = 0.0;
    if (axisLen > 0.0001) {
      axisRight = -sunViewRight / axisLen;
      axisUp = -sunViewUp / axisLen;
    }
    float focus = my.saturate(1.0 - axisLen * 0.85);
    float baseIntensity = my.saturate(0.3 + sunViewForward * 0.7);
    float lensIntensity = focus * baseIntensity;
    if (lensIntensity > 0.001 && sunViewForward > 0.0) {
      GLBlendFunc("one", "one");
      int flareIndex = 0;
      while (flareIndex < LensFlareCount) {
        float alpha = my.lensAlpha[flareIndex] * lensIntensity;
        if (alpha > 0.001) {
          float offset = my.lensOffsets[flareIndex];
          float offsetDistance = offset * SunHaloRadius * 2.4;
          float offsetRight = axisRight * offsetDistance;
          float offsetUp = axisUp * offsetDistance;
          float centerX = sunX + rightX * offsetRight + upX * offsetUp;
          float centerY = sunY + rightY * offsetRight + upY * offsetUp;
          float centerZ = sunZ + rightZ * offsetRight + upZ * offsetUp;
          float radius = my.lensSizes[flareIndex] * SunCoreRadius;
          float halfRightX = rightX * radius;
          float halfRightY = rightY * radius;
          float halfRightZ = rightZ * radius;
          float halfUpX = upX * radius;
          float halfUpY = upY * radius;
          float halfUpZ = upZ * radius;
          float colorR = my.lensColorR[flareIndex] * alpha;
          float colorG = my.lensColorG[flareIndex] * alpha;
          float colorB = my.lensColorB[flareIndex] * alpha;
          GLBegin("triangle_strip");
          GLColor4f(colorR, colorG, colorB, alpha);
          GLVertex3f(centerX - halfRightX - halfUpX,
                     centerY - halfRightY - halfUpY,
                     centerZ - halfRightZ - halfUpZ);
          GLColor4f(colorR, colorG, colorB, 0.0);
          GLVertex3f(centerX - halfRightX + halfUpX,
                     centerY - halfRightY + halfUpY,
                     centerZ - halfRightZ + halfUpZ);
          GLColor4f(colorR, colorG, colorB, alpha);
          GLVertex3f(centerX + halfRightX - halfUpX,
                     centerY + halfRightY - halfUpY,
                     centerZ + halfRightZ - halfUpZ);
          GLColor4f(colorR, colorG, colorB, 0.0);
          GLVertex3f(centerX + halfRightX + halfUpX,
                     centerY + halfRightY + halfUpY,
                     centerZ + halfRightZ + halfUpZ);
          GLEnd();
        }
        flareIndex = flareIndex + 1;
      }
      GLBlendFunc("src_alpha", "one_minus_src_alpha");
    }
  }

  void drawCloudPuff(float centerX,
                     float centerY,
                     float centerZ,
                     float radiusX,
                     float radiusY,
                     float rightX,
                     float rightY,
                     float rightZ,
                     float upX,
                     float upY,
                     float upZ,
                     float brightness,
                     float sunRightInfluence,
                     float sunUpInfluence) {
    float centerBase = my.saturate(0.68 + brightness * 0.30);
    float centerR = my.saturate(centerBase + 0.18);
    float centerG = my.saturate(centerBase + 0.10);
    float centerB = my.saturate(centerBase + 0.24);
    GLBegin("triangle_fan");
    GLColor4f(centerR, centerG, centerB, 0.68);
    GLVertex3f(centerX, centerY, centerZ);
    int i = 0;
    while (i <= CloudPuffSegments) {
      float cosA = my.cloudCircleCos[i];
      float sinA = my.cloudCircleSin[i];
      float px = centerX + rightX * (cosA * radiusX) + upX * (sinA * radiusY);
      float py = centerY + rightY * (cosA * radiusX) + upY * (sinA * radiusY);
      float pz = centerZ + rightZ * (cosA * radiusX) + upZ * (sinA * radiusY);
      float sunEdge = cosA * sunRightInfluence + sinA * sunUpInfluence;
      float rimWarm = my.saturate(0.62 + brightness * 0.28 + sunEdge * 0.32);
      float rimCool = my.saturate(0.56 + brightness * 0.20 - sunEdge * 0.20);
      float rimR = my.lerp(rimCool, rimWarm, 0.65);
      float rimG = my.lerp(rimCool, rimWarm, 0.40);
      float rimB = my.lerp(rimCool + 0.08, rimWarm + 0.12, 0.55);
      float rimAlpha = my.saturate(0.04 + brightness * 0.06 - sunEdge * 0.05);
      GLColor4f(rimR, rimG, rimB, rimAlpha);
      GLVertex3f(px, py, pz);
      i = i + 1;
    }
    GLEnd();
  }

  void drawCloudLayer(float timeSeconds,
                      float rightX,
                      float rightY,
                      float rightZ,
                      float upX,
                      float upY,
                      float upZ) {
    int i = 0;
    while (i < CloudCount) {
      float azimuth = my.cloudAzimuth[i] + timeSeconds * my.cloudSpeed[i];
      float elevation = my.cloudElevation[i];
      float distance = my.cloudDistance[i];
      float cosElev = cos(elevation);
      float sinElev = sin(elevation);
      float dirX = sin(azimuth) * cosElev;
      float dirY = sinElev;
      float dirZ = cos(azimuth) * cosElev;
      float centerX = dirX * distance;
      float centerY = dirY * distance;
      float centerZ = dirZ * distance;
      float baseScale = my.cloudScale[i];
      float baseBrightness = my.cloudBrightness[i];
      float sunInfluence = my.sunDirX * dirX + my.sunDirY * dirY + my.sunDirZ * dirZ;
      float puffBrightness = my.saturate(baseBrightness + sunInfluence * 0.18);
      float radiusX = baseScale * my.cloudPrimaryRadius[i];
      float radiusY = baseScale * my.cloudVerticalRadius[i];
      float clusterSpread = baseScale * my.cloudClusterSpread[i];
      float roll = my.cloudRoll[i];
      float cosRoll = cos(roll);
      float sinRoll = sin(roll);
      float basisRightX = rightX * cosRoll + upX * sinRoll;
      float basisRightY = rightY * cosRoll + upY * sinRoll;
      float basisRightZ = rightZ * cosRoll + upZ * sinRoll;
      float basisUpX = upX * cosRoll - rightX * sinRoll;
      float basisUpY = upY * cosRoll - rightY * sinRoll;
      float basisUpZ = upZ * cosRoll - rightZ * sinRoll;
      float sunRightInfluence = my.sunDirX * basisRightX +
                                my.sunDirY * basisRightY +
                                my.sunDirZ * basisRightZ;
      float sunUpInfluence = my.sunDirX * basisUpX +
                             my.sunDirY * basisUpY +
                             my.sunDirZ * basisUpZ;

      my.drawCloudPuff(centerX,
                       centerY,
                       centerZ,
                       radiusX,
                       radiusY,
                       basisRightX,
                       basisRightY,
                       basisRightZ,
                       basisUpX,
                       basisUpY,
                       basisUpZ,
                       puffBrightness,
                       sunRightInfluence,
                       sunUpInfluence);

      int puffCount = my.cloudPuffCount[i];
      int puffIndex = 1;
      while (puffIndex < puffCount) {
        int saltBase = 211 + puffIndex * 37;
        float angle = my.skyRandom(i, saltBase) * TwoPi;
        float radialNoise = my.skyRandom(i, saltBase + 11);
        float heightNoise = my.skyRandom(i, saltBase + 19);
        float forwardNoise = my.skyRandom(i, saltBase + 29);
        float scaleNoise = my.skyRandom(i, saltBase + 37);
        float aspectNoise = my.skyRandom(i, saltBase + 43);
        float brightnessNoise = my.skyRandom(i, saltBase + 53);

        float offsetRight = cos(angle) * (clusterSpread * (0.45 + radialNoise * 0.75));
        float offsetUp = sin(angle) * (clusterSpread * 0.40) +
                         (heightNoise - 0.5) * baseScale * 0.35;
        float offsetForward = (forwardNoise - 0.5) * baseScale * 0.25;

        float puffRadiusX = radiusX * (0.60 + scaleNoise * 0.55);
        float puffRadiusY = radiusY * (0.75 + aspectNoise * 0.40);

        float puffCenterX = centerX +
                            basisRightX * offsetRight +
                            basisUpX * offsetUp +
                            dirX * offsetForward;
        float puffCenterY = centerY +
                            basisRightY * offsetRight +
                            basisUpY * offsetUp +
                            dirY * offsetForward;
        float puffCenterZ = centerZ +
                            basisRightZ * offsetRight +
                            basisUpZ * offsetUp +
                            dirZ * offsetForward;

        float puffLight = my.saturate(puffBrightness + (brightnessNoise - 0.5) * 0.22);

        my.drawCloudPuff(puffCenterX,
                         puffCenterY,
                         puffCenterZ,
                         puffRadiusX,
                         puffRadiusY,
                         basisRightX,
                         basisRightY,
                         basisRightZ,
                         basisUpX,
                         basisUpY,
                         basisUpZ,
                         puffLight,
                         sunRightInfluence,
                         sunUpInfluence);
        puffIndex = puffIndex + 1;
      }
      i = i + 1;
    }
  }

  void drawSky(float timeSeconds) {
    float yawRadians = my.yaw * DegreesToRadians;
    float pitchRadians = my.pitch * DegreesToRadians;
    float cosYaw = cos(yawRadians);
    float sinYaw = sin(yawRadians);
    float cosPitch = cos(pitchRadians);
    float sinPitch = sin(pitchRadians);
    float forwardX = sinYaw * cosPitch;
    float forwardY = -sinPitch;
    float forwardZ = cosYaw * cosPitch;
    float rightX = forwardZ;
    float rightY = 0.0;
    float rightZ = -forwardX;
    float rightLen = sqrt(rightX * rightX + rightZ * rightZ);
    if (rightLen <= 0.0001) {
      rightX = 1.0;
      rightY = 0.0;
      rightZ = 0.0;
      rightLen = 1.0;
    }
    rightX = rightX / rightLen;
    rightZ = rightZ / rightLen;
    float upX = forwardY * rightZ - forwardZ * rightY;
    float upY = forwardZ * rightX - forwardX * rightZ;
    float upZ = forwardX * rightY - forwardY * rightX;
    float upLen = sqrt(upX * upX + upY * upY + upZ * upZ);
    if (upLen <= 0.0001) {
      upX = 0.0;
      upY = 1.0;
      upZ = 0.0;
    } else {
      upX = upX / upLen;
      upY = upY / upLen;
      upZ = upZ / upLen;
    }
    my.drawSunBillboard(rightX,
                        rightY,
                        rightZ,
                        upX,
                        upY,
                        upZ,
                        forwardX,
                        forwardY,
                        forwardZ);
    my.drawCloudLayer(timeSeconds, rightX, rightY, rightZ, upX, upY, upZ);
  }

  void setupLighting() {
    GLClearDepth(1.0);
    GLDepthTest(true);
    GLEnable("lighting");
    GLEnable("light0");
    GLEnable("color_material");
    GLEnable("normalize");
    GLShadeModel("smooth");
    GLColorMaterial("front", "ambient_and_diffuse");
//    GLEnable("cull_face");
//    GLCullFace("back");

    GLLightfv("light0", "ambient", 0.20, 0.24, 0.30, 1.0);
    GLLightfv("light0", "diffuse", 0.90, 0.90, 0.88, 1.0);
    GLLightfv("light0", "specular", 0.55, 0.60, 0.70, 1.0);

    GLMaterialfv("front", "specular", 0.32, 0.34, 0.38, 1.0);
    GLMaterialf("front", "shininess", 26.0);

    GLBlendFunc("src_alpha", "one_minus_src_alpha");
  }

  void initGraphics() {
    InitGraph3D(WindowWidth, WindowHeight, "Rea Terrain", 24, 8);
    GLViewport(0, 0, WindowWidth, WindowHeight);
    GLSetSwapInterval(1);
    my.setupLighting();
    writeln("Controls: W/S or Up/Down to move, A/D or Left/Right to turn, use the mouse to look around. N/P change seed, R randomizes, F toggles fast draw, Q or Esc exits.");
    if (my.fastDrawEnabled) {
      writeln("Fast draw active; press F to switch back to the software renderer.");
    }
    if (my.useFastTerrain ||
        my.useFastWater ||
        my.useFastWorldCoords ||
        my.useFastWaterOffsets) {
      writeln("Using extended landscape builtins for improved performance.");
    }
    int mouseX = 0;
    int mouseY = 0;
    int mouseButtons = 0;
    int mouseInside = 0;
    getmousestate(mouseX, mouseY, mouseButtons, mouseInside);
    if (mouseInside != 0) {
      my.lastMouseX = mouseX;
      my.lastMouseY = mouseY;
      my.hasMouseSample = true;
    } else {
      my.hasMouseSample = false;
    }
  }

  void regenerate(int newSeed) {
    my.seed = newSeed;
    my.field.build(newSeed);
    my.initializeSkyElements();
    my.updateVertexData();
    my.camX = TerrainSize * 0.5;
    my.camZ = TerrainSize * 0.5;
    my.camY = my.field.heightAt(my.camX, my.camZ) + EyeHeight;
    my.elapsedSeconds = 0.0;
    writeln("Generated landscape for seed ", my.seed, ".");
  }

  void handleDiscreteInput() {
    int key = pollkey();
    while (key != 0) {
      if (key == 'q' || key == 'Q' || key == 27) {
        my.running = false;
        return;
      } else if (key == 'n' || key == 'N') {
        my.regenerate(my.seed + 1);
      } else if (key == 'p' || key == 'P') {
        my.regenerate(my.seed - 1);
      } else if (key == 'r' || key == 'R') {
        int tickSeed = getticks();
        if (tickSeed == 0) tickSeed = my.seed + 7;
        my.regenerate(tickSeed);
      } else if (key == 'f' || key == 'F') {
        my.toggleFastDraw();
      }
      key = pollkey();
    }
  }

  void drawTerrain() {
    if (my.useFastTerrain) {
      landscapedrawterrain(my.vertexHeights,
                           my.vertexColorR,
                           my.vertexColorG,
                           my.vertexColorB,
                           my.vertexNormalX,
                           my.vertexNormalY,
                           my.vertexNormalZ,
                           my.worldXCoords,
                           my.worldZCoords,
                           TerrainSize,
                           VertexStride);
      return;
    }
    int z = 0;
    while (z < TerrainSize) {
      GLBegin("triangle_strip");
      float worldZ0 = my.worldZCoords[z];
      float worldZ1 = my.worldZCoords[z + 1];
      int rowIndex = z * VertexStride;
      int nextRowIndex = (z + 1) * VertexStride;
      int x = 0;
      while (x <= TerrainSize) {
        int idx0 = rowIndex + x;
        int idx1 = nextRowIndex + x;
        float worldX = my.worldXCoords[x];
        GLNormal3f(my.vertexNormalX[idx0],
                   my.vertexNormalY[idx0],
                   my.vertexNormalZ[idx0]);
        GLColor3f(my.vertexColorR[idx0], my.vertexColorG[idx0], my.vertexColorB[idx0]);
        GLVertex3f(worldX, my.vertexHeights[idx0], worldZ0);
        GLNormal3f(my.vertexNormalX[idx1],
                   my.vertexNormalY[idx1],
                   my.vertexNormalZ[idx1]);
        GLColor3f(my.vertexColorR[idx1], my.vertexColorG[idx1], my.vertexColorB[idx1]);
        GLVertex3f(worldX, my.vertexHeights[idx1], worldZ1);
        x = x + 1;
      }
      GLEnd();
      z = z + 1;
    }
  }

    void emitWaterVertex(int idx,
                       int gridX,
                       int gridZ,
                       float groundHeight,
                       float basePhase,
                       float baseSecondary,
                       float baseSparkle) {
    float depth = my.waterHeight - groundHeight;
    if (depth < 0.0) depth = 0.0;
    if (depth > 6.0) depth = 6.0;
    float depthFactor = depth / 6.0;
    float shallow = 1.0 - depthFactor;
    float ripple = sin(basePhase + my.waterPhaseOffset[idx]) *
                   (0.08 + 0.04 * depthFactor);
    float ripple2 = cos(baseSecondary + my.waterSecondaryOffset[idx]) *
                    (0.05 + 0.05 * depthFactor);
    float surfaceHeight = my.waterHeight + 0.05 + ripple + ripple2;
    float worldX = my.worldXCoords[gridX];
    float worldZ = my.worldZCoords[gridZ];
    float foam = my.saturate(1.0 - depth * 0.45);
    float sparkle = 0.02 + 0.06 * sin(baseSparkle + my.waterSparkleOffset[idx]);
    float r = 0.05 + 0.08 * depthFactor + 0.18 * foam + sparkle * shallow * 0.4;
    float g = 0.34 + 0.30 * depthFactor + 0.26 * foam + sparkle * shallow * 0.5;
    float b = 0.55 + 0.32 * depthFactor + 0.22 * foam + sparkle * 0.6;
    r = my.saturate(r);
    g = my.saturate(g);
    b = my.saturate(b);
    float alpha = 0.35 + 0.30 * shallow + sparkle * 0.4;
    if (alpha < 0.18) alpha = 0.18;
    if (alpha > 0.82) alpha = 0.82;
    GLColor4f(r, g, b, alpha);
    GLNormal3f(0.0, 1.0, 0.0);
    GLVertex3f(worldX, surfaceHeight, worldZ);
  }

  void drawWater(float timeSeconds) {
    GLEnable("blend");
    GLBlendFunc("src_alpha", "one_minus_src_alpha");
    if (my.useFastWater) {
      landscapedrawwater(my.vertexHeights,
                         my.worldXCoords,
                         my.worldZCoords,
                         my.waterPhaseOffset,
                         my.waterSecondaryOffset,
                         my.waterSparkleOffset,
                         my.waterHeight,
                         timeSeconds,
                         TerrainSize,
                         VertexStride);
      GLDisable("blend");
      return;
    }
    float allowance = 0.18;
    float maxWaterHeight = my.waterHeight + allowance;
    float basePhase = timeSeconds * 0.7;
    float baseSecondary = timeSeconds * 1.6;
    float baseSparkle = timeSeconds * 2.4;
    GLBegin("triangles");
    int z = 0;
    while (z < TerrainSize) {
      int rowIndex = z * VertexStride;
      int nextRowIndex = (z + 1) * VertexStride;
      int x = 0;
      while (x < TerrainSize) {
        int idx00 = rowIndex + x;
        int idx10 = rowIndex + x + 1;
        int idx01 = nextRowIndex + x;
        int idx11 = nextRowIndex + x + 1;
        float h00 = my.vertexHeights[idx00];
        float h10 = my.vertexHeights[idx10];
        float h01 = my.vertexHeights[idx01];
        float h11 = my.vertexHeights[idx11];
        if (h00 <= maxWaterHeight &&
            h10 <= maxWaterHeight &&
            h01 <= maxWaterHeight) {
          my.emitWaterVertex(idx00, x, z, h00, basePhase, baseSecondary, baseSparkle);
          my.emitWaterVertex(idx10, x + 1, z, h10, basePhase, baseSecondary, baseSparkle);
          my.emitWaterVertex(idx01, x, z + 1, h01, basePhase, baseSecondary, baseSparkle);
        }
        if (h10 <= maxWaterHeight &&
            h11 <= maxWaterHeight &&
            h01 <= maxWaterHeight) {
          my.emitWaterVertex(idx10, x + 1, z, h10, basePhase, baseSecondary, baseSparkle);
          my.emitWaterVertex(idx11, x + 1, z + 1, h11, basePhase, baseSecondary, baseSparkle);
          my.emitWaterVertex(idx01, x, z + 1, h01, basePhase, baseSecondary, baseSparkle);
        }
        x = x + 1;
      }
      z = z + 1;
    }
    GLEnd();
    GLDisable("blend");
  }

  void updateCamera(float dt) {
    if (dt > 0.1) dt = 0.1;
    int mouseX = 0;
    int mouseY = 0;
    int mouseButtons = 0;
    int mouseInside = 0;
    getmousestate(mouseX, mouseY, mouseButtons, mouseInside);
    bool insideWindow = mouseInside != 0;
    if (!insideWindow) {
      my.hasMouseSample = false;
    } else if (!my.hasMouseSample) {
      my.lastMouseX = mouseX;
      my.lastMouseY = mouseY;
      my.hasMouseSample = true;
    } else {
      int deltaX = mouseX - my.lastMouseX;
      int deltaY = mouseY - my.lastMouseY;
      my.lastMouseX = mouseX;
      my.lastMouseY = mouseY;
      if (deltaX != 0 || deltaY != 0) {
        int maxDeltaX = WindowWidth / 2;
        int maxDeltaY = WindowHeight / 2;
        if (deltaX >= -maxDeltaX && deltaX <= maxDeltaX &&
            deltaY >= -maxDeltaY && deltaY <= maxDeltaY) {
          my.yaw = my.yaw - deltaX * MouseYawSensitivity;
          my.pitch = my.pitch - deltaY * MousePitchSensitivity;
        }
      }
    }

    bool forward = IsKeyDown(ScanCodeS) || IsKeyDown(ScanCodeUp);
    bool backward = IsKeyDown(ScanCodeW) || IsKeyDown(ScanCodeDown);

    float moveForward = 0.0;
    if (forward) moveForward = moveForward + 1.0;
    if (backward) moveForward = moveForward - 1.0;
    if (moveForward != 0.0) {
      float speed = MoveSpeed * dt * moveForward;
      float yawRadians = my.yaw * DegreesToRadians;
      float pitchRadians = my.pitch * DegreesToRadians;
      float forwardX = sin(yawRadians) * cos(pitchRadians);
      float forwardZ = cos(yawRadians) * cos(pitchRadians);
      float forwardLen = sqrt(forwardX * forwardX + forwardZ * forwardZ);
      if (forwardLen < 0.0001) {
        forwardX = sin(yawRadians);
        forwardZ = cos(yawRadians);
        forwardLen = sqrt(forwardX * forwardX + forwardZ * forwardZ);
      }
      if (forwardLen > 0.0001) {
        forwardX = forwardX / forwardLen;
        forwardZ = forwardZ / forwardLen;
      }
      float deltaX = forwardX * speed * InvTileScale;
      float deltaZ = forwardZ * speed * InvTileScale;
      my.camX = my.camX + deltaX;
      my.camZ = my.camZ + deltaZ;
    }

    float turnInput = 0.0;
    bool turnLeft = IsKeyDown(ScanCodeLeft) || IsKeyDown(ScanCodeA);
    bool turnRight = IsKeyDown(ScanCodeRight) || IsKeyDown(ScanCodeD);
    if (turnLeft) turnInput = turnInput + 1.0;
    if (turnRight) turnInput = turnInput - 1.0;
    if (turnInput != 0.0) {
      my.yaw = my.yaw + turnInput * KeyTurnSpeed * dt;
    }

    if (my.yaw >= 360.0) my.yaw = my.yaw - 360.0;
    if (my.yaw < 0.0) my.yaw = my.yaw + 360.0;
    if (my.pitch > MaxPitch) my.pitch = MaxPitch;
    if (my.pitch < -MaxPitch) my.pitch = -MaxPitch;

    if (my.camX < 1.0) my.camX = 1.0;
    if (my.camX > TerrainSize - 1) my.camX = TerrainSize - 1;
    if (my.camZ < 1.0) my.camZ = 1.0;
    if (my.camZ > TerrainSize - 1) my.camZ = TerrainSize - 1;

    my.camY = my.field.heightAt(my.camX, my.camZ) + EyeHeight;
  }

  void drawFrame() {
    GLClearColor(0.36, 0.55, 0.78, 1.0);
    GLClear();

    GLMatrixMode("projection");
    GLLoadIdentity();
    float aspect = WindowWidth / float(WindowHeight);
    GLPerspective(68.0, aspect, 0.1, 320.0);

    GLMatrixMode("modelview");
    GLLoadIdentity();
    GLLightfv("light0", "position", my.sunDirX, my.sunDirY, my.sunDirZ, 0.0);
    GLRotatef(-my.pitch, 1.0, 0.0, 0.0);
    GLRotatef(-my.yaw, 0.0, 1.0, 0.0);
    GLDisable("lighting");
    GLEnable("blend");
    GLBlendFunc("src_alpha", "one_minus_src_alpha");
    my.drawSky(my.elapsedSeconds);
    GLDisable("blend");
    GLEnable("lighting");
    float half = TerrainSize * 0.5;
    float worldX = (my.camX - half) * TileScale;
    float worldZ = (my.camZ - half) * TileScale;
    GLTranslatef(-worldX, -my.camY, -worldZ);

    my.drawTerrain();
    my.drawWater(my.elapsedSeconds);
    GLSwapWindow();
  }

  void run() {
    my.initGraphics();
    my.lastTicks = getticks();
    while (my.running) {
      // Pump SDL events before sampling keyboard state so IsKeyDown observes
      // the latest key transitions. SDL_GetKeyboardState (used by IsKeyDown)
      // only reflects new input after SDL_PumpEvents or a polling helper runs.
      GraphLoop(0);
      my.handleDiscreteInput();
      if (QuitRequested()) break;
      int now = getticks();
      float dt = (now - my.lastTicks) / 1000.0;
      my.lastTicks = now;
      if (dt < 0.0) dt = 0.0;
      my.updateCamera(dt);
      my.elapsedSeconds = my.elapsedSeconds + dt;
      my.drawFrame();
      GraphLoop(1);
    }
    CloseGraph3D();
  }
}

int main() {
  int defaultSeed = 1337;
  int seed = extractSeedFromArgs(defaultSeed);
  printf("Calculating initial values.  This make take a bit. \n");
  LandscapeDemo demo = new LandscapeDemo(seed);
  demo.run();
  return 0;
}
