#!/usr/bin/env rea
// SDL Multi Bouncing Balls 3D demo rewritten to use Rea's OOP extensions.
// Requires building Pscal with SDL/OpenGL support.

const int WindowWidth = 1600;
const int WindowHeight = 1000;
const int WindowMarginX = 160;
const int WindowMarginY = 160;
const int MinWindowWidth = 1024;
const int MinWindowHeight = 720;

float TargetFPS = 90.0;

const int NumBalls = 320;
const float BoxWidth = 1440.0;
const float BoxHeight = 820.0;
const float BoxDepth = 600.0;
const float WallElasticity = 1.08;
const float VelocityDrag = 0.995;

const float ManualYawSpeed = 160.0;
const float ManualPitchSpeed = 90.0;
const float ManualZoomSpeed = 820.0;
const float MinCameraPitch = -60.0;
const float MaxCameraPitch = 25.0;
const float MinCameraDistance = 620.0;
const float MaxCameraDistance = 3200.0;

const int ScanCodeLeft = 79;  // SDL_SCANCODE_LEFT
const int ScanCodeRight = 80; // SDL_SCANCODE_RIGHT
const int ScanCodeUp = 82;    // SDL_SCANCODE_UP
const int ScanCodeDown = 81;  // SDL_SCANCODE_DOWN
const int ScanCodeForward = 26; // SDL_SCANCODE_W
const int ScanCodeBackward = 22; // SDL_SCANCODE_S

const int SphereStacks = 20;
const int SphereSlices = 36;
const float Pi = 3.1415926535;

const int NumStars = 361;
const float StarInnerRadiusScale = 1.45;
const float StarOuterRadiusScale = 2.85;
const float LightStarSize = 22.0;
const float LightStarBrightness = 1.0;
const float LightStarTwinkleRate = 0.22;

const float LightDirX = -0.55;
const float LightDirY = -0.35;
const float LightDirZ = 0.78;
const float AmbientLevel = 0.18;

const float InitialCameraPitch = -12.0;
const float CameraOrbitSpeed = 0.0;
const float MinInitialSpeed = 180.0;
const float MaxInitialSpeed = 1000.0;
const float InitialCameraDistance = 2200.0;

float randomUnit() {
  return random(10000) / 10000.0;
}

class Camera {
  float yaw;
  float pitch;
  float distance;
  float yawVelocity;
  float orbitSpeed;
  float minPitch;
  float maxPitch;

  Camera(float initialYaw, float initialPitch, float initialDistance) {
    my.yaw = initialYaw;
    my.pitch = initialPitch;
    my.distance = initialDistance;
    my.orbitSpeed = CameraOrbitSpeed;
    my.yawVelocity = my.orbitSpeed;
    my.minPitch = MinCameraPitch;
    my.maxPitch = MaxCameraPitch;
  }

  void handleInput(float deltaTime) {
    bool leftDown = IsKeyDown(ScanCodeLeft);
    bool rightDown = IsKeyDown(ScanCodeRight);
    bool upDown = IsKeyDown(ScanCodeUp);
    bool downDown = IsKeyDown(ScanCodeDown);
    bool forwardDown = IsKeyDown(ScanCodeForward);
    bool backwardDown = IsKeyDown(ScanCodeBackward);

    float yawInput = 0.0;
    if (leftDown) yawInput = yawInput - 1.0;
    if (rightDown) yawInput = yawInput + 1.0;
    if (yawInput == 0.0) {
      my.yawVelocity = my.orbitSpeed;
    } else {
      my.yawVelocity = yawInput * ManualYawSpeed;
    }

    if (upDown && !downDown) {
      my.pitch = my.pitch + deltaTime * ManualPitchSpeed;
    } else if (downDown && !upDown) {
      my.pitch = my.pitch - deltaTime * ManualPitchSpeed;
    }

    if (my.pitch > my.maxPitch) my.pitch = my.maxPitch;
    if (my.pitch < my.minPitch) my.pitch = my.minPitch;

    if (forwardDown && !backwardDown) {
      my.distance = my.distance - deltaTime * ManualZoomSpeed;
    } else if (backwardDown && !forwardDown) {
      my.distance = my.distance + deltaTime * ManualZoomSpeed;
    }

    if (my.distance < MinCameraDistance) my.distance = MinCameraDistance;
    if (my.distance > MaxCameraDistance) my.distance = MaxCameraDistance;
  }

  void update(float deltaTime) {
    my.yaw = my.yaw + deltaTime * my.yawVelocity;
    if (my.yaw >= 360.0) {
      my.yaw = my.yaw - 360.0;
    }
    if (my.yaw < 0.0) {
      my.yaw = my.yaw + 360.0;
    }
  }

  void applyTransform() {
    GLTranslatef(0.0, 0.0, -my.distance);
    GLRotatef(my.pitch, 1.0, 0.0, 0.0);
    GLRotatef(my.yaw, 0.0, 1.0, 0.0);
  }
}

class BallField {
  float posX[NumBalls];
  float posY[NumBalls];
  float posZ[NumBalls];
  float velX[NumBalls];
  float velY[NumBalls];
  float velZ[NumBalls];
  float radii[NumBalls];
  float screenX[NumBalls];
  float screenY[NumBalls];
  float screenRadius[NumBalls];
  float depthShade[NumBalls];
  int colorR[NumBalls];
  int colorG[NumBalls];
  int colorB[NumBalls];
  bool glassMode;

  void setGlassMode(bool enabled) {
    my.glassMode = enabled;
  }

  void init(float minSpeed, float maxSpeed) {
    int i = 0;
    float halfWidth = BoxWidth * 0.5;
    float halfHeight = BoxHeight * 0.5;
    while (i < NumBalls) {
      float r = 12.0 + random(26);
      float availX = BoxWidth - 2.0 * r;
      float availY = BoxHeight - 2.0 * r;
      float availZ = BoxDepth - 2.0 * r;
      if (availX < 4.0) availX = 4.0;
      if (availY < 4.0) availY = 4.0;
      if (availZ < 4.0) availZ = 4.0;

      my.radii[i] = r;
      my.posX[i] = -halfWidth + r + randomUnit() * availX;
      my.posY[i] = -halfHeight + r + randomUnit() * availY;
      my.posZ[i] = -r - randomUnit() * (BoxDepth - 2.0 * r);

      int speedRange = trunc(maxSpeed - minSpeed);
      float speed = minSpeed + random(speedRange + 1) + randomUnit();
      float yaw = random(360) * (Pi / 180.0);
      float pitch = (random(121) - 60.0) * (Pi / 180.0);
      float dirXY = cos(pitch);
      my.velX[i] = cos(yaw) * dirXY * speed;
      my.velY[i] = sin(pitch) * speed;
      my.velZ[i] = sin(yaw) * dirXY * speed;

      my.colorR[i] = 40 + random(210);
      my.colorG[i] = 40 + random(210);
      my.colorB[i] = 40 + random(210);
      i = i + 1;
    }
  }

  void drawBall(int index) {
    float baseR = my.colorR[index] / 255.0;
    float baseG = my.colorG[index] / 255.0;
    float baseB = my.colorB[index] / 255.0;
    float depthFactor = 0.55 + 0.45 * (1.0 - my.depthShade[index]);
    if (depthFactor < 0.0) depthFactor = 0.0;
    if (depthFactor > 1.0) depthFactor = 1.0;
    float glassAlpha = 0.32 + 0.50 * depthFactor;
    if (glassAlpha > 0.85) glassAlpha = 0.85;

    GLPushMatrix();
    GLTranslatef(my.posX[index], my.posY[index], my.posZ[index]);
    GLScalef(my.radii[index], my.radii[index], my.radii[index]);
    if (my.glassMode) {
      //GLColor4f(baseR * 0.9, baseG * 0.9, baseB * 0.9, glassAlpha);
      GLColor4f(baseR, baseG, baseB, glassAlpha);
    } else {
      GLColor3f(baseR, baseG, baseB);
    }
    BouncingBalls3DDrawUnitSphereFast(SphereStacks, SphereSlices);
    GLPopMatrix();
  }

  void draw() {
    bool blendingActive = false;
    if (my.glassMode) {
      GLEnable("blend");
      GLBlendFunc("src_alpha", "one_minus_src_alpha");
      blendingActive = true;
    }

    int i = 0;
    while (i < NumBalls) {
      my.drawBall(i);
      i = i + 1;
    }

    if (blendingActive) {
      GLDisable("blend");
    }
  }

  void update(float deltaTime, float minSpeed, float maxSpeed, float cameraDistance) {
    BouncingBalls3DStepUltra(NumBalls, deltaTime, BoxWidth, BoxHeight, BoxDepth,
      WallElasticity, minSpeed, maxSpeed, VelocityDrag,
      cameraDistance, WindowWidth, WindowHeight,
      my.posX, my.posY, my.posZ,
      my.velX, my.velY, my.velZ, my.radii,
      my.screenX, my.screenY, my.screenRadius, my.depthShade);
  }
}

class StarField {
  float starX[NumStars];
  float starY[NumStars];
  float starZ[NumStars];
  float starSize[NumStars];
  float starBaseBrightness[NumStars];
  float starTwinkleRate[NumStars];
  float starPhase[NumStars];

  void init(float cameraDistance) {
    int i = 0;
    float boxRadius = BoxWidth;
    if (BoxHeight > boxRadius) boxRadius = BoxHeight;
    if (BoxDepth > boxRadius) boxRadius = BoxDepth;
    float innerRadius = boxRadius * StarInnerRadiusScale;
    float cameraGuard = cameraDistance * 1.05;
    if (cameraGuard > innerRadius) innerRadius = cameraGuard;
    float outerRadius = boxRadius * StarOuterRadiusScale;
    if (outerRadius < innerRadius + 1.0) outerRadius = innerRadius + 1.0;

    float lightConstX = LightDirX;
    float lightConstY = LightDirY;
    float lightConstZ = LightDirZ;
    float lightDirLength = sqrt(lightConstX * lightConstX + lightConstY * lightConstY + lightConstZ * lightConstZ);
    if (lightDirLength < 0.00001) lightDirLength = 1.0;
    float highlightDistance = innerRadius + 0.78 * (outerRadius - innerRadius);
    float highlightScale = highlightDistance / lightDirLength;
    my.starX[0] = 0.0 - lightConstX * highlightScale;
    my.starY[0] = 0.0 - lightConstY * highlightScale;
    my.starZ[0] = 0.0 - lightConstZ * highlightScale;
    my.starSize[0] = LightStarSize;
    my.starBaseBrightness[0] = LightStarBrightness;
    my.starTwinkleRate[0] = LightStarTwinkleRate;
    my.starPhase[0] = 0.0;
    i = 1;
    while (i < NumStars) {
      float cosTheta = 2.0 * randomUnit() - 1.0;
      if (cosTheta > 1.0) cosTheta = 1.0;
      if (cosTheta < -1.0) cosTheta = -1.0;
      float sinSq = 1.0 - cosTheta * cosTheta;
      if (sinSq < 0.0) sinSq = 0.0;
      float sinTheta = sqrt(sinSq);
      float phi = randomUnit() * 2.0 * Pi;
      float dirX = sinTheta * cos(phi);
      float dirY = sinTheta * sin(phi);
      float dirZ = cosTheta;
      float distance = innerRadius + randomUnit() * (outerRadius - innerRadius);
      my.starX[i] = dirX * distance;
      my.starY[i] = dirY * distance;
      my.starZ[i] = dirZ * distance;
      my.starSize[i] = 6.0 + randomUnit() * 6.0;
      my.starBaseBrightness[i] = 0.45 + randomUnit() * 0.45;
      my.starTwinkleRate[i] = 0.8 + randomUnit() * 1.6;
      my.starPhase[i] = randomUnit() * 2.0 * Pi;
      i = i + 1;
    }
  }

  void draw(float elapsedSeconds) {
    float time = elapsedSeconds;
    GLDisable("lighting");
    GLDepthTest(false);
    GLEnable("blend");
    GLBlendFunc("src_alpha", "one");
    GLBegin("lines");
      int i = 0;
      while (i < NumStars) {
        float sparklePhase = my.starPhase[i] + time * my.starTwinkleRate[i];
        float sparkle = 0.55 + 0.45 * sin(sparklePhase);
        if (sparkle < 0.0) sparkle = 0.0;
        float brightness = my.starBaseBrightness[i] * sparkle;
        float alpha = 0.35 + 0.45 * sparkle;
        if (alpha > 1.0) alpha = 1.0;
        float size = my.starSize[i];
        float depthSize = size * 0.6;
        GLColor4f(brightness, brightness, brightness + 0.10, alpha);
        GLVertex3f(my.starX[i] - size, my.starY[i], my.starZ[i]);
        GLVertex3f(my.starX[i] + size, my.starY[i], my.starZ[i]);
        GLVertex3f(my.starX[i], my.starY[i] - size, my.starZ[i]);
        GLVertex3f(my.starX[i], my.starY[i] + size, my.starZ[i]);
        GLVertex3f(my.starX[i], my.starY[i], my.starZ[i] - depthSize);
        GLVertex3f(my.starX[i], my.starY[i], my.starZ[i] + depthSize);
        i = i + 1;
      }
    GLEnd();
    GLBlendFunc("src_alpha", "one_minus_src_alpha");
    GLDisable("blend");
    GLDepthTest(true);
    GLEnable("lighting");
  }
}

class BouncingBalls3DApp {
  BallField balls;
  StarField stars;
  Camera camera;
  bool quit;
  bool paused;
  int FrameDelay;
  float DeltaTime;
  float elapsedSeconds;
  float minSpeed;
  float maxSpeed;
  int windowWidthPx;
  int windowHeightPx;
  bool glassBalls;
 
  BouncingBalls3DApp() {
    my.balls = new BallField();
    my.stars = new StarField();
    my.camera = new Camera(0.0, InitialCameraPitch, InitialCameraDistance);
    my.glassBalls = false;

    int screenWidth = WindowWidth;
    int screenHeight = WindowHeight;
    if (getscreensize(screenWidth, screenHeight)) {
      if (screenWidth < MinWindowWidth) screenWidth = MinWindowWidth;
      if (screenHeight < MinWindowHeight) screenHeight = MinWindowHeight;
      screenWidth = screenWidth - WindowMarginX;
      screenHeight = screenHeight - WindowMarginY;
      if (screenWidth < MinWindowWidth) screenWidth = MinWindowWidth;
      if (screenHeight < MinWindowHeight) screenHeight = MinWindowHeight;
    } else {
      screenWidth = WindowWidth;
      screenHeight = WindowHeight;
    }

    int windowWidthPx = screenWidth;
    int windowHeightPx = screenHeight;

    my.windowWidthPx = windowWidthPx;
    my.windowHeightPx = windowHeightPx;

    InitGraph3D(my.windowWidthPx, my.windowHeightPx, "Rea Multi Bouncing Balls 3D", 24, 8);
    bool gpuAccelerated = GLIsHardwareAccelerated();
    if (gpuAccelerated) {
      writeln("OpenGL acceleration: hardware (GPU).");
    } else {
      writeln("OpenGL acceleration: software fallback.");
    }
    GLViewport(0, 0, my.windowWidthPx, my.windowHeightPx);
    GLSetSwapInterval(1);
    my.setupLighting();

    my.FrameDelay = trunc(1000 / TargetFPS);
    my.DeltaTime = 1.0 / TargetFPS;

    my.minSpeed = MinInitialSpeed;
    my.maxSpeed = MaxInitialSpeed;

    float cameraDistance = my.camera.distance;
    float fpsBoost = 1.6;
    float speedBoost = 2.3;
    float cameraPull = 0.7;
    BouncingBalls3DAccelerate(TargetFPS, my.FrameDelay, my.DeltaTime,
      my.minSpeed, my.maxSpeed, cameraDistance,
      fpsBoost, speedBoost, cameraPull);
    my.camera.distance = cameraDistance;

    randomize();
    my.balls.init(my.minSpeed, my.maxSpeed);
    my.balls.setGlassMode(my.glassBalls);
    my.stars.init(my.camera.distance);

    my.quit = false;
    my.paused = false;
    my.elapsedSeconds = 0.0;
  }

  void setupLighting() {
    GLClearDepth(1.0);
    GLDepthTest(true);
    GLEnable("lighting");
    GLEnable("light0");
    GLEnable("color_material");
    GLEnable("normalize");

    GLShadeModel("smooth");
    GLColorMaterial("front", "ambient_and_diffuse");

    float ambient = AmbientLevel;
    GLLightfv("light0", "ambient", ambient, ambient, ambient, 1.0);
    GLLightfv("light0", "diffuse", 0.90, 0.92, 0.95, 1.0);
    GLLightfv("light0", "specular", 0.85, 0.90, 0.95, 1.0);

    GLMaterialfv("front", "specular", 0.55, 0.60, 0.70, 1.0);
    GLMaterialf("front", "shininess", 42.0);
  }

  void drawGlassBox() {
    float halfWidth = BoxWidth * 0.5;
    float halfHeight = BoxHeight * 0.5;
    float frontZ = -12.0;
    float backZ = -BoxDepth;
    float floorBackZ = backZ + 1.0;

    GLDisable("lighting");
    GLEnable("blend");
    GLBlendFunc("src_alpha", "one_minus_src_alpha");

    GLColor4f(0.08, 0.12, 0.20, 1.00);
    GLBegin("quads");
      GLVertex3f(-halfWidth, -halfHeight, frontZ);
      GLVertex3f(halfWidth, -halfHeight, frontZ);
      GLVertex3f(halfWidth, -halfHeight, floorBackZ);
      GLVertex3f(-halfWidth, -halfHeight, floorBackZ);
    GLEnd();

    int gridSteps = 12;
    int i = 0;
    GLColor4f(0.18, 0.26, 0.38, 0.30);
    GLBegin("lines");
      while (i <= gridSteps) {
        float t = (i * 1.0) / gridSteps;
        float x = -halfWidth + t * BoxWidth;
        GLVertex3f(x, -halfHeight + 0.2, frontZ);
        GLVertex3f(x, -halfHeight + 0.2, floorBackZ);
        float z = frontZ + t * (floorBackZ - frontZ);
        GLVertex3f(-halfWidth, -halfHeight + 0.2, z);
        GLVertex3f(halfWidth, -halfHeight + 0.2, z);
        i = i + 1;
      }
    GLEnd();

    GLDisable("blend");
    GLColor3f(0.32, 0.46, 0.66);

    GLBegin("line_loop");
      GLVertex3f(-halfWidth, halfHeight, frontZ);
      GLVertex3f(halfWidth, halfHeight, frontZ);
      GLVertex3f(halfWidth, -halfHeight, frontZ);
      GLVertex3f(-halfWidth, -halfHeight, frontZ);
    GLEnd();

    GLBegin("line_loop");
      GLVertex3f(-halfWidth, halfHeight, backZ);
      GLVertex3f(halfWidth, halfHeight, backZ);
      GLVertex3f(halfWidth, -halfHeight, backZ);
      GLVertex3f(-halfWidth, -halfHeight, backZ);
    GLEnd();

    GLBegin("lines");
      GLVertex3f(-halfWidth, halfHeight, frontZ);
      GLVertex3f(-halfWidth, halfHeight, backZ);
      GLVertex3f(halfWidth, halfHeight, frontZ);
      GLVertex3f(halfWidth, halfHeight, backZ);
      GLVertex3f(halfWidth, -halfHeight, frontZ);
      GLVertex3f(halfWidth, -halfHeight, backZ);
      GLVertex3f(-halfWidth, -halfHeight, frontZ);
      GLVertex3f(-halfWidth, -halfHeight, backZ);
    GLEnd();

    GLEnable("blend");
    GLColor4f(0.12, 0.18, 0.26, 0.26);
    GLBegin("quads");
      GLVertex3f(-halfWidth, halfHeight, backZ);
      GLVertex3f(halfWidth, halfHeight, backZ);
      GLVertex3f(halfWidth, -halfHeight, backZ);
      GLVertex3f(-halfWidth, -halfHeight, backZ);
    GLEnd();

    GLDisable("blend");
    GLEnable("lighting");
  }

  void drawScene() {
    GLClearColor(0.05, 0.07, 0.12, 1.0);
    GLClear();

    GLMatrixMode("projection");
    GLLoadIdentity();
    float aspect = my.windowWidthPx * 1.0 / my.windowHeightPx;
    GLPerspective(55.0, aspect, 24.0, 8000.0);

    GLMatrixMode("modelview");
    GLLoadIdentity();
    my.camera.applyTransform();

    GLLightfv("light0", "position", LightDirX, LightDirY, LightDirZ, 0.0);

    my.stars.draw(my.elapsedSeconds);
    my.balls.draw();
    my.drawGlassBox();

    GLSwapWindow();
  }

  void updateSimulation() {
    if (my.paused) return;
    my.balls.update(my.DeltaTime, my.minSpeed, my.maxSpeed, my.camera.distance);
    my.elapsedSeconds = my.elapsedSeconds + my.DeltaTime;
    my.camera.update(my.DeltaTime);
  }

  void handleInput() {
    my.camera.handleInput(my.DeltaTime);

    int keyCode = pollkeyany();
    while (keyCode != 0) {
      if (keyCode >= 0 && keyCode <= 255) {
        int ascii = keyCode;
        if (ascii == 'q' || ascii == 'Q') {
          my.quit = true;
        } else if (ascii == ' ') {
          my.paused = !my.paused;
        } else if (ascii == 'g' || ascii == 'G') {
          my.glassBalls = !my.glassBalls;
          my.balls.setGlassMode(my.glassBalls);
          if (my.glassBalls) {
            writeln("Glass mode enabled.");
          } else {
            writeln("Glass mode disabled.");
          }
        }
      }
      keyCode = pollkeyany();
    }
  }

  void run() {
    writeln("Multi Bouncing Balls 3D (OpenGL) ... Press Q to quit, Space to pause, W/S to move, G for glass mode.");
    while (!my.quit) {
      if (QuitRequested()) {
        my.quit = true;
        break;
      }
      my.handleInput();
      my.updateSimulation();
      my.drawScene();
      GraphLoop(my.FrameDelay);
    }
    CloseGraph3D();
    writeln("Demo finished.");
  }
}

BouncingBalls3DApp app = new BouncingBalls3DApp();
app.run();
