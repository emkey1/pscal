// SDL Multi Bouncing Balls demo ported to Rea using classes.
// Requires building Pscal with SDL support.

class Ball {
  float x;
  float y;
  float dx;
  float dy;
  float mass;
  int radius;
  int r;
  int g;
  int b;
  bool active;

  Ball init(int w, int h, float minSpeed, float maxSpeed) {
    my.radius = 8 + random(13);
    my.x = my.radius + random(w - 2 * my.radius);
    my.y = my.radius + random(h - 2 * my.radius);
    int speedRange = trunc(maxSpeed - minSpeed + 1);
    float speed = minSpeed + random(speedRange);
    float angle = random(360) * (3.14159265 / 180.0);
    my.dx = cos(angle) * speed / 60.0;
    my.dy = sin(angle) * speed / 60.0;
    if ((abs(my.dx) < 0.1) && (abs(my.dy) < 0.1)) {
      my.dx = (minSpeed / 60.0) * 0.707;
      my.dy = (minSpeed / 60.0) * 0.707;
    }
    my.r = random(206) + 50;
    my.g = random(206) + 50;
    my.b = random(206) + 50;
    my.mass = my.radius * my.radius;
    my.active = true;
    return my;
  }

  void move(int maxX, int maxY) {
    my.x = my.x + my.dx;
    my.y = my.y + my.dy;
    if ((my.x - my.radius) < 0) {
      my.x = my.radius;
      my.dx = -my.dx;
    } else if ((my.x + my.radius) > maxX) {
      my.x = maxX - my.radius;
      my.dx = -my.dx;
    }
    if ((my.y - my.radius) < 0) {
      my.y = my.radius;
      my.dy = -my.dy;
    } else if ((my.y + my.radius) > maxY) {
      my.y = maxY - my.radius;
      my.dy = -my.dy;
    }
  }

  void draw() {
    setrgbcolor(my.r, my.g, my.b);
    fillcircle(trunc(my.x), trunc(my.y), my.radius);
  }
}

class BallsApp {
  const int WindowWidth = 1280;
  const int WindowHeight = 1024;
  const int TargetFPS = 60;
  const int NumBalls = 90;
  const float MaxInitialSpeed = 250.0;
  const float MinInitialSpeed = 80.0;

  // Frame delay in milliseconds for the desired frame rate.
  int FrameDelay;
  Ball balls[NumBalls + 1];
  int maxX;
  int maxY;
  bool quit;

  void init() {
    initgraph(WindowWidth, WindowHeight, "Multi Bouncing Balls in Rea");
    randomize();
    my.maxX = getmaxx();
    my.maxY = getmaxy();
    my.FrameDelay = trunc(1000 / TargetFPS);
    int i = 1;
    while (i <= NumBalls) {
      Ball b = new Ball();
      my.balls[i] = b.init(WindowWidth, WindowHeight, MinInitialSpeed, MaxInitialSpeed);
      i = i + 1;
    }
    my.quit = false;
  }

  void handleCollisions() {
    int i = 1;
    while (i <= NumBalls) {
      if (my.balls[i].active) {
        int j = i + 1;
        while (j <= NumBalls) {
          if (my.balls[j].active) {
            float distSq = (my.balls[i].x - my.balls[j].x) * (my.balls[i].x - my.balls[j].x) +
                           (my.balls[i].y - my.balls[j].y) * (my.balls[i].y - my.balls[j].y);
            float sumR = my.balls[i].radius + my.balls[j].radius;
            float sumR2 = sumR * sumR;
            if (distSq <= sumR2) {
              float dist = sqrt(distSq);
              if (dist == 0.0) dist = 0.001;
              float nx = (my.balls[j].x - my.balls[i].x) / dist;
              float ny = (my.balls[j].y - my.balls[i].y) / dist;
              float tx = -ny;
              float ty = nx;
              float v1x = my.balls[i].dx;
              float v1y = my.balls[i].dy;
              float v2x = my.balls[j].dx;
              float v2y = my.balls[j].dy;
              float v1n = v1x * nx + v1y * ny;
              float v1t = v1x * tx + v1y * ty;
              float v2n = v2x * nx + v2y * ny;
              float v2t = v2x * tx + v2y * ty;
              float m1 = my.balls[i].mass;
              float m2 = my.balls[j].mass;
              float new_v1n = (v1n * (m1 - m2) + 2 * m2 * v2n) / (m1 + m2);
              float new_v2n = (v2n * (m2 - m1) + 2 * m1 * v1n) / (m1 + m2);
              my.balls[i].dx = new_v1n * nx + v1t * tx;
              my.balls[i].dy = new_v1n * ny + v1t * ty;
              my.balls[j].dx = new_v2n * nx + v2t * tx;
              my.balls[j].dy = new_v2n * ny + v2t * ty;
              float overlap = sumR - dist;
              if (overlap > 0.0) {
                my.balls[i].x = my.balls[i].x - (overlap / 2.0) * nx;
                my.balls[i].y = my.balls[i].y - (overlap / 2.0) * ny;
                my.balls[j].x = my.balls[j].x + (overlap / 2.0) * nx;
                my.balls[j].y = my.balls[j].y + (overlap / 2.0) * ny;
              }
            }
          }
          j = j + 1;
        }
      }
      i = i + 1;
    }
  }

  void update() {
    int i = 1;
    while (i <= NumBalls) {
      if (my.balls[i].active) my.balls[i].move(my.maxX, my.maxY);
      i = i + 1;
    }
    my.handleCollisions();
  }

  void draw() {
    cleardevice();
    int i = 1;
    while (i <= NumBalls) {
      if (my.balls[i].active) my.balls[i].draw();
      i = i + 1;
    }
    updatescreen();
  }

  void run() {
    my.init();
    writeln("Multi Bouncing Balls... Press Q to quit.");
    while (!my.quit) {
      if (keypressed()) {
        char c = readkey();
        if (toupper(c) == 'Q') my.quit = true;
      }
      my.update();
      my.draw();
      graphloop(my.FrameDelay);
    }
    closegraph();
    writeln("Demo finished.");
  }
}

BallsApp app = new BallsApp();
BallsApp_run(app);

