// SDL Multi Bouncing Balls demo ported to Rea using classes.
// Requires building Pscal with SDL support.

const int NumBalls = 90;

class Ball {
  float x;
  float y;
  float dx;
  float dy;
  float mass;
  int radius;
  int r;
  int g;
  int b;
  bool active;

  void init(int w, int h, float minSpeed, float maxSpeed) {
    this.radius = 8 + random(13);
    this.x = this.radius + random(w - 2 * this.radius);
    this.y = this.radius + random(h - 2 * this.radius);
    int speedRange = trunc(maxSpeed - minSpeed + 1);
    float speed = minSpeed + random(speedRange);
    float angle = random(360) * (3.14159265 / 180.0);
    this.dx = cos(angle) * speed / 60.0;
    this.dy = sin(angle) * speed / 60.0;
    if ((abs(this.dx) < 0.1) && (abs(this.dy) < 0.1)) {
      this.dx = (minSpeed / 60.0) * 0.707;
      this.dy = (minSpeed / 60.0) * 0.707;
    }
    this.r = random(206) + 50;
    this.g = random(206) + 50;
    this.b = random(206) + 50;
    this.mass = this.radius * this.radius;
    this.active = true;
  }

  void move(int maxX, int maxY) {
    this.x = this.x + this.dx;
    this.y = this.y + this.dy;
    if ((this.x - this.radius) < 0) {
      this.x = this.radius;
      this.dx = -this.dx;
    } else if ((this.x + this.radius) > maxX) {
      this.x = maxX - this.radius;
      this.dx = -this.dx;
    }
    if ((this.y - this.radius) < 0) {
      this.y = this.radius;
      this.dy = -this.dy;
    } else if ((this.y + this.radius) > maxY) {
      this.y = maxY - this.radius;
      this.dy = -this.dy;
    }
  }

  void draw() {
    setrgbcolor(this.r, this.g, this.b);
    fillcircle(trunc(this.x), trunc(this.y), this.radius);
  }
}

Ball balls[NumBalls + 1];

class BallsApp {
  const int WindowWidth = 1280;
  const int WindowHeight = 1024;
  const int TargetFPS = 60;
  const int FrameDelay = trunc(1000 / TargetFPS);
  const float MaxInitialSpeed = 250.0;
  const float MinInitialSpeed = 80.0;
  int maxX;
  int maxY;
  bool quitRequested = false;

  void init() {
    initgraph(WindowWidth, WindowHeight, "Multi Bouncing Balls in Rea");
    randomize();
    this.maxX = getmaxx();
    this.maxY = getmaxy();
    int i = 1;
    while (i <= NumBalls) {
      balls[i] = new Ball();
      Ball_init(balls[i], WindowWidth, WindowHeight, MinInitialSpeed, MaxInitialSpeed);
      i = i + 1;
    }
  }

  void handleCollisions() {
    int i = 1;
    while (i <= NumBalls) {
      if (balls[i].active) {
        int j = i + 1;
        while (j <= NumBalls) {
          if (balls[j].active) {
            float distSq = (balls[i].x - balls[j].x) * (balls[i].x - balls[j].x) +
                           (balls[i].y - balls[j].y) * (balls[i].y - balls[j].y);
            float sumR = balls[i].radius + balls[j].radius;
            float sumR2 = sumR * sumR;
            if (distSq <= sumR2) {
              float dist = sqrt(distSq);
              if (dist == 0.0) dist = 0.001;
              float nx = (balls[j].x - balls[i].x) / dist;
              float ny = (balls[j].y - balls[i].y) / dist;
              float tx = -ny;
              float ty = nx;
              float v1x = balls[i].dx;
              float v1y = balls[i].dy;
              float v2x = balls[j].dx;
              float v2y = balls[j].dy;
              float v1n = v1x * nx + v1y * ny;
              float v1t = v1x * tx + v1y * ty;
              float v2n = v2x * nx + v2y * ny;
              float v2t = v2x * tx + v2y * ty;
              float m1 = balls[i].mass;
              float m2 = balls[j].mass;
              float new_v1n = (v1n * (m1 - m2) + 2 * m2 * v2n) / (m1 + m2);
              float new_v2n = (v2n * (m2 - m1) + 2 * m1 * v1n) / (m1 + m2);
              balls[i].dx = new_v1n * nx + v1t * tx;
              balls[i].dy = new_v1n * ny + v1t * ty;
              balls[j].dx = new_v2n * nx + v2t * tx;
              balls[j].dy = new_v2n * ny + v2t * ty;
              float overlap = sumR - dist;
              if (overlap > 0.0) {
                balls[i].x = balls[i].x - (overlap / 2.0) * nx;
                balls[i].y = balls[i].y - (overlap / 2.0) * ny;
                balls[j].x = balls[j].x + (overlap / 2.0) * nx;
                balls[j].y = balls[j].y + (overlap / 2.0) * ny;
              }
            }
          }
          j = j + 1;
        }
      }
      i = i + 1;
    }
  }

  void update() {
    int i = 1;
    while (i <= NumBalls) {
      if (balls[i].active) Ball_move(balls[i], this.maxX, this.maxY);
      i = i + 1;
    }
    this.handleCollisions();
  }

  void draw() {
    cleardevice();
    int i = 1;
    while (i <= NumBalls) {
      if (balls[i].active) Ball_draw(balls[i]);
      i = i + 1;
    }
    updatescreen();
  }

  void run() {
    this.init();
    write("Multi Bouncing Balls... Press Q to quit.\n");
    while (!this.quitRequested) {
      if (keypressed()) {
        char c = readkey();
        if (toupper(c) == 'Q') this.quitRequested = true;
      }
      this.update();
      this.draw();
      graphloop(FrameDelay);
    }
    closegraph();
    write("Demo finished.\n");
  }
}

BallsApp app = new BallsApp();
app.run();
