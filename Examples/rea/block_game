#!/usr/bin/env rea
// Uses SDL for graphics and input handling

const int BoardWidth = 10;
const int BoardHeight = 20;
const int CellSize = 30;

const int TetrominoCount = 7;
const int RotationCount = 4;
const int BlocksPerPiece = 4;

int TetrominoOffsets[TetrominoCount][RotationCount][BlocksPerPiece * 2];
int TetrominoColorR[TetrominoCount];
int TetrominoColorG[TetrominoCount];
int TetrominoColorB[TetrominoCount];
bool TetrominoDataInitialized = false;

void initializeTetrominoData() {
    if (TetrominoDataInitialized) {
        return;
    }
    TetrominoDataInitialized = true;

    TetrominoColorR[0] = 0;   TetrominoColorG[0] = 255; TetrominoColorB[0] = 255; // I - Cyan
    TetrominoColorR[1] = 255; TetrominoColorG[1] = 255; TetrominoColorB[1] = 0;   // O - Yellow
    TetrominoColorR[2] = 128; TetrominoColorG[2] = 0;   TetrominoColorB[2] = 128; // T - Purple
    TetrominoColorR[3] = 0;   TetrominoColorG[3] = 255; TetrominoColorB[3] = 0;   // S - Green
    TetrominoColorR[4] = 255; TetrominoColorG[4] = 0;   TetrominoColorB[4] = 0;   // Z - Red
    TetrominoColorR[5] = 0;   TetrominoColorG[5] = 0;   TetrominoColorB[5] = 255; // J - Blue
    TetrominoColorR[6] = 255; TetrominoColorG[6] = 165; TetrominoColorB[6] = 0;   // L - Orange

    int baseOffsets[TetrominoCount][BlocksPerPiece * 2];

    // I piece (horizontal)
    baseOffsets[0][0] = 0; baseOffsets[0][1] = 1;
    baseOffsets[0][2] = 1; baseOffsets[0][3] = 1;
    baseOffsets[0][4] = 2; baseOffsets[0][5] = 1;
    baseOffsets[0][6] = 3; baseOffsets[0][7] = 1;

    // O piece
    baseOffsets[1][0] = 1; baseOffsets[1][1] = 0;
    baseOffsets[1][2] = 2; baseOffsets[1][3] = 0;
    baseOffsets[1][4] = 1; baseOffsets[1][5] = 1;
    baseOffsets[1][6] = 2; baseOffsets[1][7] = 1;

    // T piece
    baseOffsets[2][0] = 1; baseOffsets[2][1] = 0;
    baseOffsets[2][2] = 0; baseOffsets[2][3] = 1;
    baseOffsets[2][4] = 1; baseOffsets[2][5] = 1;
    baseOffsets[2][6] = 2; baseOffsets[2][7] = 1;

    // S piece
    baseOffsets[3][0] = 1; baseOffsets[3][1] = 0;
    baseOffsets[3][2] = 2; baseOffsets[3][3] = 0;
    baseOffsets[3][4] = 0; baseOffsets[3][5] = 1;
    baseOffsets[3][6] = 1; baseOffsets[3][7] = 1;

    // Z piece
    baseOffsets[4][0] = 0; baseOffsets[4][1] = 0;
    baseOffsets[4][2] = 1; baseOffsets[4][3] = 0;
    baseOffsets[4][4] = 1; baseOffsets[4][5] = 1;
    baseOffsets[4][6] = 2; baseOffsets[4][7] = 1;

    // J piece
    baseOffsets[5][0] = 0; baseOffsets[5][1] = 0;
    baseOffsets[5][2] = 0; baseOffsets[5][3] = 1;
    baseOffsets[5][4] = 1; baseOffsets[5][5] = 1;
    baseOffsets[5][6] = 2; baseOffsets[5][7] = 1;

    // L piece
    baseOffsets[6][0] = 2; baseOffsets[6][1] = 0;
    baseOffsets[6][2] = 0; baseOffsets[6][3] = 1;
    baseOffsets[6][4] = 1; baseOffsets[6][5] = 1;
    baseOffsets[6][6] = 2; baseOffsets[6][7] = 1;

    int shape;
    for (shape = 0; shape < TetrominoCount; shape = shape + 1) {
        int block;
        for (block = 0; block < BlocksPerPiece; block = block + 1) {
            int baseX = baseOffsets[shape][block * 2];
            int baseY = baseOffsets[shape][block * 2 + 1];

            // Rotation 0 (spawn)
            TetrominoOffsets[shape][0][block * 2] = baseX;
            TetrominoOffsets[shape][0][block * 2 + 1] = baseY;

            // Rotation 1 (90 degrees clockwise)
            TetrominoOffsets[shape][1][block * 2] = 3 - baseY;
            TetrominoOffsets[shape][1][block * 2 + 1] = baseX;

            // Rotation 2 (180 degrees)
            TetrominoOffsets[shape][2][block * 2] = 3 - baseX;
            TetrominoOffsets[shape][2][block * 2 + 1] = 3 - baseY;

            // Rotation 3 (270 degrees)
            TetrominoOffsets[shape][3][block * 2] = baseY;
            TetrominoOffsets[shape][3][block * 2 + 1] = 3 - baseX;
        }

        int rotation;
        for (rotation = 0; rotation < RotationCount; rotation = rotation + 1) {
            int minX = TetrominoOffsets[shape][rotation][0];
            int minY = TetrominoOffsets[shape][rotation][1];
            for (block = 0; block < BlocksPerPiece; block = block + 1) {
                int idx = block * 2;
                if (TetrominoOffsets[shape][rotation][idx] < minX) {
                    minX = TetrominoOffsets[shape][rotation][idx];
                }
                if (TetrominoOffsets[shape][rotation][idx + 1] < minY) {
                    minY = TetrominoOffsets[shape][rotation][idx + 1];
                }
            }
            for (block = 0; block < BlocksPerPiece; block = block + 1) {
                int idx = block * 2;
                TetrominoOffsets[shape][rotation][idx] = TetrominoOffsets[shape][rotation][idx] - minX;
                TetrominoOffsets[shape][rotation][idx + 1] = TetrominoOffsets[shape][rotation][idx + 1] - minY;
            }
        }
    }
}

class Board {
    int grid[BoardWidth * BoardHeight];
    int score;
    int level;
    int lines;
    
    void Board() {
        myself.score = 0;
        myself.level = 1;
        myself.lines = 0;
        int i;
        for (i = 0; i < BoardWidth * BoardHeight; i = i + 1) {
            myself.grid[i] = 0;
        }
    }
    
    bool isValidPosition(int x, int y) {
        return (x >= 0 && x < BoardWidth && y >= 0 && y < BoardHeight);
    }
    
    bool isCollision(int x, int y, int shapeIndex, int rotation) {
        int block;
        for (block = 0; block < BlocksPerPiece; block = block + 1) {
            int offsetX = TetrominoOffsets[shapeIndex][rotation][block * 2];
            int offsetY = TetrominoOffsets[shapeIndex][rotation][block * 2 + 1];
            int newX = x + offsetX;
            int newY = y + offsetY;

            if (newX < 0 || newX >= BoardWidth) {
                return true;
            }
            if (newY >= BoardHeight) {
                return true;
            }
            if (newY >= 0 && myself.grid[newY * BoardWidth + newX] != 0) {
                return true;
            }
        }
        return false;
    }

    bool placePiece(int x, int y, int shapeIndex, int rotation, int color) {
        bool lockedOut = false;
        int block;
        for (block = 0; block < BlocksPerPiece; block = block + 1) {
            int offsetX = TetrominoOffsets[shapeIndex][rotation][block * 2];
            int offsetY = TetrominoOffsets[shapeIndex][rotation][block * 2 + 1];
            int newX = x + offsetX;
            int newY = y + offsetY;
            if (newY < 0) {
                lockedOut = true;
            } else if (newY < BoardHeight && newX >= 0 && newX < BoardWidth) {
                myself.grid[newY * BoardWidth + newX] = color;
            }
        }
        return lockedOut;
    }
    
    void clearLines() {
        int linesCleared = 0;
        int i, j, k;

        for (i = BoardHeight - 1; i >= 0; i = i - 1) {
            bool fullLine = true;
            for (j = 0; j < BoardWidth; j = j + 1) {
                if (myself.grid[i * BoardWidth + j] == 0) {
                    fullLine = false;
                    break;
                }
            }
            
            if (fullLine) {
                linesCleared = linesCleared + 1;
                // Shift all lines above down
                for (k = i; k > 0; k = k - 1) {
                    for (j = 0; j < BoardWidth; j = j + 1) {
                        myself.grid[k * BoardWidth + j] = myself.grid[(k - 1) * BoardWidth + j];
                    }
                }
                // Clear top line
                for (j = 0; j < BoardWidth; j = j + 1) {
                    myself.grid[j] = 0;
                }
                i = i + 1; // Check same row again
            }
        }
        
        if (linesCleared > 0) {
            myself.lines = myself.lines + linesCleared;
            myself.score = myself.score + linesCleared * 100 * myself.level;
            if (myself.lines >= myself.level * 10) {
                myself.level = myself.level + 1;
            }
        }
    }
    
    void draw(int offsetX, int offsetY) {
        int i, j;
        for (i = 0; i < BoardHeight; i = i + 1) {
            for (j = 0; j < BoardWidth; j = j + 1) {
                int value = myself.grid[i * BoardWidth + j];
                if (value != 0) {
                    int r = value % 256;
                    int g = int(value / 256) % 256;
                    int b = int(value / 65536);
                    setrgbcolor(r, g, b);
                    int cellLeft = offsetX + j * CellSize;
                    int cellTop = offsetY + i * CellSize;
                    int cellRight = cellLeft + CellSize - 1;
                    int cellBottom = cellTop + CellSize - 1;
                    fillrect(cellLeft, cellTop, cellRight, cellBottom);
                }
            }
        }
    }
    
    int getScore() { return myself.score; }
    int getLevel() { return myself.level; }
    int getLines() { return myself.lines; }
}

class Game {
    const int BoardX = 50;
    const int BoardY = 20;
    const int WindowWidth = 420;
    const int WindowHeight = BoardY + BoardHeight * CellSize + 60;
    
    Board board;
    int currentShapeIndex;
    int currentRotation;
    int currentColor;
    int currentX;
    int currentY;
    int nextShapeIndex;
    bool gameOver;
    int frameDelay;
    float dropTime;
    float lastDrop;
    
    void Game() {
        initializeTetrominoData();
        myself.board = new Board();
        myself.gameOver = false;
        myself.frameDelay = 1000 / 60; // ~60 FPS
        myself.dropTime = 0.5; // seconds per drop
        myself.lastDrop = 0.0;
        myself.currentX = BoardWidth / 2 - 2;
        myself.currentY = -2;
        myself.currentShapeIndex = 0;
        myself.currentRotation = 0;
        myself.nextShapeIndex = random(TetrominoCount);
        myself.spawnPiece();
    }
    
    void spawnPiece() {
        myself.currentShapeIndex = myself.nextShapeIndex;
        myself.currentRotation = 0;
        myself.currentColor = TetrominoColorR[myself.currentShapeIndex] +
                              TetrominoColorG[myself.currentShapeIndex] * 256 +
                              TetrominoColorB[myself.currentShapeIndex] * 65536;
        myself.nextShapeIndex = random(TetrominoCount);
        myself.currentX = BoardWidth / 2 - 2;
        myself.currentY = -2;

        if (myself.board.isCollision(myself.currentX, myself.currentY,
                                     myself.currentShapeIndex, myself.currentRotation)) {
            myself.gameOver = true;
        }
    }

    void movePiece(int dx, int dy) {
        if (!myself.gameOver &&
            !myself.board.isCollision(myself.currentX + dx, myself.currentY + dy,
                                      myself.currentShapeIndex, myself.currentRotation)) {
            myself.currentX = myself.currentX + dx;
            myself.currentY = myself.currentY + dy;
        }
    }

    void rotatePiece() {
        if (!myself.gameOver) {
            int newRotation = (myself.currentRotation + 1) % RotationCount;
            if (!myself.board.isCollision(myself.currentX, myself.currentY,
                                          myself.currentShapeIndex, newRotation)) {
                myself.currentRotation = newRotation;
            } else if (!myself.board.isCollision(myself.currentX - 1, myself.currentY,
                                                 myself.currentShapeIndex, newRotation)) {
                myself.currentX = myself.currentX - 1;
                myself.currentRotation = newRotation;
            } else if (!myself.board.isCollision(myself.currentX + 1, myself.currentY,
                                                 myself.currentShapeIndex, newRotation)) {
                myself.currentX = myself.currentX + 1;
                myself.currentRotation = newRotation;
            }
        }
    }
    
    void hardDrop() {
        if (!myself.gameOver) {
            while (!myself.board.isCollision(myself.currentX, myself.currentY + 1,
                                             myself.currentShapeIndex, myself.currentRotation)) {
                myself.currentY = myself.currentY + 1;
            }
            myself.lockPiece();
        }
    }

    void lockPiece() {
        bool lockedOut = myself.board.placePiece(myself.currentX, myself.currentY,
                                                myself.currentShapeIndex, myself.currentRotation,
                                                myself.currentColor);
        myself.board.clearLines();
        if (lockedOut) {
            myself.gameOver = true;
        } else {
            myself.spawnPiece();
        }
    }

    void update(float deltaTime) {
        if (myself.gameOver) return;

        myself.lastDrop = myself.lastDrop + deltaTime;
        if (myself.lastDrop >= myself.dropTime) {
            if (!myself.board.isCollision(myself.currentX, myself.currentY + 1,
                                          myself.currentShapeIndex, myself.currentRotation)) {
                myself.currentY = myself.currentY + 1;
            } else {
                myself.lockPiece();
            }
            myself.lastDrop = 0.0;
        }
    }
    
    void draw() {
        cleardevice();
        
        // Draw board background
        setrgbcolor(30, 30, 30);
        int boardRight = BoardX + BoardWidth * CellSize + 5;
        int boardBottom = BoardY + BoardHeight * CellSize + 5;
        fillrect(BoardX - 5, BoardY - 5, boardRight, boardBottom);
        
        // Draw grid lines
        setrgbcolor(60, 60, 60);
        int i;
        for (i = 0; i <= BoardWidth; i = i + 1) {
            drawline(BoardX + i * CellSize, BoardY, BoardX + i * CellSize, BoardY + BoardHeight * CellSize);
        }
        for (i = 0; i <= BoardHeight; i = i + 1) {
            drawline(BoardX, BoardY + i * CellSize, BoardX + BoardWidth * CellSize, BoardY + i * CellSize);
        }
        
        // Draw placed pieces
        myself.board.draw(BoardX, BoardY);
        
        // Draw current piece
        if (!myself.gameOver) {
            int block;
            int currentR = myself.currentColor % 256;
            int currentG = int(myself.currentColor / 256) % 256;
            int currentB = int(myself.currentColor / 65536);
            setrgbcolor(currentR, currentG, currentB);
            for (block = 0; block < BlocksPerPiece; block = block + 1) {
                int offsetX = TetrominoOffsets[myself.currentShapeIndex][myself.currentRotation][block * 2];
                int offsetY = TetrominoOffsets[myself.currentShapeIndex][myself.currentRotation][block * 2 + 1];
                int drawX = myself.currentX + offsetX;
                int drawY = myself.currentY + offsetY;
                if (drawY >= 0) {
                    int pieceLeft = BoardX + drawX * CellSize;
                    int pieceTop = BoardY + drawY * CellSize;
                    int pieceRight = pieceLeft + CellSize - 1;
                    int pieceBottom = pieceTop + CellSize - 1;
                    fillrect(pieceLeft, pieceTop, pieceRight, pieceBottom);
                }
            }
        }
        
        // Draw score info
        setrgbcolor(255, 255, 255);
        str scoreStr = "Score: " + inttostr(myself.board.getScore());
        outtextxy(20, 20, scoreStr);
        
        str levelStr = "Level: " + inttostr(myself.board.getLevel());
        outtextxy(20, 40, levelStr);
        
        str linesStr = "Lines: " + inttostr(myself.board.getLines());
        outtextxy(20, 60, linesStr);
        
        if (myself.gameOver) {
            str gameOverStr = "GAME OVER - Press Q to quit";
            outtextxy(BoardX + 10, BoardY + BoardHeight * CellSize / 2 - 20, gameOverStr);
        }
        
        updatescreen();
    }
    
    bool handleInput() {
        if (keypressed()) {
            char c = readkey();
            int code = ord(c);
            if (code == 0 || code == 224) {
                char extended = readkey();
                int extCode = ord(extended);
                if (extCode == 75) {
                    myself.movePiece(-1, 0); // Left arrow
                } else if (extCode == 77) {
                    myself.movePiece(1, 0); // Right arrow
                } else if (extCode == 72) {
                    myself.rotatePiece(); // Up arrow
                } else if (extCode == 80) {
                    myself.movePiece(0, 1); // Down arrow
                }
                return false;
            }

            char key = toupper(c);
            if (key == 'Q') {
                return true; // Quit
            }
            if (myself.gameOver) return false;

            switch (key) {
                case 'A':
                    myself.movePiece(-1, 0);
                    break;
                case 'D':
                    myself.movePiece(1, 0);
                    break;
                case 'S':
                    myself.movePiece(0, 1);
                    break;
                case 'W':
                    myself.rotatePiece();
                    break;
            }

            if (c == ' ') {
                myself.hardDrop();
            }
        }
        
        return false; // Continue running
    }
    
    void run() {
        initgraph(WindowWidth, WindowHeight, "Rea Block Game");
        str systemFontPath = "/usr/local/Pscal/fonts/Roboto/static/Roboto-Regular.ttf";
        str repoFontPath1 = "fonts/Roboto/static/Roboto-Regular.ttf";
        str repoFontPath2 = "../../fonts/Roboto/static/Roboto-Regular.ttf";
        if (fileexists(systemFontPath)) {
            inittextsystem(systemFontPath, 18);
        } else if (fileexists(repoFontPath1)) {
            inittextsystem(repoFontPath1, 18);
        } else {
            inittextsystem(repoFontPath2, 18);
        }
        randomize();

        writeln("Block Game - Use A/D or "+
                "Left/Right to move, S or Down to drop, W or Up to rotate, Space for hard drop. Press Q to quit.");
        
        float lastTime = 0.0;
        bool quit = false;
        
        while (!quit && !myself.gameOver) {
            float currentTime = getticks() / 1000.0;
            float deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            if (deltaTime > 0.1) deltaTime = 0.1; // Cap at 100ms
            
            myself.update(deltaTime);
            
            if (myself.handleInput()) {
                quit = true;
            }
            
            myself.draw();
            graphloop(myself.frameDelay);
        }
        
        if (myself.gameOver) {
            writeln("Game Over! Final Score: ", myself.board.getScore());
        }
        
        closegraph();
        writeln("Thanks for playing Block Game!");
    }
}

Game mygame = new Game();
mygame.run();
