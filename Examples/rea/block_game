#!/usr/bin/env rea
// Uses SDL for graphics and input handling

const int BoardWidth = 10;
const int BoardHeight = 20;
const int CellSize = 30;

class Tetromino {
    str shape;
    int colorR;
    int colorG;
    int colorB;
    int rotation;
    
    void Tetromino(str s, int r, int g, int b) {
        myself.shape = s;
        myself.colorR = r;
        myself.colorG = g;
        myself.colorB = b;
        myself.rotation = 0;
    }
    
    void rotate() {
        myself.rotation = (myself.rotation + 1) % 4;
    }
    
    int getShape(int rot, int x, int y) {
        // Simplified shape representation
        if (rot == 0) {
            return myself.shape[y * 4 + x + 1];
        }
        return 0;
    }
}

class Board {
    int grid[BoardWidth * BoardHeight];
    int score;
    int level;
    int lines;
    
    void Board() {
        myself.score = 0;
        myself.level = 1;
        myself.lines = 0;
        int i;
        for (i = 0; i < BoardWidth * BoardHeight; i = i + 1) {
            myself.grid[i] = 0;
        }
    }
    
    bool isValidPosition(int x, int y) {
        return (x >= 0 && x < BoardWidth && y >= 0 && y < BoardHeight);
    }
    
    bool isCollision(int x, int y, str shape) {
        int i, j;
        for (i = 0; i < 4; i = i + 1) {
            for (j = 0; j < 4; j = j + 1) {
                int index = i * 4 + j + 1;
                if (shape[index] == '1') {
                    int newX = x + j;
                    int newY = y + i;
                    if (!myself.isValidPosition(newX, newY) || myself.grid[newY * BoardWidth + newX] != 0) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    void placePiece(int x, int y, str shape, int color) {
        int i, j;
        for (i = 0; i < 4; i = i + 1) {
            for (j = 0; j < 4; j = j + 1) {
                int index = i * 4 + j + 1;
                if (shape[index] == '1') {
                    int newX = x + j;
                    int newY = y + i;
                    if (myself.isValidPosition(newX, newY)) {
                        myself.grid[newY * BoardWidth + newX] = color;
                    }
                }
            }
        }
    }
    
    void clearLines() {
        int linesCleared = 0;
        int i, j, k;

        for (i = BoardHeight - 1; i >= 0; i = i - 1) {
            bool fullLine = true;
            for (j = 0; j < BoardWidth; j = j + 1) {
                if (myself.grid[i * BoardWidth + j] == 0) {
                    fullLine = false;
                    break;
                }
            }
            
            if (fullLine) {
                linesCleared = linesCleared + 1;
                // Shift all lines above down
                for (k = i; k > 0; k = k - 1) {
                    for (j = 0; j < BoardWidth; j = j + 1) {
                        myself.grid[k * BoardWidth + j] = myself.grid[(k - 1) * BoardWidth + j];
                    }
                }
                // Clear top line
                for (j = 0; j < BoardWidth; j = j + 1) {
                    myself.grid[j] = 0;
                }
                i = i + 1; // Check same row again
            }
        }
        
        if (linesCleared > 0) {
            myself.lines = myself.lines + linesCleared;
            myself.score = myself.score + linesCleared * 100 * myself.level;
            if (myself.lines >= myself.level * 10) {
                myself.level = myself.level + 1;
            }
        }
    }
    
    void draw(int offsetX, int offsetY) {
        int i, j;
        for (i = 0; i < BoardHeight; i = i + 1) {
            for (j = 0; j < BoardWidth; j = j + 1) {
                int value = myself.grid[i * BoardWidth + j];
                if (value != 0) {
                    int r = value % 256;
                    int g = int(value / 256) % 256;
                    int b = int(value / 65536);
                    setrgbcolor(r, g, b);
                    fillrect(offsetX + j * CellSize, offsetY + i * CellSize, CellSize - 1, CellSize - 1);
                }
            }
        }
    }
    
    int getScore() { return myself.score; }
    int getLevel() { return myself.level; }
    int getLines() { return myself.lines; }
}

class Game {
    const int WindowWidth = 400;
    const int WindowHeight = 600;
    const int BoardX = 50;
    const int BoardY = 20;
    
    Board board;
    str currentShape;
    int currentColor;
    int currentX;
    int currentY;
    int nextShape;
    bool gameOver;
    int frameDelay;
    float dropTime;
    float lastDrop;
    
    void Game() {
        myself.board = new Board();
        myself.gameOver = false;
        myself.frameDelay = 1000 / 60; // ~60 FPS
        myself.dropTime = 0.5; // seconds per drop
        myself.lastDrop = 0.0;
        myself.currentX = BoardWidth / 2 - 2;
        myself.currentY = 0;
        myself.nextShape = random(7);
        myself.spawnPiece();
    }
    
    void spawnPiece() {
        // Simplified tetromino shapes: 4x4 grids stored row-major with '1' marking filled cells
        str shapes[7];
        shapes[0] = "0000111100000000"; // I
        shapes[1] = "0110011000000000";  // O
        shapes[2] = "0100111000000000";  // T
        shapes[3] = "0110110000000000";  // S
        shapes[4] = "1100011000000000";  // Z
        shapes[5] = "1000111000000000";  // J
        shapes[6] = "0010111000000000";  // L

        int colorR[7];
        int colorG[7];
        int colorB[7];
        colorR[0] = 0;   colorG[0] = 255; colorB[0] = 255; // Cyan
        colorR[1] = 255; colorG[1] = 255; colorB[1] = 0;   // Yellow
        colorR[2] = 128; colorG[2] = 0;   colorB[2] = 128; // Purple
        colorR[3] = 0;   colorG[3] = 255; colorB[3] = 0;   // Green
        colorR[4] = 255; colorG[4] = 0;   colorB[4] = 0;   // Red
        colorR[5] = 0;   colorG[5] = 0;   colorB[5] = 255; // Blue
        colorR[6] = 255; colorG[6] = 165; colorB[6] = 0;   // Orange

        myself.currentShape = shapes[myself.nextShape];
        myself.currentColor = colorR[myself.nextShape] +
                              colorG[myself.nextShape] * 256 +
                              colorB[myself.nextShape] * 65536;
        myself.nextShape = random(7);
        myself.currentX = BoardWidth / 2 - 2;
        myself.currentY = 0;
        
        if (myself.board.isCollision(myself.currentX, myself.currentY, myself.currentShape)) {
            myself.gameOver = true;
        }
    }
    
    void movePiece(int dx, int dy) {
        if (!myself.gameOver && !myself.board.isCollision(myself.currentX + dx, myself.currentY + dy, myself.currentShape)) {
            myself.currentX = myself.currentX + dx;
            myself.currentY = myself.currentY + dy;
        }
    }
    
    void rotatePiece() {
        if (!myself.gameOver) {
            // Simplified rotation - we'll just use the same shape for now
            // In a full implementation, this would rotate the piece's pattern
        }
    }
    
    void hardDrop() {
        if (!myself.gameOver) {
            while (!myself.board.isCollision(myself.currentX, myself.currentY + 1, myself.currentShape)) {
                myself.currentY = myself.currentY + 1;
            }
            myself.lockPiece();
        }
    }
    
    void lockPiece() {
        myself.board.placePiece(myself.currentX, myself.currentY, myself.currentShape, myself.currentColor);
        myself.board.clearLines();
        myself.spawnPiece();
    }
    
    void update(float deltaTime) {
        if (myself.gameOver) return;
        
        myself.lastDrop = myself.lastDrop + deltaTime;
        if (myself.lastDrop >= myself.dropTime) {
            if (!myself.board.isCollision(myself.currentX, myself.currentY + 1, myself.currentShape)) {
                myself.currentY = myself.currentY + 1;
            } else {
                myself.lockPiece();
            }
            myself.lastDrop = 0.0;
        }
    }
    
    void draw() {
        cleardevice();
        
        // Draw board background
        setrgbcolor(30, 30, 30);
        fillrect(BoardX - 5, BoardY - 5, BoardWidth * CellSize + 10, BoardHeight * CellSize + 10);
        
        // Draw grid lines
        setrgbcolor(60, 60, 60);
        int i;
        for (i = 0; i <= BoardWidth; i = i + 1) {
            drawline(BoardX + i * CellSize, BoardY, BoardX + i * CellSize, BoardY + BoardHeight * CellSize);
        }
        for (i = 0; i <= BoardHeight; i = i + 1) {
            drawline(BoardX, BoardY + i * CellSize, BoardX + BoardWidth * CellSize, BoardY + i * CellSize);
        }
        
        // Draw placed pieces
        myself.board.draw(BoardX, BoardY);
        
        // Draw current piece
        if (!myself.gameOver) {
            int x, y;
            int currentR = myself.currentColor % 256;
            int currentG = int(myself.currentColor / 256) % 256;
            int currentB = int(myself.currentColor / 65536);
            setrgbcolor(currentR, currentG, currentB);
            for (y = 0; y < 4; y = y + 1) {
                for (x = 0; x < 4; x = x + 1) {
                    int index = y * 4 + x + 1;
                    if (myself.currentShape[index] == '1') {
                        fillrect(
                            BoardX + (myself.currentX + x) * CellSize,
                            BoardY + (myself.currentY + y) * CellSize,
                            CellSize - 1, CellSize - 1
                        );
                    }
                }
            }
        }
        
        // Draw score info
        setrgbcolor(255, 255, 255);
        str scoreStr = "Score: " + inttostr(myself.board.getScore());
        outtextxy(20, 20, scoreStr);
        
        str levelStr = "Level: " + inttostr(myself.board.getLevel());
        outtextxy(20, 40, levelStr);
        
        str linesStr = "Lines: " + inttostr(myself.board.getLines());
        outtextxy(20, 60, linesStr);
        
        if (myself.gameOver) {
            str gameOverStr = "GAME OVER - Press Q to quit";
            outtextxy(BoardX + 10, BoardY + BoardHeight * CellSize / 2 - 20, gameOverStr);
        }
        
        updatescreen();
    }
    
    bool handleInput() {
        if (keypressed()) {
            char c = readkey();
            if (c == 'q' || c == 'Q') {
                return true; // Quit
            }
            if (myself.gameOver) return false;
            
            switch (c) {
                case 'a':
                case 'A':
                    myself.movePiece(-1, 0);
                    break;
                case 'd':
                case 'D':
                    myself.movePiece(1, 0);
                    break;
                case 's':
                case 'S':
                    myself.movePiece(0, 1);
                    break;
                case 'w':
                case 'W':
                    myself.rotatePiece();
                    break;
                case ' ':
                    myself.hardDrop();
                    break;
            }
        }
        
        return false; // Continue running
    }
    
    void run() {
        initgraph(WindowWidth, WindowHeight, "Rea Block Game");
        randomize();
        
        writeln("Block Game - Use A/D to move, S to drop, W to rotate, Space for hard drop. Press Q to quit.");
        
        float lastTime = 0.0;
        bool quit = false;
        
        while (!quit && !myself.gameOver) {
            float currentTime = getticks() / 1000.0;
            float deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            if (deltaTime > 0.1) deltaTime = 0.1; // Cap at 100ms
            
            myself.update(deltaTime);
            
            if (myself.handleInput()) {
                quit = true;
            }
            
            myself.draw();
            graphloop(myself.frameDelay);
        }
        
        if (myself.gameOver) {
            writeln("Game Over! Final Score: ", myself.board.getScore());
        }
        
        closegraph();
        writeln("Thanks for playing Block Game!");
    }
}

Game mygame = new Game();
mygame.run();
