#!/usr/bin/env pascal
program HttpAsyncDemo;

uses SysUtils;

var s, id, code: integer;
    ms: mstream;
    workDir, srcPath, dstPath, url, line: string;
    f: text;

function ResolveWorkDir: string;
var
  candidate: string;
begin
  candidate := GetCurrentDir();
  candidate := candidate + '';
  if candidate = '' then
    candidate := GetEnv('PWD');
  candidate := candidate + '';
  if candidate = '' then
    candidate := GetEnv('HOME') + '';
  if candidate = '' then
    candidate := '/tmp';
  ResolveWorkDir := candidate;
end;

function NormalizeForUrl(const path: string): string;
var
  i: integer;
  tmp: string;
begin
  tmp := path;
  for i := 1 to Length(tmp) do
  begin
    if tmp[i] = '\' then
      tmp[i] := '/';
  end;
  NormalizeForUrl := tmp;
end;

function AppendTrailingSlash(const path: string): string;
var
  tmp: string;
  lastChar: char;
begin
  tmp := path + '';
  if tmp = '' then
  begin
    AppendTrailingSlash := '';
    exit;
  end;
  lastChar := tmp[Length(tmp)];
  if (lastChar <> '/') and (lastChar <> '\') then
    AppendTrailingSlash := tmp + '/'
  else
    AppendTrailingSlash := tmp;
end;
begin
  workDir := AppendTrailingSlash(ResolveWorkDir);
  srcPath := workDir + 'http_async_src.txt';
  dstPath := workDir + 'http_async_dst.txt';

  { Create local file to fetch via file:// }
  assign(f, srcPath);
  rewrite(f);
  writeln(f, 'HelloAsync');
  close(f);

  url := 'file://' + NormalizeForUrl(srcPath);

  s := HttpSession();
  id := HttpRequestAsyncToFile(s, 'GET', url, nil, dstPath);
  while HttpIsDone(id) = 0 do Delay(10);

  ms := mstreamcreate();
  code := HttpAwait(id, ms);
  writeln('Status: ', code);

  assign(f, dstPath);
  reset(f); readln(f, line); close(f);
  writeln('File: ', line);

  mstreamfree(ms);
  HttpClose(s);
  if FileExists(dstPath) then
  begin
    assign(f, dstPath);
    erase(f);
  end;
  if FileExists(srcPath) then
  begin
    assign(f, srcPath);
    erase(f);
  end;
end.
