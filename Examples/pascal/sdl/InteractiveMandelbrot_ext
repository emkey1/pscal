#!/usr/bin/env pascal
PROGRAM TextureMandelbrotZoomBuiltin;

USES CRT;

CONST
  DefaultMandelWindowWidth   = 1024;
  DefaultMandelWindowHeight  = 768;
  MandelWindowTitle   = 'Mandelbrot (Builtin Row - LMB:Zoom, RMB:Reset, Q:Quit)';
  DefaultBaseIterations      = 50;
  MinimumBaseIterations      = 25;
  ZoomIterationIncrement     = 5;
  MaxIterationMultiplier     = 2;
  BenchmarkTargetFrameMs     = 900;
  BenchmarkSampleWidth       = 320;
  BenchmarkSampleRows        = 24;
  BenchmarkSampleIterations  = 100;
  BenchmarkSafetyFactor      = 0.90;
  MandelZoomFactor    = 2.0;
  MandelBytesPerPixel = 4;
  MandelTextureUpdateIntervalRows = 1;
  MaxWorkerThreads = 15;
  DefaultCpuCount = 4;

  InitialMinRe  = -2.0;
  InitialMaxRe  =  1.0;
  InitialCenterIm = 0.0;

  ButtonLeft   = 1;
  ButtonRight  = 4;

  ControlsStartY = 4;
  StatusLineY    = 10;

TYPE
  PixelBuffer = ARRAY OF Byte;
  RowStateBuffer = ARRAY OF Integer;
  MandelRowIterations = ARRAY OF Integer;
  PWorkerArg = ^Integer;

VAR
  MandelWindowWidth, MandelWindowHeight : Integer;
  MinRe, MaxRe, MinIm, MaxIm : Real;
  ViewPixelWidth, ViewPixelHeight : Integer;
  ReRange, ImRange           : Real;
  ScaleRe, ScaleIm           : Real;

  InitialSpanRe : Real;
  BaseIterations : Integer;
  CurrentMaxIterations : Integer;

  MandelTextureID : Integer;
  DisplayPixelData : PixelBuffer;
  QuitProgram     : Boolean;
  RedrawNeeded    : Boolean;
  RenderInProgress : Boolean;
  MouseX, MouseY, MouseButtons : Integer;
  PrevMouseButtons : Integer; // Track previous mouse button state to detect fresh clicks

  PendingZoom, PendingReset : Boolean;
  PendingMinRe, PendingMaxRe, PendingMinIm : Real;
  PendingMouseX, PendingMouseY : Integer;

  ThreadCount : Integer;
  ThreadStart, ThreadEnd, ThreadStride : ARRAY OF Integer;
  RowDone : RowStateBuffer;
  RenderThreadIDs : ARRAY OF Integer;
  WorkerArgs : ARRAY OF Integer;
  WorkReady : ARRAY OF Integer;
  WorkerShutdown : Boolean;
  RowMutex : Integer;
  WorkMutex : Integer;
  CancelMutex : Integer;
  CancelRender : Boolean;

  PercentDone : Integer;
  i : Integer;
  MinimalConsoleOutput : Boolean;

FUNCTION ResolveMinimalConsoleOutput: Boolean;
VAR
  overrideFlag: Integer;
  sessionPath: String;
BEGIN
  overrideFlag := GetEnvInt('PSCAL_MANDEL_MIN_CONSOLE', -1);
  IF overrideFlag < 0 THEN
    overrideFlag := GetEnvInt('MANDEL_MIN_CONSOLE', -1);
  IF overrideFlag >= 0 THEN BEGIN
    ResolveMinimalConsoleOutput := overrideFlag <> 0;
    EXIT;
  END;

  sessionPath := GetEnv('SESSIONPATH');
  ResolveMinimalConsoleOutput := sessionPath <> '';
END;

FUNCTION ResolveWorkerThreadCount: Integer;
VAR
  overrideCount, totalCpuCount, resolved: Integer;
BEGIN
  overrideCount := GetEnvInt('PSCAL_MANDEL_THREADS', 0);
  IF overrideCount <= 0 THEN
    overrideCount := GetEnvInt('MANDEL_THREADS', 0);

  IF overrideCount > 0 THEN BEGIN
    resolved := overrideCount;
  END ELSE BEGIN
    totalCpuCount := GetEnvInt('PSCAL_CPU_COUNT', 0);
    IF totalCpuCount <= 0 THEN
      totalCpuCount := GetEnvInt('PSCAL_ACTIVE_CPU_COUNT', 0);
    IF totalCpuCount <= 0 THEN
      totalCpuCount := DefaultCpuCount;

    resolved := totalCpuCount DIV 2;
    IF resolved <= 0 THEN
      resolved := 1;
  END;

  IF resolved < 1 THEN
    resolved := 1;
  IF resolved > MaxWorkerThreads THEN
    resolved := MaxWorkerThreads;

  ResolveWorkerThreadCount := resolved;
END;

PROCEDURE RefreshWindowDimensionsFromScreen;
VAR
  detectedWidth, detectedHeight: Integer;
BEGIN
  detectedWidth := MandelWindowWidth;
  detectedHeight := MandelWindowHeight;
  IF GetScreenSize(detectedWidth, detectedHeight) THEN BEGIN
    IF detectedWidth > 0 THEN
      MandelWindowWidth := detectedWidth;
    IF detectedHeight > 0 THEN
      MandelWindowHeight := detectedHeight;
  END;
END;

PROCEDURE ConfigureWorkerArrays;
BEGIN
  ThreadCount := ResolveWorkerThreadCount;
  SetLength(ThreadStart, ThreadCount);
  SetLength(ThreadEnd, ThreadCount);
  SetLength(ThreadStride, ThreadCount);
  SetLength(RenderThreadIDs, ThreadCount);
  SetLength(WorkerArgs, ThreadCount);
  SetLength(WorkReady, ThreadCount);
END;

FUNCTION ResolveBenchmarkTargetFrameMs: Integer;
VAR
  targetMs: Integer;
BEGIN
  targetMs := GetEnvInt('PSCAL_MANDEL_TARGET_MS', BenchmarkTargetFrameMs);
  IF targetMs < 250 THEN
    targetMs := 250;
  ResolveBenchmarkTargetFrameMs := targetMs;
END;

FUNCTION BenchmarkBaseIterations(targetFrameMs: Integer): Integer;
VAR
  sampleWidth, sampleRows, sampleIterations, threadsForEstimate: Integer;
  startTicks, endTicks, elapsedMs, rowIndex: Integer;
  sampleMinRe, sampleMaxRe, sampleReRange: Real;
  sampleMinIm, sampleMaxIm, sampleScaleRe, sampleScaleIm, y0: Real;
  samplePixels, fullPixels, estimatedReal: Real;
  rowIterations: MandelRowIterations;
  estimated: Integer;
BEGIN
  sampleWidth := ViewPixelWidth;
  IF sampleWidth > BenchmarkSampleWidth THEN
    sampleWidth := BenchmarkSampleWidth;
  IF sampleWidth < 64 THEN
    sampleWidth := 64;

  sampleRows := ViewPixelHeight;
  IF sampleRows > BenchmarkSampleRows THEN
    sampleRows := BenchmarkSampleRows;
  IF sampleRows < 8 THEN
    sampleRows := 8;

  IF sampleWidth <= 1 THEN BEGIN
    BenchmarkBaseIterations := MinimumBaseIterations;
    EXIT;
  END;

  sampleIterations := BenchmarkSampleIterations;

  sampleMinRe := InitialMinRe;
  sampleMaxRe := InitialMaxRe;
  sampleReRange := sampleMaxRe - sampleMinRe;
  IF sampleReRange <= 0.0 THEN
    sampleReRange := 3.0;

  IF ViewPixelWidth > 0 THEN
    sampleMaxIm := InitialCenterIm + ((sampleReRange * ViewPixelHeight / ViewPixelWidth) / 2.0)
  ELSE
    sampleMaxIm := InitialCenterIm + (sampleReRange / 2.0);
  sampleMinIm := InitialCenterIm - (sampleMaxIm - InitialCenterIm);

  sampleScaleRe := sampleReRange / (sampleWidth - 1);
  IF sampleRows > 1 THEN
    sampleScaleIm := (sampleMaxIm - sampleMinIm) / (sampleRows - 1)
  ELSE
    sampleScaleIm := (sampleMaxIm - sampleMinIm);

  SetLength(rowIterations, sampleWidth);
  startTicks := GetTicks();
  FOR rowIndex := 0 TO sampleRows - 1 DO BEGIN
    y0 := sampleMaxIm - (rowIndex * sampleScaleIm);
    MandelbrotRow(sampleMinRe, sampleScaleRe, y0, sampleIterations, sampleWidth - 1, rowIterations);
  END;
  endTicks := GetTicks();
  elapsedMs := endTicks - startTicks;
  IF elapsedMs < 1 THEN
    elapsedMs := 1;

  threadsForEstimate := ThreadCount;
  IF threadsForEstimate < 1 THEN
    threadsForEstimate := 1;

  samplePixels := sampleWidth * sampleRows;
  fullPixels := ViewPixelWidth * ViewPixelHeight;
  IF fullPixels < 1.0 THEN
    fullPixels := 1.0;

  estimatedReal := sampleIterations;
  estimatedReal := estimatedReal * (targetFrameMs / elapsedMs);
  estimatedReal := estimatedReal * (samplePixels / fullPixels);
  estimatedReal := estimatedReal * threadsForEstimate;
  estimatedReal := estimatedReal * BenchmarkSafetyFactor;

  estimated := Trunc(estimatedReal + 0.5);
  IF estimated < MinimumBaseIterations THEN
    estimated := MinimumBaseIterations;

  BenchmarkBaseIterations := estimated;
END;

PROCEDURE ConfigureAdaptiveIterations;
VAR
  targetFrameMs, benchmarkBase, maxIterations: Integer;
BEGIN
  targetFrameMs := ResolveBenchmarkTargetFrameMs;
  benchmarkBase := BenchmarkBaseIterations(targetFrameMs);

  BaseIterations := benchmarkBase;
  RecomputeMaxIterations;
  maxIterations := BaseIterations * MaxIterationMultiplier;
  WriteLn('Mandelbrot initial iterations: ', BaseIterations, ' (max ', maxIterations, ', +', ZoomIterationIncrement, '/zoom)');
  IF NOT MinimalConsoleOutput THEN BEGIN
    GotoXY(1, ControlsStartY + 6); ClrEol;
    Write('Benchmark: base=', BaseIterations, ', max=', maxIterations, ', target=', targetFrameMs, 'ms');
  END;
END;

PROCEDURE EnsurePixelBuffersSized;
VAR
  RequiredPixels, RequiredBytes: Integer;
BEGIN
  RequiredPixels := ViewPixelWidth * ViewPixelHeight;
  RequiredBytes := RequiredPixels * MandelBytesPerPixel;

  IF Length(DisplayPixelData) <> RequiredBytes THEN
    SetLength(DisplayPixelData, RequiredBytes);
  IF Length(RowDone) <> ViewPixelHeight THEN
    SetLength(RowDone, ViewPixelHeight);
END;

PROCEDURE RecomputeMaxIterations;
VAR
  spanRe, baseSpan, zoomRatio : Real;
  zoomSteps, maxIterations : Integer;
BEGIN
  baseSpan := InitialSpanRe;
  IF baseSpan <= 0.0 THEN
    baseSpan := MaxRe - MinRe;

  spanRe := MaxRe - MinRe;
  IF spanRe <= 0.0 THEN
    spanRe := baseSpan;

  zoomSteps := 0;
  IF (spanRe > 0.0) AND (baseSpan > 0.0) THEN BEGIN
    zoomRatio := baseSpan / spanRe;
    IF zoomRatio > 0.0 THEN
      zoomSteps := Trunc(Ln(zoomRatio) / Ln(2.0));
  END;

  IF zoomSteps < 0 THEN
    zoomSteps := 0;

  CurrentMaxIterations := BaseIterations + (zoomSteps * ZoomIterationIncrement);
  maxIterations := BaseIterations * MaxIterationMultiplier;
  IF CurrentMaxIterations > maxIterations THEN
    CurrentMaxIterations := maxIterations;
END;

// This procedure recalculates MaxIm and scaling factors based on CURRENT MinRe, MaxRe, MinIm
PROCEDURE UpdateScalingAndDependentViewParams;
BEGIN
  // GetMaxX/Y are based on InitGraph, which uses MandelWindowWidth/Height constants for texture too
  ViewPixelWidth  := MandelWindowWidth;  // Assuming texture matches window size
  ViewPixelHeight := MandelWindowHeight;

  ReRange := MaxRe - MinRe;
  IF ViewPixelWidth > 0 THEN
    MaxIm := MinIm + (ReRange * ViewPixelHeight) / ViewPixelWidth
  ELSE
    MaxIm := MinIm;
  ImRange := MaxIm - MinIm;

  IF ViewPixelWidth > 1 THEN ScaleRe := ReRange / (ViewPixelWidth - 1)
  ELSE IF ViewPixelWidth = 1 THEN ScaleRe := ReRange
  ELSE ScaleRe := 0;

  IF ViewPixelHeight > 1 THEN ScaleIm := ImRange / (ViewPixelHeight - 1)
  ELSE IF ViewPixelHeight = 1 THEN ScaleIm := ImRange
  ELSE ScaleIm := 0;

  RecomputeMaxIterations;

  // Update console display
  IF NOT MinimalConsoleOutput THEN BEGIN
    GotoXY(1, 2); ClrEol; Write('View: Re[', MinRe:0:4,'..',MaxRe:0:4,'], Im[',MinIm:0:4,'..',MaxIm:0:4,']');
    GotoXY(1, ControlsStartY + 4); ClrEol;
    Write('Max Iter: ', CurrentMaxIterations, ', Zoom Factor: ', MandelZoomFactor:0:1, ', Texture ID: ', MandelTextureID); ClrEol;
  END;
  EnsurePixelBuffersSized;
END;

PROCEDURE ResetViewToInitial;
VAR
  initialImRange: Real;
BEGIN
  MinRe := InitialMinRe;
  MaxRe := InitialMaxRe;
  IF MandelWindowWidth > 0 THEN
    initialImRange := (MaxRe - MinRe) * MandelWindowHeight / MandelWindowWidth
  ELSE
    initialImRange := (MaxRe - MinRe);
  MinIm := InitialCenterIm - (initialImRange / 2.0);
  InitialSpanRe := MaxRe - MinRe;
  RecomputeMaxIterations;
  UpdateScalingAndDependentViewParams; // Now calculate MaxIm and scales for these initial values
END;

PROCEDURE UpdateAndDisplayTextureInProgress;
BEGIN
  UpdateTexture(MandelTextureID, DisplayPixelData);
  ClearDevice;
  RenderCopy(MandelTextureID);
  UpdateScreen;
  GraphLoop(0);
END;

FUNCTION RenderCancellationRequested: Boolean;
VAR ResultValue: Boolean;
BEGIN
  lock(CancelMutex);
  ResultValue := CancelRender;
  unlock(CancelMutex);
  RenderCancellationRequested := ResultValue;
END;

PROCEDURE RequestRenderCancellation;
VAR AlreadyCancelling: Boolean;
BEGIN
  lock(CancelMutex);
  AlreadyCancelling := CancelRender;
  CancelRender := True;
  unlock(CancelMutex);
  IF (NOT AlreadyCancelling) AND (NOT MinimalConsoleOutput) THEN BEGIN
    GotoXY(1, StatusLineY); ClrEol; Write('Cancelling current render...');
  END;
END;

PROCEDURE ClearRenderCancellation;
BEGIN
  lock(CancelMutex);
  CancelRender := False;
  unlock(CancelMutex);
END;

FUNCTION ComputeRows(startY, endY, rowStride: Integer): Boolean;
VAR LocalPy, LocalPx, BufferBaseIdx, Iteration: Integer;
    y0: Real;
    RowIterations: MandelRowIterations;
    R_calc, G_calc, B_calc: Byte;
    Cancelled: Boolean;
BEGIN
  IF rowStride <= 0 THEN
    rowStride := 1;
  Cancelled := False;
  SetLength(RowIterations, ViewPixelWidth);
  LocalPy := startY;
  WHILE LocalPy <= endY DO BEGIN
    IF RenderCancellationRequested THEN BEGIN
      Cancelled := True;
      BREAK;
    END;
    y0 := MaxIm - (LocalPy * ScaleIm);
    MandelbrotRow(MinRe, ScaleRe, y0, CurrentMaxIterations, ViewPixelWidth - 1, RowIterations);
    FOR LocalPx := 0 TO ViewPixelWidth - 1 DO BEGIN
      Iteration := RowIterations[LocalPx];
      IF Iteration = CurrentMaxIterations THEN BEGIN
        R_calc := Byte(0);
        G_calc := Byte(0);
        B_calc := Byte(0);
      END ELSE BEGIN
        R_calc := Byte(((Iteration * 12) MOD 256 + 256) MOD 256);
        G_calc := Byte(((Iteration * 8 + 80) MOD 256 + 256) MOD 256);
        B_calc := Byte(((Iteration * 5 + 160) MOD 256 + 256) MOD 256);
      END;
      BufferBaseIdx := (LocalPy * ViewPixelWidth + LocalPx) * MandelBytesPerPixel;
      DisplayPixelData[BufferBaseIdx + 0] := R_calc;
      DisplayPixelData[BufferBaseIdx + 1] := G_calc;
      DisplayPixelData[BufferBaseIdx + 2] := B_calc;
      DisplayPixelData[BufferBaseIdx + 3] := Byte(255);
    END; // Px
    lock(RowMutex);
    RowDone[LocalPy] := 1;
    unlock(RowMutex);
    LocalPy := LocalPy + rowStride;
  END; // Py
  ComputeRows := NOT Cancelled;
END;

FUNCTION TryClaimRowCopy(y: Integer): Boolean;
VAR canCopy: Boolean;
BEGIN
  canCopy := False;
  lock(RowMutex);
  IF (y >= 0) AND (y < Length(RowDone)) AND (RowDone[y] = 1) THEN BEGIN
    RowDone[y] := 2;
    canCopy := True;
  END;
  unlock(RowMutex);
  TryClaimRowCopy := canCopy;
END;

PROCEDURE ResetRowState;
VAR y: Integer;
BEGIN
  IF Length(RowDone) <> ViewPixelHeight THEN
    SetLength(RowDone, ViewPixelHeight);
  lock(RowMutex);
  FOR y := 0 TO ViewPixelHeight - 1 DO
    RowDone[y] := 0;
  unlock(RowMutex);
END;

PROCEDURE SetWorkerShutdown(value: Boolean);
BEGIN
  lock(WorkMutex);
  WorkerShutdown := value;
  unlock(WorkMutex);
END;

FUNCTION WorkerShutdownRequested: Boolean;
VAR flag: Boolean;
BEGIN
  lock(WorkMutex);
  flag := WorkerShutdown;
  unlock(WorkMutex);
  WorkerShutdownRequested := flag;
END;

PROCEDURE ClearWorkerAssignments;
VAR idx: Integer;
BEGIN
  lock(WorkMutex);
  FOR idx := 0 TO ThreadCount - 1 DO
    WorkReady[idx] := 0;
  unlock(WorkMutex);
  FOR idx := 0 TO ThreadCount - 1 DO
    RenderThreadIDs[idx] := -1;
END;

PROCEDURE PublishWork(id, startY, endY, rowStride: Integer);
BEGIN
  lock(WorkMutex);
  ThreadStart[id] := startY;
  ThreadEnd[id] := endY;
  ThreadStride[id] := rowStride;
  WorkReady[id] := 1;
  unlock(WorkMutex);
END;

FUNCTION TryClaimWork(id: Integer; VAR startY, endY, rowStride: Integer): Boolean;
VAR hasWork: Boolean;
BEGIN
  lock(WorkMutex);
  hasWork := WorkReady[id] = 1;
  IF hasWork THEN BEGIN
    startY := ThreadStart[id];
    endY := ThreadEnd[id];
    rowStride := ThreadStride[id];
    WorkReady[id] := 2;
  END;
  unlock(WorkMutex);
  TryClaimWork := hasWork;
END;

PROCEDURE FinishWork(id: Integer);
BEGIN
  lock(WorkMutex);
  WorkReady[id] := 0;
  unlock(WorkMutex);
END;

FUNCTION WorkerBusy(id: Integer): Boolean;
VAR busy: Boolean;
BEGIN
  lock(WorkMutex);
  busy := WorkReady[id] <> 0;
  unlock(WorkMutex);
  WorkerBusy := busy;
END;

PROCEDURE WorkerLoop(id: Integer);
VAR Completed: Boolean;
    startY, endY, rowStride: Integer;
BEGIN
  WHILE NOT WorkerShutdownRequested DO BEGIN
    IF TryClaimWork(id, startY, endY, rowStride) THEN BEGIN
      Completed := ComputeRows(startY, endY, rowStride);
      IF NOT Completed THEN
        Delay(0);
      FinishWork(id);
    END ELSE
      Delay(0);
  END;
END;

PROCEDURE WorkerEntry(argPtr: PWorkerArg);
VAR workerId: Integer;
BEGIN
  IF argPtr = NIL THEN
    EXIT;
  workerId := argPtr^;
  WorkerLoop(workerId);
END;

PROCEDURE SpawnWorker(id: Integer);
VAR handle: Integer;
BEGIN
  WorkerArgs[id] := id;
  handle := CreateThread(@WorkerEntry, @WorkerArgs[id]);
  IF handle >= 0 THEN
    RenderThreadIDs[id] := handle
  ELSE
    RenderThreadIDs[id] := -1;
END;

PROCEDURE ScheduleZoomRequest(clickX, clickY: Integer);
VAR
  LocalCenterX, LocalCenterY       : Real;
  LocalViewWidthRe, LocalViewHeightIm : Real;
  LocalNewViewWidthRe, LocalNewViewHeightIm : Real;
BEGIN
  LocalCenterX := MinRe + (clickX * ScaleRe);
  LocalCenterY := MaxIm - (clickY * ScaleIm);
  LocalViewWidthRe  := MaxRe - MinRe;
  LocalViewHeightIm := MaxIm - MinIm;
  LocalNewViewWidthRe  := LocalViewWidthRe / MandelZoomFactor;
  LocalNewViewHeightIm := LocalViewHeightIm / MandelZoomFactor;

  PendingMinRe := LocalCenterX - (LocalNewViewWidthRe / 2.0);
  PendingMaxRe := LocalCenterX + (LocalNewViewWidthRe / 2.0);
  PendingMinIm := LocalCenterY - (LocalNewViewHeightIm / 2.0);
  PendingMouseX := clickX;
  PendingMouseY := clickY;
  PendingZoom := True;
  PendingReset := False;
END;

PROCEDURE ApplyPendingViewChanges;
BEGIN
  IF RenderInProgress THEN BEGIN
    IF PendingReset OR PendingZoom THEN
      RequestRenderCancellation;
    EXIT;
  END;

  IF PendingReset THEN BEGIN
    ResetViewToInitial;
    RedrawNeeded := True;
    IF NOT MinimalConsoleOutput THEN BEGIN
      GotoXY(1,StatusLineY); ClrEol; Write('Resetting view...');
    END;
    PendingReset := False;
    PendingZoom := False;
  END ELSE IF PendingZoom THEN BEGIN
    MinRe := PendingMinRe;
    MaxRe := PendingMaxRe;
    MinIm := PendingMinIm;
    UpdateScalingAndDependentViewParams;
    RedrawNeeded := True;
    IF NOT MinimalConsoleOutput THEN BEGIN
      GotoXY(1,StatusLineY); ClrEol; Write('Zooming... Click @ (', PendingMouseX, ',', PendingMouseY, ')');
    END;
    PendingZoom := False;
  END;
END;

PROCEDURE ProcessInput;
VAR
  KeyCode: Integer;
BEGIN
  KeyCode := PollKeyAny();
  WHILE KeyCode <> 0 DO BEGIN
    IF (KeyCode >= 0) AND (KeyCode <= $FF) THEN BEGIN
      IF UpCase(Chr(KeyCode)) = 'Q' THEN BEGIN
        QuitProgram := True;
        BREAK;
      END;
    END;
    KeyCode := PollKeyAny();
  END;

  IF QuitRequested THEN QuitProgram := True;

  IF QuitProgram AND RenderInProgress THEN
    RequestRenderCancellation;

  GetMouseState(MouseX, MouseY, MouseButtons);
  IF ((MouseButtons AND ButtonLeft) <> 0) AND ((PrevMouseButtons AND ButtonLeft) = 0) THEN BEGIN
    ScheduleZoomRequest(MouseX, MouseY);
  END ELSE IF ((MouseButtons AND ButtonRight) <> 0) AND ((PrevMouseButtons AND ButtonRight) = 0) THEN BEGIN
    PendingReset := True;
    PendingZoom := False;
  END;
  PrevMouseButtons := MouseButtons;

  ApplyPendingViewChanges;
END;

PROCEDURE FillPixelDataAndDisplayProgressively;
  VAR i, startY, endY, y, displayedRows : Integer;
      copied : Boolean;
      Cancelled : Boolean;
BEGIN
  endy := 0;
  RenderInProgress := True;
  RedrawNeeded := False;
  ClearRenderCancellation;
  IF NOT MinimalConsoleOutput THEN BEGIN
    GotoXY(1, StatusLineY); ClrEol; Write('Calculating and rendering progressively...');
  END;

  EnsurePixelBuffersSized;
  ResetRowState;
  // Use strided row assignment so expensive center rows are shared across
  // workers instead of bunching into one contiguous range.
  FOR i := 0 TO ThreadCount - 1 DO BEGIN
    startY := i;
    endY := ViewPixelHeight - 1;
    PublishWork(i, startY, endY, ThreadCount);
  END;

  displayedRows := 0;
  Cancelled := False;
  WHILE (displayedRows < ViewPixelHeight) AND (NOT QuitProgram) DO BEGIN
    ProcessInput;
    IF QuitProgram THEN BREAK;

    IF RenderCancellationRequested THEN BEGIN
      Cancelled := True;
      BREAK;
    END;

    copied := False;
    // Workers write directly into DisplayPixelData. We only claim rows here
    // for progress tracking and texture upload cadence.
    FOR y := 0 TO ViewPixelHeight - 1 DO BEGIN
      IF TryClaimRowCopy(y) THEN BEGIN
        copied := True;
        displayedRows := displayedRows + 1;
      END;
    END;
    IF copied THEN BEGIN
      PercentDone := Trunc( displayedRows * 100.0 / ViewPixelHeight );
      IF NOT MinimalConsoleOutput THEN BEGIN
        GotoXY(1, StatusLineY); ClrEol; Write('Processing: Row ', displayedRows, '/', ViewPixelHeight, '. ~', PercentDone, '%');
      END;
      IF ((displayedRows MOD MandelTextureUpdateIntervalRows = 0) OR (displayedRows = ViewPixelHeight)) THEN
        UpdateAndDisplayTextureInProgress;
    END ELSE BEGIN
      GraphLoop(0);
    END;

    ProcessInput;
  END;

  FOR i := 0 TO ThreadCount - 1 DO
    WHILE WorkerBusy(i) DO Delay(0);

  IF NOT QuitProgram THEN BEGIN
    IF Cancelled THEN BEGIN
      IF NOT MinimalConsoleOutput THEN BEGIN
        GotoXY(1, StatusLineY); ClrEol; Write('Render cancelled. Waiting for new view...');
      END;
    END ELSE BEGIN
      // Make sure the final frame is copied to the SDL texture and shown.
      // Without this call, the window may stay black once rendering finishes
      // because the last few rows might not yet have been uploaded to the GPU
      // when the worker threads complete.
      UpdateAndDisplayTextureInProgress;

      IF NOT MinimalConsoleOutput THEN BEGIN
        GotoXY(1, StatusLineY); ClrEol; Write('Render complete. Click, R-Click, or Q.');
      END;
    END;
  END;
  RenderInProgress := False;
  ClearRenderCancellation;
  ApplyPendingViewChanges;
END;

BEGIN // Main Program
  MandelWindowWidth := DefaultMandelWindowWidth;
  MandelWindowHeight := DefaultMandelWindowHeight;
  MinimalConsoleOutput := ResolveMinimalConsoleOutput;
  IF NOT MinimalConsoleOutput THEN BEGIN
    HideCursor; ClrScr;
    GotoXY(1, 1); Write('Pscal Texture Mandelbrot (Extended Builtin)');
    GotoXY(1, ControlsStartY);     Write('Controls:');
    GotoXY(1, ControlsStartY + 1); Write('- LClick: Zoom In');
    GotoXY(1, ControlsStartY + 2); Write('- RClick: Reset View');
    GotoXY(1, ControlsStartY + 3); Write('- Q Key (in terminal): Quit');
    GotoXY(1, ControlsStartY + 5); Write('----------------------------------------------------------');
  END;

  IF NOT HasExtBuiltin('math', 'MandelbrotRow') THEN BEGIN
    GotoXY(1, StatusLineY); ClrEol; Write('Error: MandelbrotRow extended builtin unavailable.');
    GotoXY(1, StatusLineY + 1); ClrEol; Write('Rebuild with -DENABLE_EXT_BUILTIN_MATH=ON to enable it.');
    NormVideo; ShowCursor; WriteLn; HALT;
  END;

  InitGraph(MandelWindowWidth, MandelWindowHeight, MandelWindowTitle);
  RefreshWindowDimensionsFromScreen;
  MandelTextureID := CreateTexture(MandelWindowWidth, MandelWindowHeight);
  IF MandelTextureID < 0 THEN
  BEGIN
    GotoXY(1, StatusLineY);
    WriteLn('Error: No Texture! Halting.');
    ReadKey;
    CloseGraph;
    NormVideo;
    ShowCursor;
    HALT;
  END;

  RowMutex := mutex();
  WorkMutex := mutex();
  CancelMutex := mutex();
  CancelRender := False;
  ConfigureWorkerArrays;

  BaseIterations := DefaultBaseIterations;
  ResetViewToInitial; // Sets MinRe,MaxRe,MinIm to defaults AND calculates scales/MaxIm
  ConfigureAdaptiveIterations;

  SetWorkerShutdown(False);
  ClearWorkerAssignments;
  FOR i := 0 TO ThreadCount - 1 DO
    SpawnWorker(i);

  RedrawNeeded := True;
  QuitProgram  := False;
  PrevMouseButtons := 0;
  RenderInProgress := False;
  PendingZoom := False;
  PendingReset := False;

  WHILE NOT QuitProgram DO BEGIN
    ProcessInput;
    IF QuitProgram THEN BREAK;

    IF RedrawNeeded THEN BEGIN
      FillPixelDataAndDisplayProgressively;
    END ELSE BEGIN // If not redrawing, ensure screen is still updated and events processed
      ClearDevice; RenderCopy(MandelTextureID); UpdateScreen;
      GraphLoop(20);
      ProcessInput;
      IF QuitProgram THEN BREAK;
    END;
  END; // WHILE

  SetWorkerShutdown(True);
  FOR i := 0 TO ThreadCount - 1 DO
    IF RenderThreadIDs[i] >= 0 THEN
      WaitForThread(RenderThreadIDs[i]);

  DestroyTexture(MandelTextureID); CloseGraph;
  destroy(RowMutex);
  destroy(WorkMutex);
  destroy(CancelMutex);
  IF NOT MinimalConsoleOutput THEN BEGIN
    GotoXY(1, StatusLineY + 8);
    ClrEol;
  END;
  NormVideo;
  ShowCursor;
  WriteLn;
  IF NOT MinimalConsoleOutput THEN
    WriteLn('Program terminated.');
END.
