#!/usr/bin/env pascal
PROGRAM SDLPlasmaRGB;

// USES System; // Implicit for Sin, Sqrt, Trunc if not global

CONST
  WindowWidth        = 1024;
  WindowHeight       = 768;
  WindowTitle        = 'TrueColor Plasma Effect (SDL)';
  Pi                 = 3.1415926535; // For sinusoidal color mapping
  UpdateIntervalRows = 8;            // Update window every N rows
  BytesPerPixel      = 4;
  TextureBufferSize  = WindowWidth * WindowHeight * BytesPerPixel;

TYPE
  PixelBuffer = ARRAY[0..TextureBufferSize - 1] OF Byte;

VAR
  Row, Col            : Integer;
  x, y                : Real;
  val1, val2, val3, plasmaValue : Real; // plasmaValue will be in range -1 to 1
  R, G, B             : Byte; // For R, G, B color components (0-255)
  InvWidth, InvHeight : Real;
  CurrentMaxX, CurrentMaxY : Integer;
  ViewPixelWidth, ViewPixelHeight : Integer;
  TimeOffset          : Real; // For animating the plasma (optional, starting static)
  TextureID           : Integer;
  PixelData           : PixelBuffer;
  BufferBaseIdx       : Integer;
  TotalBufferElements : Integer;
  BufferIndex         : Integer;
  QuitNow             : Boolean;
  KeyCode             : Integer;

BEGIN
  InitGraph(WindowWidth, WindowHeight, WindowTitle);
  ClearDevice;
  UpdateScreen;
  GraphLoop(0);

  CurrentMaxX := GetMaxX;
  CurrentMaxY := GetMaxY;
  ViewPixelWidth  := CurrentMaxX + 1;
  ViewPixelHeight := CurrentMaxY + 1;

  IF (ViewPixelWidth > WindowWidth) OR (ViewPixelHeight > WindowHeight) THEN
  BEGIN
    WriteLn('Error: window dimensions exceed allocated texture buffer.');
    CloseGraph;
    Halt;
  END;

  IF (CurrentMaxX + 1) > 0 THEN InvWidth  := 1.0 / (CurrentMaxX + 1) ELSE InvWidth  := 0;
  IF (CurrentMaxY + 1) > 0 THEN InvHeight := 1.0 / (CurrentMaxY + 1) ELSE InvHeight := 0;

  TimeOffset := 0.0; // Start with no animation
  writeln('Rendering RGB plasma...');

  TextureID := CreateTexture(ViewPixelWidth, ViewPixelHeight);
  IF TextureID < 0 THEN
  BEGIN
    WriteLn('Error: unable to create SDL texture for plasma rendering.');
    CloseGraph;
    Halt;
  END;

  TotalBufferElements := TextureBufferSize;
  FOR BufferIndex := 0 TO TotalBufferElements - 1 DO
    PixelData[BufferIndex] := 0;

  QuitNow := False;

  FOR Row := 0 TO ViewPixelHeight - 1 DO
  BEGIN
    FOR Col := 0 TO ViewPixelWidth - 1 DO
    BEGIN
      // Scale coordinates and add time for animation (optional)
      // Experiment with these scaling factors for different plasma looks
      x := Col * InvWidth * 10.0;  // Controls horizontal frequency/stretch
      y := Row * InvHeight * 5.0; // Controls vertical frequency/stretch

      // Plasma calculation - combine multiple sine waves
      // The TimeOffset can be incremented in an outer loop for animation
      val1 := Sin(x + TimeOffset);
      val2 := Sin(y / 2.0 - TimeOffset / 2.0); // Different frequency/phase for y
      val3 := Sin(Sqrt( (x - (CurrentMaxX/2)*InvWidth*10.0) * (x - (CurrentMaxX/2)*InvWidth*10.0) +
                       (y - (CurrentMaxY/2)*InvHeight*5.0) * (y - (CurrentMaxY/2)*InvHeight*5.0) ) / 4.0 + TimeOffset); // Radial wave from center

      // Combine waves. The result will be roughly in -3 to +3. Normalize to -1 to +1.
      plasmaValue := (val1 + val2 + val3) / 3.0;

      // Map plasmaValue (-1 to 1) to R, G, B components (0 to 255) using phase-shifted sines
      // (plasmaValue + 1.0) / 2.0 maps it to 0..1 range
      // Then Sin wave for color, Pi * value maps 0..1 to 0..Pi (half a sine wave)
      // We scale and shift Sin output (-1..1) to 0..255

      R := byte(Trunc( (Sin( Pi * ( (plasmaValue + 1.0) / 2.0 )                  ) + 1.0) * 127.5 ));
      G := byte(Trunc( (Sin( Pi * ( (plasmaValue + 1.0) / 2.0 ) + 2.0 * Pi / 3.0 ) + 1.0) * 127.5 )); // Phase shift G by 2*Pi/3
      B := byte(Trunc( (Sin( Pi * ( (plasmaValue + 1.0) / 2.0 ) + 4.0 * Pi / 3.0 ) + 1.0) * 127.5 )); // Phase shift B by 4*Pi/3

      // Clamp values just in case (though Trunc usually handles it if input to Sin is bounded)
      IF R < 0 THEN R := 0 ELSE IF R > 255 THEN R := 255;
      IF G < 0 THEN G := 0 ELSE IF G > 255 THEN G := 255;
      IF B < 0 THEN B := 0 ELSE IF B > 255 THEN B := 255;

      BufferBaseIdx := (Row * ViewPixelWidth + Col) * BytesPerPixel;
      PixelData[BufferBaseIdx + 0] := R;
      PixelData[BufferBaseIdx + 1] := G;
      PixelData[BufferBaseIdx + 2] := B;
      PixelData[BufferBaseIdx + 3] := Byte(255);
    END;

    // Periodically update the screen so the window shows progress while rendering
    IF ((Row + 1) MOD UpdateIntervalRows = 0) OR (Row = ViewPixelHeight - 1) THEN
    BEGIN
      UpdateTexture(TextureID, PixelData);
      ClearDevice;
      RenderCopy(TextureID);
      UpdateScreen;
      GraphLoop(0); // Pump events so the OS keeps the window responsive

      IF QuitRequested() THEN
      BEGIN
        QuitNow := True;
        BREAK;
      END;
    END;
    IF QuitNow THEN
      BREAK;
  END;

  IF QuitNow THEN
    WriteLn('Quit requested while rendering. Displaying last computed frame...')
  ELSE
  BEGIN
    UpdateTexture(TextureID, PixelData);
    ClearDevice;
    RenderCopy(TextureID);
    UpdateScreen;
  END;

  // Wait for key press or quit request
  IF QuitNow THEN
    WriteLn('Press any key or close the window to exit.')
  ELSE
    WriteLn('RGB Plasma complete. Press any key or close the window to exit.');

  KeyCode := 0;
  REPEAT
    GraphLoop(16);
    KeyCode := PollKey();
  UNTIL (KeyCode <> 0) OR QuitRequested();

  DestroyTexture(TextureID);
  CloseGraph;
END.
