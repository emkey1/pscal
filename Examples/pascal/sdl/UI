#!/usr/bin/env pascal
program UI_Demo;

uses
  CRT;      { For ReadKey, KeyPressed }

const
  PixelWidth = 640;
  PixelHeight = 480;
  DefaultFont = '/usr/local/pscal/fonts/Roboto/static/Roboto-Regular.ttf';
  FontSize = 14;

type
  { --- 1. Define the Interface --- }
  IComponent = interface
    procedure Draw;
    function HandleKey(key: char): boolean;
  end;

  { --- 2. Define the Closure (Procedure Pointer) Type --- }
  TNotifyEvent = procedure();

  { --- 3. Define the Label Record (PulsingLights-style) --- }
  PLabel = ^TLabel;
  TLabel = record
    X, Y: integer;
    Caption: string;
    procedure Draw; virtual;
    function HandleKey(key: char): boolean; virtual;
  end;

  { --- 4. Define the Button Record (PulsingLights-style) --- }
  PButton = ^TButton;
  TButton = record
    X, Y, W, H: integer;
    Caption: string;
    IsFocused: boolean;
    OnClick: TNotifyEvent; { Stores the closure }
    procedure Draw; virtual;
    function HandleKey(key: char): boolean; virtual;
  end;

var
  Components: array of IComponent; { Dynamic array of interfaces }
  lblInfo: PLabel;  { Pointer to the record }
  btn1, btn2: PButton; { Pointers to the records }
  key: char;
  i: integer;
  counter: integer; { This will be 'captured' by the closure }

{ --- Label Implementation --- }

procedure TLabel.Draw;
var
  self: PLabel;
begin
  self := myself; { Use 'myself' to get self-reference }
  SetRGBColor(255, 255, 255); { White text }
  OutTextXY(self^.X, self^.Y, self^.Caption);
end;

function TLabel.HandleKey(key: char): boolean;
begin
  Result := False; { Labels don't handle input }
end;

{ --- Button Implementation --- }

procedure TButton.Draw;
var
  self: PButton;
begin
  self := myself; { Use 'myself' to get self-reference }
  
  if self^.IsFocused then
    SetRGBColor(0, 150, 255) { Blue if focused }
  else
    SetRGBColor(100, 100, 100); { Gray if not }
  
  FillRect(self^.X, self^.Y, self^.W, self^.H);

  SetRGBColor(0, 0, 0); { Black text }
  OutTextXY(self^.X + 10, self^.Y + (self^.H div 2) - (FontSize div 2), self^.Caption);
end;

function TButton.HandleKey(key: char): boolean;
var
  self: PButton;
begin
  self := myself; { Use 'myself' to get self-reference }
  Result := False;
  
  if self^.IsFocused then
  begin
    if (key = #13) or (key = #10) then { Enter key }
    begin
      if self^.OnClick <> nil then
        self^.OnClick(); { <-- Execute the closure! }
      Result := True;
    end;
  end;
end;

{ --- Closures (These are nested in main and capture outer 'var's) --- }

procedure HandleButton1Click;
begin
  counter := counter + 1;
  { Use built-in IntToStr }
  lblInfo^.Caption := 'Button 1 clicked ' + IntToStr(counter) + ' times!';
end;

procedure HandleButton2Click;
begin
  lblInfo^.Caption := 'Button 2 clicked! Resetting count.';
  counter := 0;
end;


{ --- MAIN PROGRAM --- }
begin
  { Use the 2D+Text pipeline }
  InitGraph(PixelWidth, PixelHeight, 'Closure & Interface Demo');
  InitTextSystem(DefaultFont, FontSize);

  counter := 0;
  
  { Allocate Records on the heap using New() }
  New(lblInfo);
  New(btn1);
  New(btn2);

  { Init Label }
  lblInfo^.X := 10;
  lblInfo^.Y := 10;
  lblInfo^.Caption := 'Press Tab to focus, Enter to click. ESC to exit.';

  { Init Button 1 }
  btn1^.X := 10; btn1^.Y := 40; btn1^.W := 150; btn1^.H := 30;
  btn1^.Caption := 'Click Me';
  btn1^.IsFocused := True; { Start focused }
  btn1^.OnClick := @HandleButton1Click; { <-- Assign the closure }

  { Init Button 2 }
  btn2^.X := 10; btn2^.Y := 80; btn2^.W := 150; btn2^.H := 30;
  btn2^.Caption := 'Reset Count';
  btn2^.IsFocused := False;
  btn2^.OnClick := @HandleButton2Click; { <-- Assign the closure }

  { Populate Component List (Casting record POINTERS to interfaces) }
  SetLength(Components, 3);
  Components[0] := IComponent(lblInfo); { <-- This is the 'PulsingLights' pattern }
  Components[1] := IComponent(btn1);
  Components[2] := IComponent(btn2);

  { Main Loop }
  repeat
    SetRGBColor(0, 0, 0); 
    FillRect(0, 0, PixelWidth, PixelHeight);

    { Draw all components via interface dispatch }
    for i := 0 to High(Components) do
      Components[i].Draw;
    
    UpdateScreen;

    { Handle Input }
    key := ReadKey;
    if key = #9 then { Tab Key }
    begin
      { Simple focus toggle }
      btn1^.IsFocused := not btn1^.IsFocused;
      btn2^.IsFocused := not btn2^.IsFocused;
    end
    else
    begin
      { Pass key to focused button }
      if btn1^.IsFocused then
        btn1^.HandleKey(key)
      else if btn2^.IsFocused then
        btn2^.HandleKey(key);
    end;
    
  until key = #27; { ESC key }

  { Cleanup }
  CloseGraph;
  Dispose(lblInfo);
  Dispose(btn1);
  Dispose(btn2);
end.
