program ScreenFillingMazeSDL;

uses
  CRT; { For KeyPressed/ReadKey }

const
  MaxMazeWidth = 400;
  MaxMazeHeight = 160;
  MaxCellsWidth = 198;
  MaxCellsHeight = 78;
  MazeBufferSize = MaxMazeWidth * MaxMazeHeight;
  VisitBufferSize = MaxCellsWidth * MaxCellsHeight;
  
  { Original Box-drawing characters (kept for WallGlyph logic) }
  CornerTL = '╔';
  CornerTR = '╗';
  CornerBL = '╚';
  CornerBR = '╝';
  LineH = '═';
  LineV = '║';
  LineCross = '╬';
  TeeDown = '╦';
  TeeUp = '╩';
  TeeLeft = '╠';
  TeeRight = '╣';

  { Graphics Constants }
  CellSize = 8; { 8x8 pixels per maze cell }
  //DefaultFont = '@PSCAL_INSTALL_ROOT_RESOLVED@/fonts/Roboto/static/Roboto-Regular.ttf';
  DefaultFont = '/usr/local/pscal/fonts/Roboto/static/Roboto-Regular.ttf';
  //DefaultFont = 'font.ttf'; { Assumed font for InitTextSystem }
  FontSize = 14;

type
  TCellChar = string[4];
  TMazeGrid = array[0..MazeBufferSize - 1] of TCellChar;
  TVisitGrid = array[0..VisitBufferSize - 1] of boolean;
  TDirArray = array[0..3] of integer;
  TCellArray = array[0..VisitBufferSize - 1] of integer;
  TMaskGrid = array[0..MazeBufferSize - 1] of boolean;

var
  Maze: TMazeGrid;
  Visited: TVisitGrid;
  MazeWidth, MazeHeight: integer;
  CellsWidth, CellsHeight: integer;
  EntryCol, ExitCol: integer;
  SolutionMask: TMaskGrid;
  PixelWidth, PixelHeight: integer; { For SDL window size }

function MazeIndex(row, col: integer): integer;
begin
  Result := row * MazeWidth + col;
end;

function VisitIndex(row, col: integer): integer;
begin
  Result := row * CellsWidth + col;
end;

procedure PutCell(row, col: integer; ch: TCellChar);
begin
  if (row >= 0) and (row < MazeHeight) and (col >= 0) and (col < MazeWidth) then
    Maze[MazeIndex(row, col)] := ch;
end;

function CellAt(row, col: integer): TCellChar;
begin
  Result := Maze[MazeIndex(row, col)];
end;

function IsWallCell(row, col: integer): boolean;
begin
  Result := CellAt(row, col) <> ' ';
end;

function HasWallAt(row, col: integer): boolean;
begin
  if (row < 0) or (row >= MazeHeight) or (col < 0) or (col >= MazeWidth) then
  begin
    Result := False;
    Exit;
  end;
  Result := IsWallCell(row, col);
end;

procedure MarkVisited(row, col: integer);
begin
  Visited[VisitIndex(row, col)] := True;
end;

function IsVisited(row, col: integer): boolean;
begin
  Result := Visited[VisitIndex(row, col)];
end;

procedure ResetVisited;
var
  i: integer;
begin
  for i := 0 to VisitBufferSize - 1 do
    Visited[i] := False;
end;

procedure ClearSolutionMask;
var
  i: integer;
begin
  for i := 0 to MazeBufferSize - 1 do
    SolutionMask[i] := False;
end;

procedure ClampDimensions;
begin
  { --- MODIFIED ---
    Instead of using ScreenCols/ScreenRows, we'll set a fixed
    cell count for our SDL window.
  }
  CellsWidth := 80;
  CellsHeight := 60;
  
  { Calculate maze grid dimensions based on cell count }
  MazeWidth := (CellsWidth * 2) + 1;
  MazeHeight := (CellsHeight * 2) + 1;

  { Keep the original safety checks against max buffer size }
  if MazeWidth > MaxMazeWidth then MazeWidth := MaxMazeWidth;
  if MazeHeight > MaxMazeHeight then MazeHeight := MaxMazeHeight;
  if CellsWidth > MaxCellsWidth then CellsWidth := MaxCellsWidth;
  if CellsHeight > MaxCellsHeight then CellsHeight := MaxCellsHeight;

  if MazeWidth < 3 then MazeWidth := 3;
  if MazeHeight < 3 then MazeHeight := 3;
  if CellsWidth < 1 then CellsWidth := 1;
  if CellsHeight < 1 then CellsHeight := 1;
end;

procedure InitializeMaze;
var
  i: integer;
  r, c: integer;
begin
  for i := 0 to MazeBufferSize - 1 do
    Maze[i] := ' ';

  for r := 0 to MazeHeight - 1 do
    for c := 0 to MazeWidth - 1 do
    begin
      if r = 0 then
      begin
        if c = 0 then
          PutCell(r, c, CornerTL)
        else if c = MazeWidth - 1 then
          PutCell(r, c, CornerTR)
        else
          PutCell(r, c, LineH);
      end
      else if r = MazeHeight - 1 then
      begin
        if c = 0 then
          PutCell(r, c, CornerBL)
        else if c = MazeWidth - 1 then
          PutCell(r, c, CornerBR)
        else
          PutCell(r, c, LineH);
      end
      else if c = 0 then
        PutCell(r, c, LineV)
      else if c = MazeWidth - 1 then
        PutCell(r, c, LineV)
      else if (r mod 2 = 0) and (c mod 2 = 0) then
        PutCell(r, c, LineCross)
      else if (r mod 2 = 0) then
        PutCell(r, c, LineH)
      else if (c mod 2 = 0) then
        PutCell(r, c, LineV)
      else
        PutCell(r, c, ' ');
    end;
end;

{ --- INCLUDED: Original WallGlyph procedure --- }
function WallGlyph(connectUp, connectDown, connectLeft, connectRight: boolean): TCellChar;
var
  links: integer;
begin
  links := 0;
  if connectUp then Inc(links);
  if connectDown then Inc(links);
  if connectLeft then Inc(links);
  if connectRight then Inc(links);

  if links >= 4 then
  begin
    Result := LineCross;
    Exit;
  end;

  if links = 3 then
  begin
    if not connectUp then
    begin
      Result := TeeDown;
      Exit;
    end;
    if not connectDown then
    begin
      Result := TeeUp;
      Exit;
    end;
    if not connectLeft then
    begin
      Result := TeeLeft;
      Exit;
    end;
    Result := TeeRight;
    Exit;
  end;

  if links = 2 then
  begin
    if connectUp and connectDown then
    begin
      Result := LineV;
      Exit;
    end;
    if connectLeft and connectRight then
    begin
      Result := LineH;
      Exit;
    end;
    if connectUp and connectRight then
    begin
      Result := CornerBL;
      Exit;
    end;
    if connectUp and connectLeft then
    begin
      Result := CornerBR;
      Exit;
    end;
    if connectDown and connectRight then
    begin
      Result := CornerTL;
      Exit;
    end;
    if connectDown and connectLeft then
    begin
      Result := CornerTR;
      Exit;
    end;
  end;

  if links = 1 then
  begin
    if connectUp or connectDown then
    begin
      Result := LineV;
      Exit;
    end
    else
    begin
      Result := LineH;
      Exit;
    end;
  end;

  if links = 0 then
    Result := LineH
  else
    Result := LineCross;
end;

{ --- INCLUDED: Original PolishWalls procedure --- }
procedure PolishWalls;
var
  r, c: integer;
  up, down, leftConn, rightConn: boolean;
begin
  for r := 0 to MazeHeight - 1 do
    for c := 0 to MazeWidth - 1 do
      if IsWallCell(r, c) then
      begin
        up := HasWallAt(r - 1, c);
        down := HasWallAt(r + 1, c);
        leftConn := HasWallAt(r, c - 1);
        rightConn := HasWallAt(r, c + 1);
        PutCell(r, c, WallGlyph(up, down, leftConn, rightConn));
      end;
end;

{ --- INCLUDED: Original IsPassage procedure --- }
function IsPassage(row, col: integer): boolean;
begin
  if (row < 0) or (row >= MazeHeight) or (col < 0) or (col >= MazeWidth) then
  begin
    Result := False;
    Exit;
  end;
  Result := CellAt(row, col) = ' ';
end;

{ --- INCLUDED: Original SolveMaze procedure --- }
function SolveMaze: boolean;
type
  TIntArray = array[0..MazeBufferSize - 1] of integer;
  TBoolArray = array[0..MazeBufferSize - 1] of boolean;
const
  dRow: array[0..3] of integer = (-1, 1, 0, 0);
  dCol: array[0..3] of integer = (0, 0, -1, 1);
  QueueCapacity = MazeBufferSize;
var
  queueRow, queueCol: TIntArray;
  parent: TIntArray;
  visited: TBoolArray;
  head, tail: integer;
  startRow, startCol, goalRow, goalCol: integer;
  curRow, curCol, nextRow, nextCol: integer;
  curIdx, nextIdx: integer;
  found: boolean;
  i: integer;
begin
  ClearSolutionMask;
  for i := 0 to MazeBufferSize - 1 do
  begin
    parent[i] := -1;
    visited[i] := False;
  end;

  startCol := EntryCol;
  startRow := 1;
  if not IsPassage(startRow, startCol) then
    startRow := 0;
  if not IsPassage(startRow, startCol) then
  begin
    SolveMaze := False;
    Exit;
  end;

  goalCol := ExitCol;
  goalRow := MazeHeight - 2;
  if not IsPassage(goalRow, goalCol) then
    goalRow := MazeHeight - 1;
  if not IsPassage(goalRow, goalCol) then
  begin
    SolveMaze := False;
    Exit;
  end;

  head := 0;
  tail := 0;
  queueRow[tail] := startRow;
  queueCol[tail] := startCol;
  tail := (tail + 1) mod QueueCapacity;
  curIdx := MazeIndex(startRow, startCol);
  visited[curIdx] := True;

  found := False;
  while head <> tail do
  begin
    curRow := queueRow[head];
    curCol := queueCol[head];
    head := (head + 1) mod QueueCapacity;
    if (curRow = goalRow) and (curCol = goalCol) then
    begin
      found := True;
      Break;
    end;
    curIdx := MazeIndex(curRow, curCol);

    for i := 0 to 3 do
    begin
      nextRow := curRow + dRow[i];
      nextCol := curCol + dCol[i];
      if IsPassage(nextRow, nextCol) then
      begin
        nextIdx := MazeIndex(nextRow, nextCol);
        if not visited[nextIdx] then
        begin
          visited[nextIdx] := True;
          parent[nextIdx] := MazeIndex(curRow, curCol);
          queueRow[tail] := nextRow;
          queueCol[tail] := nextCol;
          tail := (tail + 1) mod QueueCapacity;
          if tail = head then
          begin
            found := False;
            Break;
          end;
        end;
      end;
    end;
    if not found and (tail = head) then
    begin
      { queue exhausted without reaching goal }
      Break;
    end;
  end;

  if not found then
  begin
    SolveMaze := False;
    Exit;
  end;

  nextIdx := MazeIndex(goalRow, goalCol);
  while nextIdx <> -1 do
  begin
    SolutionMask[nextIdx] := True;
    nextIdx := parent[nextIdx];
  end;
  SolutionMask[MazeIndex(0, EntryCol)] := True;
  SolutionMask[MazeIndex(MazeHeight - 1, ExitCol)] := True;
  SolveMaze := True;
end;

{ --- INCLUDED: Original Shuffle procedure --- }
procedure Shuffle(var arr: TDirArray);
var
  i, j, tmp: integer;
begin
  for i := High(arr) downto 1 do
  begin
    j := Random(i + 1);
    tmp := arr[i];
    arr[i] := arr[j];
    arr[j] := tmp;
  end;
end;

{ --- INCLUDED: Original GenerateMaze procedure --- }
procedure GenerateMaze(startRow, startCol: integer);
var
  stackRow, stackCol: TCellArray;
  top, row, col, i, nextRow, nextCol: integer;
  dirs: TDirArray;
  carved: boolean;
  cellRow, cellCol: integer;
begin
  top := 0;
  stackRow[top] := startRow;
  stackCol[top] := startCol;
  Inc(top);
  MarkVisited(startRow, startCol);
  cellRow := 1 + startRow * 2;
  cellCol := 1 + startCol * 2;
  PutCell(cellRow, cellCol, ' ');

  while top > 0 do
  begin
    row := stackRow[top - 1];
    col := stackCol[top - 1];
    cellRow := 1 + row * 2;
    cellCol := 1 + col * 2;

    dirs[0] := 0; dirs[1] := 1; dirs[2] := 2; dirs[3] := 3;
    Shuffle(dirs);
    carved := False;

    for i := 0 to 3 do
    begin
      nextRow := row;
      nextCol := col;
      case dirs[i] of
        0: Dec(nextRow);
        1: Inc(nextRow);
        2: Dec(nextCol);
        3: Inc(nextCol);
      end;

      if (nextRow >= 0) and (nextRow < CellsHeight) and
         (nextCol >= 0) and (nextCol < CellsWidth) and
         (not IsVisited(nextRow, nextCol)) then
      begin
        case dirs[i] of
          0: PutCell(cellRow - 1, cellCol, ' ');
          1: PutCell(cellRow + 1, cellCol, ' ');
          2: PutCell(cellRow, cellCol - 1, ' ');
          3: PutCell(cellRow, cellCol + 1, ' ');
        end;
        stackRow[top] := nextRow;
        stackCol[top] := nextCol;
        Inc(top);
        MarkVisited(nextRow, nextCol);
        cellRow := 1 + nextRow * 2;
        cellCol := 1 + nextCol * 2;
        PutCell(cellRow, cellCol, ' ');
        carved := True;
        Break;
      end;
    end;

    if not carved then
      Dec(top);
  end;
end;

{ --- INCLUDED: Original CarveEntranceAt procedure --- }
procedure CarveEntranceAt(rowTop: integer; col: integer);
begin
  if col < 1 then col := 1;
  if col > MazeWidth - 2 then col := MazeWidth - 2;

  PutCell(rowTop, col, ' ');
  if rowTop = 0 then
    PutCell(rowTop + 1, col, ' ')
  else
    PutCell(rowTop - 1, col, ' ');
end;

{ --- INCLUDED: Original CreateEntranceAndExit procedure --- }
procedure CreateEntranceAndExit;
begin
  EntryCol := 1 + (Random(CellsWidth) * 2);
  if EntryCol > MazeWidth - 2 then EntryCol := MazeWidth - 2;
  ExitCol := 1 + (Random(CellsWidth) * 2);
  if ExitCol > MazeWidth - 2 then ExitCol := MazeWidth - 2;

  CarveEntranceAt(0, EntryCol);
  CarveEntranceAt(MazeHeight - 1, ExitCol);
end;

{ --- INCLUDED: Original RestoreEntranceAndExit procedure --- }
procedure RestoreEntranceAndExit;
begin
  if (EntryCol >= 1) and (EntryCol <= MazeWidth - 2) then
    CarveEntranceAt(0, EntryCol);
  if (ExitCol >= 1) and (ExitCol <= MazeWidth - 2) then
    CarveEntranceAt(MazeHeight - 1, ExitCol);
end;

{ --- REWRITTEN: DrawMaze for SDL --- }
procedure DrawMaze(showSolution: boolean);
var
  r, c: integer;
  px, py: integer;
  idx: integer;
  prompt: string;
begin

  { 1. Clear the screen to black }
  GLColor3f(0.0, 0.0, 0.0);
  FillRect(0, 0, PixelWidth, PixelHeight);

  { 2. Iterate over the maze grid and draw rectangles }
  for r := 0 to MazeHeight - 1 do
  begin
    py := r * CellSize;
    for c := 0 to MazeWidth - 1 do
    begin
      px := c * CellSize;
      idx := MazeIndex(r, c);

      if showSolution and SolutionMask[idx] then
      begin
        { Draw solution path in green (0, 200, 0) }
        GLColor3f(0.0, 0.784, 0.0); { 200 / 255 = 0.784 }
        FillRect(px, py, CellSize, CellSize);
      end
      else if IsWallCell(r, c) then
      begin
        { Draw wall in light gray (200, 200, 200) }
        GLColor3f(0.784, 0.784, 0.784);
        FillRect(px, py, CellSize, CellSize);
      end;
      { else: It's a passage (' '), which we leave as black (background) }
    end;
  end;

  { 3. Draw the text prompt at the bottom of the window }
  SetRGBColor(255, 255, 255); { White text }
  if showSolution then
    prompt := 'Solution shown. Press any key to exit...'
  else
    prompt := 'Press ''s'' to show the solution, or any other key to exit...';
  
  OutTextXY(10, PixelHeight - (FontSize + 6), prompt);

  { 4. Flip the buffer to the screen }
  UpdateScreen;
end;

{ --- INCLUDED: Original FlushPendingKeys procedure --- }
procedure FlushPendingKeys;
begin
  while KeyPressed do
    ReadKey;
end;

{ --- INCLUDED: Original ReadCommandKey procedure --- }
function ReadCommandKey: char;
var
  key: char;
begin
  repeat
    key := ReadKey;
  until (key <> #10) and (key <> #13); { Filter out Enter key presses }
  ReadCommandKey := key;
end;

{ --- MAIN PROGRAM --- }
var
  startRow, startCol: integer;
  key: char;
  solved: boolean;
begin
  Randomize;
  
  { 1. Set up maze dimensions }
  ClampDimensions;
  
  { 2. Calculate pixel dimensions for SDL window }
  PixelWidth := MazeWidth * CellSize;
  { Add space at the bottom for the text prompt }
  PixelHeight := (MazeHeight * CellSize) + (FontSize * 2) + 12;

  { 3. Initialize SDL Graphics and Text }
  InitGraph(PixelWidth, PixelHeight, 'SDL Maze Generator');
  InitTextSystem(DefaultFont, FontSize);
  
  { 4. Generate the maze (this will work now) }
  InitializeMaze;
  ResetVisited;
  startRow := Random(CellsHeight);
  startCol := Random(CellsWidth);
  GenerateMaze(startRow, startCol); { <-- CRASH CULPRIT }
  CreateEntranceAndExit;
  
  { 5. Polish the walls for a cleaner look (optional but nice) }
  PolishWalls;
  RestoreEntranceAndExit;
  
  ClearSolutionMask;
  
  { 6. Draw the initial maze }
  DrawMaze(False);
  
  { 7. Handle input }
  key := ReadCommandKey;
  if (UpCase(key) = 'S') then
  begin
    solved := SolveMaze;
    if solved then
    begin
      DrawMaze(True);
      FlushPendingKeys;
      ReadKey;
    end
    else
    begin
      { Report the error using SDL text }
      SetRGBColor(255, 0, 0);
      OutTextXY(10, 10, 'Unable to solve maze.');
      UpdateScreen;
      FlushPendingKeys;
      ReadKey;
    end;
  end;
  
  { 8. Clean up SDL }
  CloseGraph;
end.
