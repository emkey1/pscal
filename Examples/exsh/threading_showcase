#!/usr/bin/env exsh
# Comprehensive thread helper demonstration for exsh.
#
# Usage:
#   build/bin/exsh Examples/exsh/threading_showcase [host ...]
#
# When no hostnames are provided the script resolves three defaults
# (localhost, example.com, and the intentionally failing invalid.invalid).
# The optional THREAD_SHOWCASE_DELAY_MS environment variable controls the
# delay submitted via the worker queue (defaults to 750 milliseconds).
#
# The demo exercises the following helpers:
#   * ThreadSpawnBuiltin – launch DNS lookups on background workers.
#   * ThreadPoolSubmit  – queue a delay without blocking the caller.
#   * ThreadSetName     – assign friendly names for easier diagnostics.
#   * ThreadLookup      – map thread names back to handles.
#   * WaitForThread     – join workers while checking their status codes.
#   * ThreadGetResult   – retrieve stored builtin results.
#   * ThreadGetStatus   – drop cached results/status flags so slots can reuse.
#   * ThreadStats       – emit a snapshot of the worker pool state at the end.
#
# Each log line is prefixed with "threading_showcase:" so automated tooling can
# scrape the transcript easily.

set -e
set -o pipefail

if [ "$#" -gt 0 ]; then
    : # Hosts supplied by the caller.
else
    set -- localhost example.com invalid.invalid
fi

DELAY_MS=${THREAD_SHOWCASE_DELAY_MS:-750}

# Accumulate thread metadata as "id|label|kind" tuples (newline separated).
THREAD_INFO=""

printf 'threading_showcase:start hosts=%s delay_ms=%s\n' "$*" "$DELAY_MS"

for host in "$@"; do
    tid=$(builtin ThreadSpawnBuiltin str:dnslookup "str:$host")
    label="dns:$host"
    # Naming threads keeps ThreadStats/ThreadLookup output legible.
    if builtin ThreadSetName "$tid" "str:$label" >/dev/null 2>&1; then
        printf 'threading_showcase:spawn:%s:%s\n' "$label" "$tid"
    else
        printf 'threading_showcase:spawn:%s:%s (name-pending)\n' "$label" "$tid"
    fi
    THREAD_INFO="${THREAD_INFO}${tid}|${label}|dns"$'\n'
done

# Try to queue the delay via ThreadPoolSubmit; fall back to ThreadSpawnBuiltin
# if the helper is unavailable in the current build.
if delay_tid=$(builtin ThreadPoolSubmit str:delay "int:$DELAY_MS" 2>/dev/null); then
    delay_kind=delay_queue
    printf 'threading_showcase:submit:delay:%sms:%s\n' "$DELAY_MS" "$delay_tid"
else
    delay_tid=$(builtin ThreadSpawnBuiltin str:delay "int:$DELAY_MS")
    delay_kind=delay_spawn
    printf 'threading_showcase:spawn:delay:%sms:%s\n' "$DELAY_MS" "$delay_tid"
fi

delay_label="delay:${DELAY_MS}ms"
builtin ThreadSetName "$delay_tid" "str:$delay_label" >/dev/null 2>&1 || true
THREAD_INFO="${THREAD_INFO}${delay_tid}|${delay_label}|${delay_kind}"$'\n'

# Demonstrate ThreadLookup for every recorded label.
while IFS='|' read -r tid label kind; do
    [ -z "$tid" ] && continue
    lookup=$(builtin ThreadLookup "str:$label" 2>/dev/null || printf '')
    if [ -n "$lookup" ]; then
        printf 'threading_showcase:lookup:%s:%s\n' "$label" "$lookup"
    else
        printf 'threading_showcase:lookup:%s:<not-found>\n' "$label"
    fi
done <<'INFO'
$THREAD_INFO
INFO

dns_counter=0
while IFS='|' read -r tid label kind; do
    [ -z "$tid" ] && continue
    if WaitForThread "$tid"; then
        join_status=$EXSH_LAST_STATUS
    else
        join_status=$EXSH_LAST_STATUS
    fi

    result_payload=""
    status_note=""

    case "$kind" in
        dns)
            dns_counter=$((dns_counter + 1))
            if [ "$dns_counter" -eq 1 ]; then
                # Two-step collection: read the value, then drop the cached state.
                result_payload=$(builtin ThreadGetResult "$tid")
                status_flag=$(builtin ThreadGetStatus "$tid" bool:true)
                status_note="status=$status_flag"
            else
                # Consume the status flag at the same time as the result.
                result_payload=$(builtin ThreadGetResult "$tid" bool:true)
                status_note="status via WaitForThread=$join_status"
            fi
            ;;
        delay_queue|delay_spawn)
            status_flag=$(builtin ThreadGetStatus "$tid" bool:true)
            status_note="status=$status_flag"
            result_payload="<void>"
            ;;
        *)
            status_flag=$(builtin ThreadGetStatus "$tid" bool:true)
            status_note="status=$status_flag"
            ;;
    esac

    if [ -z "$result_payload" ]; then
        result_payload="<empty>"
    fi

    printf 'threading_showcase:result:%s:join=%s %s value=%s\n' \
        "$label" "$join_status" "$status_note" "$result_payload"
done <<'INFO'
$THREAD_INFO
INFO

stats_output=$(builtin ThreadStats 2>/dev/null || printf '')
if [ -n "$stats_output" ]; then
    printf 'threading_showcase:stats:%s\n' "$stats_output"
else
    printf 'threading_showcase:stats:<empty>\n'
fi

printf 'threading_showcase:end\n'

