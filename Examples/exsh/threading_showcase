#!/usr/bin/env exsh
# Comprehensive thread helper demonstration for exsh.
#
# Usage:
#   build/bin/exsh Examples/exsh/threading_showcase [host ...]
#
# When no hostnames are provided the script resolves three defaults
# (localhost, example.com, and the intentionally failing invalid.invalid).
# The optional THREAD_SHOWCASE_DELAY_MS environment variable controls the
# delay submitted via the worker queue (defaults to 750 milliseconds).
#
# The demo exercises the following helpers:
#   * ThreadSpawnBuiltin – launch DNS lookups on background workers.
#   * ThreadPoolSubmit  – queue a delay without blocking the caller.
#   * ThreadSetName     – assign friendly names for easier diagnostics.
#   * ThreadLookup      – map thread names back to handles.
#   * WaitForThread     – join workers while checking their status codes.
#   * ThreadGetResult   – retrieve stored builtin results.
#   * ThreadGetStatus   – drop cached results/status flags so slots can reuse.
#   * ThreadStats       – emit a snapshot of the worker pool state at the end.
#
# Each log line is prefixed with "threading_showcase:" so automated tooling can
# scrape the transcript easily.

set -e
set -o pipefail

if [ "$#" -gt 0 ]; then
    : # Hosts supplied by the caller.
else
    set -- localhost example.com invalid.invalid
fi

DELAY_MS=${THREAD_SHOWCASE_DELAY_MS:-750}

# Accumulate thread metadata as "id|label|kind" tuples (newline separated).
# Using a temp file keeps the data accessible across multiple passes without
# relying on shell-specific newline handling quirks.
tmpdir=${TMPDIR:-/tmp}
if [ -z "$tmpdir" ]; then
    tmpdir=/tmp
fi
# macOS exposes TMPDIR with a trailing slash, so strip any suffix to avoid
# generating paths with a "//" sequence that some mktemp(1) builds reject.
# Preserve the root directory so we do not end up with an empty string when
# TMPDIR="/".
case "$tmpdir" in
    /) : ;;
    */) tmpdir=${tmpdir%/} ;;
esac

create_thread_info_file() {
    dir="$1"
    THREAD_INFO_FILE=""

    if [ ! -d "$dir" ] || [ ! -w "$dir" ]; then
        return
    fi

    mktemp_template="$dir/threading_showcase.XXXXXX"

    if THREAD_INFO_FILE=$(mktemp "$mktemp_template" 2>/dev/null); then
        :
    else
        if THREAD_INFO_FILE=$(TMPDIR="$dir" mktemp -t threading_showcase.XXXXXX 2>/dev/null); then
            :
        else
            THREAD_INFO_FILE=""
        fi
    fi

    if [ -n "$THREAD_INFO_FILE" ] && [ ! -e "$THREAD_INFO_FILE" ]; then
        if ! (umask 077 && : >"$THREAD_INFO_FILE") 2>/dev/null; then
            THREAD_INFO_FILE=""
        fi
    fi

    if [ -z "$THREAD_INFO_FILE" ]; then
        fallback_idx=0
        while [ "$fallback_idx" -lt 128 ]; do
            candidate="$dir/threading_showcase.$$.$fallback_idx"
            if (umask 077 && : >"$candidate") 2>/dev/null; then
                THREAD_INFO_FILE="$candidate"
                break
            fi
            fallback_idx=$((fallback_idx + 1))
        done
    fi
}

create_thread_info_file "$tmpdir"
if [ -z "$THREAD_INFO_FILE" ] && [ "$tmpdir" != "/tmp" ]; then
    # Some macOS configurations expose TMPDIR under a restricted path (e.g.,
    # `~/Library/Containers/...`) that rejects manual file creation even when
    # mktemp(1) succeeds. Retry under /tmp before surfacing an error.
    tmpdir=/tmp
    create_thread_info_file "$tmpdir"
fi

if [ -z "$THREAD_INFO_FILE" ]; then
    printf 'threading_showcase:error:mktemp_failed dir=%s\n' "$tmpdir" >&2
    exit 1
fi

trap 'rm -f "$THREAD_INFO_FILE"' EXIT INT TERM
record_thread_info() {
    printf '%s|%s|%s\n' "$1" "$2" "$3" >>"$THREAD_INFO_FILE"
}

printf 'threading_showcase:start hosts=%s delay_ms=%s\n' "$*" "$DELAY_MS"

for host in "$@"; do
    tid=$(builtin ThreadSpawnBuiltin str:dnslookup "str:$host")
    label="dns:$host"
    # Naming threads keeps ThreadStats/ThreadLookup output legible.
    if builtin ThreadSetName "$tid" "str:$label" >/dev/null 2>&1; then
        printf 'threading_showcase:spawn:%s:%s\n' "$label" "$tid"
    else
        printf 'threading_showcase:spawn:%s:%s (name-pending)\n' "$label" "$tid"
    fi
    record_thread_info "$tid" "$label" dns
done

# Try to queue the delay via ThreadPoolSubmit; fall back to ThreadSpawnBuiltin
# if the helper is unavailable in the current build.
if delay_tid=$(builtin ThreadPoolSubmit str:delay "int:$DELAY_MS" 2>/dev/null); then
    delay_kind=delay_queue
    printf 'threading_showcase:submit:delay:%sms:%s\n' "$DELAY_MS" "$delay_tid"
else
    delay_tid=$(builtin ThreadSpawnBuiltin str:delay "int:$DELAY_MS")
    delay_kind=delay_spawn
    printf 'threading_showcase:spawn:delay:%sms:%s\n' "$DELAY_MS" "$delay_tid"
fi

delay_label="delay:${DELAY_MS}ms"
builtin ThreadSetName "$delay_tid" "str:$delay_label" >/dev/null 2>&1 || true
record_thread_info "$delay_tid" "$delay_label" "$delay_kind"

# Demonstrate ThreadLookup for every recorded label.
while IFS='|' read -r tid label kind; do
    [ -z "$tid" ] && continue
    lookup=$(builtin ThreadLookup "str:$label" 2>/dev/null || printf '')
    if [ -n "$lookup" ]; then
        printf 'threading_showcase:lookup:%s:%s\n' "$label" "$lookup"
    else
        printf 'threading_showcase:lookup:%s:<not-found>\n' "$label"
    fi
done <"$THREAD_INFO_FILE"

dns_counter=0
while IFS='|' read -r tid label kind; do
    [ -z "$tid" ] && continue
    if WaitForThread "$tid"; then
        join_status=$EXSH_LAST_STATUS
    else
        join_status=$EXSH_LAST_STATUS
    fi

    result_payload=""
    status_note=""

    case "$kind" in
        dns)
            dns_counter=$((dns_counter + 1))
            if [ "$dns_counter" -eq 1 ]; then
                # Two-step collection: read the value, then drop the cached state.
                result_payload=$(builtin ThreadGetResult "$tid")
                status_flag=$(builtin ThreadGetStatus "$tid" bool:true)
                status_note="status=$status_flag"
            else
                # Consume the status flag at the same time as the result.
                result_payload=$(builtin ThreadGetResult "$tid" bool:true)
                status_note="status via WaitForThread=$join_status"
            fi
            ;;
        delay_queue|delay_spawn)
            status_flag=$(builtin ThreadGetStatus "$tid" bool:true)
            status_note="status=$status_flag"
            result_payload="<void>"
            ;;
        *)
            status_flag=$(builtin ThreadGetStatus "$tid" bool:true)
            status_note="status=$status_flag"
            ;;
    esac

    if [ -z "$result_payload" ]; then
        result_payload="<empty>"
    fi

    printf 'threading_showcase:result:%s:join=%s %s value=%s\n' \
        "$label" "$join_status" "$status_note" "$result_payload"
done <"$THREAD_INFO_FILE"

stats_output=$(builtin ThreadStatsJson 2>/dev/null || printf '')
if [ -n "$stats_output" ]; then
    printf 'threading_showcase:stats:%s\n' "$stats_output"
else
    printf 'threading_showcase:stats:[]\n'
fi

printf 'threading_showcase:end\n'

