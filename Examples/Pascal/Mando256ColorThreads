#!/usr/bin/env pascal
PROGRAM Mandelbrot256ColorThreads;

USES Crt;

CONST
  MaxIter         = 80;
  EscapeRadiusSq  = 4.0;
  MinX            = -2.0;
  MaxX            = 1.0;
  MinY            = -1.0;
  MaxY            = 1.0;
  InsideColorIndex = 16;
  PaletteSize     = 239;
  ThreadCount     = 4;
  MaxBufferCols   = 2048;
  MaxBufferRows   = 1536;

TYPE
  TRowRange = record
    StartRow: Integer;
    EndRow: Integer;
  end;
  PRowRange = ^TRowRange;

VAR
  Width, Height : Integer;
  ScaleX, ScaleY: Real;
  DrawChar      : Char;
  ColorBuffer   : array[1..MaxBufferRows, 1..MaxBufferCols] of Byte;
  ThreadHandles : array[0..ThreadCount - 1] of Integer;
  RowMutex      : Integer;
  NextRow       : Integer;
  ThreadingEnabled: Boolean;

PROCEDURE ComputeRow(Row: Integer);
VAR
  Col      : Integer;
  cx, cy   : Real;
  zx, zy   : Real;
  xTemp    : Real;
  iter     : Integer;
  ColorIndex: Byte;
BEGIN
  IF (Row < 1) OR (Row > Height) THEN
    EXIT;

  cy := MinY + Row * ScaleY;

  FOR Col := 1 TO Width DO
  BEGIN
    cx := MinX + Col * ScaleX;
    zx := 0.0;
    zy := 0.0;
    iter := 0;

    WHILE (iter < MaxIter) AND ((zx*zx + zy*zy) < EscapeRadiusSq) DO
    BEGIN
      xTemp := zx*zx - zy*zy + cx;
      zy := 2.0 * zx * zy + cy;
      zx := xTemp;
      iter := iter + 1;
    END;

    IF iter = MaxIter THEN
      ColorIndex := InsideColorIndex
    ELSE
      ColorIndex := Byte(16 + (iter MOD PaletteSize));

    ColorBuffer[Row, Col] := ColorIndex;
  END;
END;

PROCEDURE ComputeRowRange(startRow, endRow: Integer);
VAR
  Row: Integer;
BEGIN
  IF startRow < 1 THEN
    startRow := 1;
  IF endRow > Height THEN
    endRow := Height;
  IF endRow < startRow THEN
    EXIT;

  FOR Row := startRow TO endRow DO
    ComputeRow(Row);
END;

FUNCTION TryGetNextRow(VAR rowOut: Integer): Boolean;
BEGIN
  TryGetNextRow := FALSE;
  IF (NOT ThreadingEnabled) OR (RowMutex < 0) THEN
    EXIT;

  lock(RowMutex);
  IF NextRow <= Height THEN
  BEGIN
    rowOut := NextRow;
    NextRow := NextRow + 1;
    TryGetNextRow := TRUE;
  END;
  unlock(RowMutex);
END;

PROCEDURE ComputeRows(rangePtr: PRowRange);
VAR
  Row: Integer;
  startRow, endRow: Integer;
BEGIN
  IF rangePtr = NIL THEN
  BEGIN
    IF NOT ThreadingEnabled THEN
      EXIT;

    WHILE TryGetNextRow(Row) DO
      ComputeRow(Row);
    EXIT;
  END;

  startRow := rangePtr^.StartRow;
  endRow := rangePtr^.EndRow;

  ComputeRowRange(startRow, endRow);
END;

PROCEDURE SpawnThreads;
VAR
  i, handle: Integer;
  anyThread: Boolean;
BEGIN
  ThreadingEnabled := FALSE;
  RowMutex := mutex();
  IF RowMutex < 0 THEN
  BEGIN
    RowMutex := -1;
    FOR i := 0 TO ThreadCount - 1 DO
      ThreadHandles[i] := -1;
    EXIT;
  END;

  NextRow := 1;
  ThreadingEnabled := TRUE;
  anyThread := FALSE;

  FOR i := 0 TO ThreadCount - 1 DO
  BEGIN
    ThreadHandles[i] := -1;
    handle := CreateThread(@ComputeRows, NIL);
    IF handle >= 0 THEN
    BEGIN
      ThreadHandles[i] := handle;
      anyThread := TRUE;
    END;
  END;

  IF NOT anyThread THEN
  BEGIN
    ThreadingEnabled := FALSE;
    destroy(RowMutex);
    RowMutex := -1;
  END;
END;

PROCEDURE JoinThreads;
VAR
  i: Integer;
BEGIN
  FOR i := 0 TO ThreadCount - 1 DO
    IF ThreadHandles[i] >= 0 THEN
      WaitForThread(ThreadHandles[i]);

  IF RowMutex >= 0 THEN
  BEGIN
    destroy(RowMutex);
    RowMutex := -1;
  END;
  ThreadingEnabled := FALSE;
END;

PROCEDURE DisplayBuffer;
VAR
  Row, Col: Integer;
BEGIN
  FOR Row := 1 TO Height DO
  BEGIN
    GotoXY(1, Row);
    FOR Col := 1 TO Width DO
    BEGIN
      TextColorE(ColorBuffer[Row, Col]);
      Write(DrawChar);
    END;
  END;
END;

BEGIN
  Width := ScreenCols;
  Height := ScreenRows;

  ClrScr;

  IF ThreadCount <= 0 THEN
  BEGIN
    WriteLn('ThreadCount must be positive.');
    Write('Press any key to exit.');
    ReadKey;
    EXIT;
  END;

  IF (Width > MaxBufferCols) OR (Height > MaxBufferRows) THEN
  BEGIN
    WriteLn('Screen size ', Width, 'x', Height, ' exceeds supported buffer dimensions of ', MaxBufferCols, 'x', MaxBufferRows, '.');
    WriteLn('Please reduce the terminal size and rerun the program.');
    Write('Press any key to exit.');
    ReadKey;
    EXIT;
  END;

  WriteLn('Calculating Mandelbrot (', Width, 'x', Height, ') with 256 colors using ', ThreadCount, ' threads...');

  ScaleX := (MaxX - MinX) / Width;
  ScaleY := (MaxY - MinY) / Height;
  DrawChar := '#';

  SpawnThreads;
  IF ThreadingEnabled THEN
    ComputeRows(NIL)
  ELSE
    ComputeRowRange(1, Height);

  JoinThreads;

  DisplayBuffer;

  NormVideo;
  TextColor(LightGray);
  GotoXY(1, Height + 1);
  Write('Calculation complete. Press any key to exit.');
  ReadKey;
  WriteLn;
END.
