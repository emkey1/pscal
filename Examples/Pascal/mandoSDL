#!/usr/bin/env pascal
PROGRAM SDLMandelbrotWithStatus;

// USES System; // Implicit for Sqrt, Trunc, WriteLn etc. if not global

CONST
  WindowWidth   = 1024;
  WindowHeight  = 768;
  WindowTitle   = 'Mandelbrot Set (SDL)';
//  MaxIterations = 255;
  MaxIterations = 128;
  StatusUpdateInterval = 20; // Print status every 20 rows
  ScreenUpdateInterval = 1;  // Refresh SDL window every row

VAR
  Px, Py        : Integer; // Pixel coordinates
  x0, y0        : Real;    // Coordinates in the complex plane
  x, y          : Real;    // Current z value
  xTemp         : Real;
  Iteration     : Integer;
  R, G, B       : Byte;

  MinRe         : Real;
  MaxRe         : Real;
  MinIm         : Real;
  MaxIm         : Real;

  ReRange, ImRange : Real;
  ScaleRe, ScaleIm : Real;
  CurrentMaxX, CurrentMaxY : Integer;

  PercentDone : Integer;

BEGIN
  MinRe := -2.0;
  MaxRe := 1.0;
  MinIM := -1.2;

  // Initial message to the terminal
  WriteLn('Calculating Mandelbrot set for a ', WindowWidth, 'x', WindowHeight, ' window.');
  WriteLn('The graphics window will update as the calculation progresses.');
  WriteLn;
  WriteLn('Progress updates will be shown here in the terminal.');
  WriteLn('-----------------------------------------------------');
  // You could add a Delay(1000) here if you want users to definitely see the message

  InitGraph(WindowWidth, WindowHeight, WindowTitle);
  ClearDevice;  UpdateScreen;  // show blank window immediately

  CurrentMaxX := GetMaxX;
  CurrentMaxY := GetMaxY;

  ReRange := MaxRe - MinRe;
  MaxIm := MinIm + (ReRange * (CurrentMaxY + 1)) / (CurrentMaxX + 1);
  ImRange := MaxIm - MinIm;

  IF CurrentMaxX > 0 THEN ScaleRe := ReRange / CurrentMaxX ELSE ScaleRe := 0;
  IF CurrentMaxY > 0 THEN ScaleIm := ImRange / CurrentMaxY ELSE ScaleIm := 0;

  // Initialize progress tracking
  PercentDone := 0;

  // Main loop through each pixel
  FOR Py := 0 TO CurrentMaxY DO
  BEGIN
    y0 := MaxIm - (Py * ScaleIm);
    x0 := MinRe;
    FOR Px := 0 TO CurrentMaxX DO
    BEGIN

      x := 0.0;
      y := 0.0;
      Iteration := 0;

      WHILE (x*x + y*y <= 4.0) AND (Iteration < MaxIterations) DO
      BEGIN
        xTemp := x*x - y*y + x0;
        y     := 2*x*y + y0;
        x     := xTemp;
        Iteration := Iteration + 1;
      END;

      IF Iteration = MaxIterations THEN
      BEGIN
        R := 0; G := 0; B := 0;
      END
      ELSE
      BEGIN
        R := (Iteration * 5) MOD 256;
        G := (Iteration * 7 + 85) MOD 256;
        B := (Iteration * 11 + 170) MOD 256;
      END;

      SetRGBColor(R, G, B);
      PutPixel(Px, Py);

      x0 := x0 + ScaleRe;
    END; // END FOR Px

    // Status Update Logic
    // Py is 0-indexed, CurrentMaxY is max index. (CurrentMaxY + 1) is total rows.
    IF (Py + 1) MOD StatusUpdateInterval = 0 THEN // After every 'StatusUpdateInterval' rows
    BEGIN
        PercentDone := Trunc( (Py + 1) * 100.0 / (CurrentMaxY + 1) );
        WriteLn('Processing row ', Py + 1, ' of ', CurrentMaxY + 1, '. Approximately ', PercentDone, '% complete...');
    END
    ELSE IF Py = CurrentMaxY THEN // Ensure a 100% message on the last row if not caught by interval
    BEGIN
        WriteLn('Processing row ', Py + 1, ' of ', CurrentMaxY + 1, '. Approximately 100% complete...');
    END;

    // Periodic screen update so the window displays while calculating
    IF (Py + 1) MOD ScreenUpdateInterval = 0 THEN
    BEGIN
      UpdateScreen;
      GraphLoop(0);
    END;

  END; // END FOR Py

  WriteLn('-----------------------------------------------------');
  WriteLn('Calculation complete! Displaying Mandelbrot set.');

  UpdateScreen;

  // WriteLn('Mandelbrot set displayed. Press any key to exit.'); // Console message
  GraphLoop(100);
  ReadKey;

  CloseGraph;
END.
