#!/usr/bin/env pascal
program GalaxianClone;

const
  ScreenWidth  = 640;
  ScreenHeight = 480;
  PlayerSpeed  = 5;
  PlayerW      = 40;
  PlayerH      = 20;
  BulletW      = 4;
  BulletH      = 10;
  PlayerBulletSpeed = 8;
  EnemyRows    = 4;
  EnemyCols    = 6;
  MaxEnemies   = EnemyRows * EnemyCols;
  EnemyW       = 30;
  EnemyH       = 20;
  EnemyPaddingX = 10;
  EnemyPaddingY = 10;
  EnemyMoveDown = 10;
  EnemySpeed   = 2;
  MaxEnemyBullets = 5;
  EnemyBulletSpeed = 4;

  LeftKey  = 1073741904;
  RightKey = 1073741903;
  FireKey  = 32;

  ShotSoundFile    = '/usr/local/pscal/lib/sounds/paddle_hit.wav';
  ExplodeSoundFile = '/usr/local/pscal/lib/sounds/wall_hit.wav';

type
  PlayerType = record
    x, y  : integer;
    lives : integer;
    score : integer;
    laserActive : boolean;
  end;

  EnemyType = record
    x, y   : integer;
    active : boolean;
    diving : boolean;
  end;

  BulletType = record
    x, y   : integer;
    active : boolean;
  end;

  GameStateType = record
    level : integer;
    enemiesRemaining : integer;
    playing : boolean;
  end;

var
  player : PlayerType;
  enemies : array[1..MaxEnemies] of EnemyType;
  playerBullet : BulletType;
  enemyBullets : array[1..MaxEnemyBullets] of BulletType;
  game : GameStateType;
  AlienDir : integer;
  ShotSound, ExplodeSound : integer;

procedure InitGame;
var
  i, j, idx : integer;
begin
  InitGraph(ScreenWidth, ScreenHeight, 'Pascal Galaxian');
  InitSoundSystem;
  ShotSound := LoadSound(ShotSoundFile);
  ExplodeSound := LoadSound(ExplodeSoundFile);

  player.x := ScreenWidth div 2 - PlayerW div 2;
  player.y := ScreenHeight - PlayerH - 10;
  player.lives := 3;
  player.score := 0;
  player.laserActive := false;

  playerBullet.active := false;

  for i := 1 to MaxEnemyBullets do
    enemyBullets[i].active := false;

  idx := 1;
  for i := 0 to EnemyRows - 1 do
  begin
    for j := 0 to EnemyCols - 1 do
    begin
      enemies[idx].x := 50 + j * (EnemyW + EnemyPaddingX);
      enemies[idx].y := 50 + i * (EnemyH + EnemyPaddingY);
      enemies[idx].active := true;
      enemies[idx].diving := false;
      idx := idx + 1;
    end;
  end;

  game.level := 1;
  game.enemiesRemaining := MaxEnemies;
  game.playing := true;
  AlienDir := 1;
  Randomize;
end;

procedure HandleInput;
var
  key : integer;
begin
  key := PollKey;
  while key <> 0 do
  begin
    if key = LeftKey then
      player.x := player.x - PlayerSpeed
    else if key = RightKey then
      player.x := player.x + PlayerSpeed
    else if (key = FireKey) and (not player.laserActive) then
    begin
      player.laserActive := true;
      playerBullet.active := true;
      playerBullet.x := player.x + PlayerW div 2 - BulletW div 2;
      playerBullet.y := player.y - BulletH;
      if ShotSound <> -1 then PlaySound(ShotSound);
    end;
    key := PollKey;
  end;
  if player.x < 0 then player.x := 0;
  if player.x > ScreenWidth - PlayerW then player.x := ScreenWidth - PlayerW;
end;

procedure UpdatePlayerBullet;
begin
  if player.laserActive then
  begin
    playerBullet.y := playerBullet.y - PlayerBulletSpeed;
    if playerBullet.y < 0 then
    begin
      player.laserActive := false;
      playerBullet.active := false;
    end;
  end;
end;

procedure UpdateEnemyFormation;
var
  i : integer;
  minX, maxX : integer;
begin
  minX := ScreenWidth;
  maxX := 0;
  for i := 1 to MaxEnemies do
    if enemies[i].active and (not enemies[i].diving) then
    begin
      if enemies[i].x < minX then minX := enemies[i].x;
      if enemies[i].x + EnemyW > maxX then maxX := enemies[i].x + EnemyW;
    end;
  if (AlienDir = 1) and (maxX >= ScreenWidth - 10) then
  begin
    AlienDir := -1;
    for i := 1 to MaxEnemies do
      if enemies[i].active then enemies[i].y := enemies[i].y + EnemyMoveDown;
  end
  else if (AlienDir = -1) and (minX <= 10) then
  begin
    AlienDir := 1;
    for i := 1 to MaxEnemies do
      if enemies[i].active then enemies[i].y := enemies[i].y + EnemyMoveDown;
  end;
  for i := 1 to MaxEnemies do
    if enemies[i].active and (not enemies[i].diving) then
      enemies[i].x := enemies[i].x + AlienDir * EnemySpeed;
end;

procedure StartDivingEnemy;
var
  idx : integer;
begin
  idx := Random(MaxEnemies) + 1;
  if enemies[idx].active and (not enemies[idx].diving) then
    enemies[idx].diving := true;
end;

procedure UpdateDivingEnemies;
var
  i : integer;
begin
  for i := 1 to MaxEnemies do
    if enemies[i].active and enemies[i].diving then
    begin
      enemies[i].y := enemies[i].y + 4;
      if (enemies[i].y > ScreenHeight) then
      begin
        enemies[i].active := false;
        enemies[i].diving := false;
        game.enemiesRemaining := game.enemiesRemaining - 1;
      end
      else if (enemies[i].x < player.x + PlayerW) and
              (enemies[i].x + EnemyW > player.x) and
              (enemies[i].y < player.y + PlayerH) and
              (enemies[i].y + EnemyH > player.y) then
      begin
        enemies[i].active := false;
        enemies[i].diving := false;
        player.lives := player.lives - 1;
        game.enemiesRemaining := game.enemiesRemaining - 1;
      end;
    end;
end;

procedure FireEnemyBullet;
var
  idx, b : integer;
begin
  idx := Random(MaxEnemies) + 1;
  if enemies[idx].active then
  begin
    for b := 1 to MaxEnemyBullets do
      if not enemyBullets[b].active then
      begin
        enemyBullets[b].active := true;
        enemyBullets[b].x := enemies[idx].x + EnemyW div 2 - BulletW div 2;
        enemyBullets[b].y := enemies[idx].y + EnemyH;
        break;
      end;
  end;
end;

procedure UpdateEnemyBullets;
var
  b : integer;
begin
  for b := 1 to MaxEnemyBullets do
    if enemyBullets[b].active then
    begin
      enemyBullets[b].y := enemyBullets[b].y + EnemyBulletSpeed;
      if enemyBullets[b].y > ScreenHeight then
        enemyBullets[b].active := false
      else if (enemyBullets[b].x < player.x + PlayerW) and
              (enemyBullets[b].x + BulletW > player.x) and
              (enemyBullets[b].y < player.y + PlayerH) and
              (enemyBullets[b].y + BulletH > player.y) then
      begin
        enemyBullets[b].active := false;
        player.lives := player.lives - 1;
      end;
    end;
end;

procedure CheckPlayerBulletCollisions;
var
  i : integer;
begin
  if player.laserActive then
    for i := 1 to MaxEnemies do
      if enemies[i].active then
        if (playerBullet.x < enemies[i].x + EnemyW) and
           (playerBullet.x + BulletW > enemies[i].x) and
           (playerBullet.y < enemies[i].y + EnemyH) and
           (playerBullet.y + BulletH > enemies[i].y) then
        begin
          enemies[i].active := false;
          enemies[i].diving := false;
          player.laserActive := false;
          playerBullet.active := false;
          player.score := player.score + 10;
          game.enemiesRemaining := game.enemiesRemaining - 1;
          if ExplodeSound <> -1 then PlaySound(ExplodeSound);
          break;
        end;
end;

procedure Render;
var
  i, b : integer;
  scoreStr, livesStr : string;
begin
  ClearDevice;
  SetRGBColor(0, 255, 0);
  FillRect(player.x, player.y, PlayerW, PlayerH);
  if player.laserActive then
  begin
    SetRGBColor(255, 255, 0);
    FillRect(playerBullet.x, playerBullet.y, BulletW, BulletH);
  end;
  SetRGBColor(255, 0, 0);
  for i := 1 to MaxEnemies do
    if enemies[i].active then
      FillRect(enemies[i].x, enemies[i].y, EnemyW, EnemyH);
  SetRGBColor(255,255,255);
  for b := 1 to MaxEnemyBullets do
    if enemyBullets[b].active then
      FillRect(enemyBullets[b].x, enemyBullets[b].y, BulletW, BulletH);
  Str(player.score, scoreStr);
  Str(player.lives, livesStr);
  OutTextXY(10, 10, 'Score: ' + scoreStr + ' Lives: ' + livesStr);
  UpdateScreen;
end;

begin
  InitGame;
  while (not QuitRequested) and game.playing do
  begin
    GraphLoop(16);
    HandleInput;
    UpdatePlayerBullet;
    UpdateEnemyFormation;
    if Random(200) = 0 then StartDivingEnemy;
    UpdateDivingEnemies;
    if Random(100) = 0 then FireEnemyBullet;
    UpdateEnemyBullets;
    CheckPlayerBulletCollisions;
    if player.lives <= 0 then game.playing := false;
    if game.enemiesRemaining <= 0 then game.playing := false;
    Render;
  end;
  QuitSoundSystem;
  CloseGraph;
end.
