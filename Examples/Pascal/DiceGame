#!/usr/bin/env pascal
program DiceGame;

uses CRT;

const
  NUM_DICE = 5;
  MAX_ROLLS = 3;
  NUM_CATEGORIES = 13;
  // Game layout dimensions for centering
  GAME_WIDTH = 60;
  GAME_HEIGHT = 25;

  // Color constants
  Black        = 0;
  Blue         = 1;
  Green        = 2;
  Cyan         = 3;
  Red          = 4;
  LightGray    = 7;
  LightGreen   = 10;
  LightRed     = 12;
  Yellow       = 14;
  White        = 15;

type
  TDiceArray = array[1..NUM_DICE] of integer;
  TKeepArray = array[1..NUM_DICE] of boolean;

  TScoreCategory = record
    name: string[20];
    score: integer;
    used: boolean;
  end;
  TScorecard = array[1..NUM_CATEGORIES] of TScoreCategory;

var
  dice: TDiceArray;
  keep: TKeepArray;
  rollsLeft: integer;
  turn: integer;
  scorecard: TScorecard;
  i, j, upperScore, lowerScore, bonusScore, totalScore: integer;
  gameOver: boolean;
  inputChar: char;
  categoryChoice: integer;
  userChoice: char;
  turnStr: string[4];
  totalStr: string[4];
  scoreStr: string[4];
  k: integer;
  hOffset, vOffset: integer; // Offsets for centering the game

// --- Custom Screen Clearing Procedure ---
// This is a more reliable way to clear the screen with a specific background color.
procedure ClearScreenWithColor(bgColor: byte);
var
  y, x: integer;
  blankLine: string;
begin
//  TextBackground(bgColor);
//  blankLine := '';
  // Create a string of spaces that matches the screen width
//  for x := 1 to ScreenCols do
//  begin
//    blankLine := blankLine + ' ';
//  end;

  // Print the blank line on every row
//  for y := 1 to ScreenRows do
//  begin
//    GotoXY(1, y);
//    Write(blankLine);
//  end;
//  GotoXY(1, 1); // Move cursor to top-left after clearing
  ClrScr;
  writeln('\e]11;#000000\a');
end;

// --- CRT Helper Procedures (Now with Centering) ---

procedure Print(x, y: integer; s: string);
begin
  GotoXY(x + hOffset, y + vOffset);
  Write(s);
end;

procedure PrintColor(x, y: integer; s: string; fg, bg: byte);
begin
  TextColor(fg);
  TextBackground(bg);
  GotoXY(x + hOffset, y + vOffset);
  Write(s);
  NormVideo;
  TextBackground(Black); // Re-apply black background after NormVideo
end;

// --- Game Logic Procedures (Modified for Centering) ---

procedure InitializeScorecard;
begin
  scorecard[1].name := 'Ones';
  scorecard[2].name := 'Twos';
  scorecard[3].name := 'Threes';
  scorecard[4].name := 'Fours';
  scorecard[5].name := 'Fives';
  scorecard[6].name := 'Sixes';
  scorecard[7].name := '3 of a Kind';
  scorecard[8].name := '4 of a Kind';
  scorecard[9].name := 'Full House';
  scorecard[10].name := 'Sm Straight';
  scorecard[11].name := 'Lg Straight';
  scorecard[12].name := 'Shipzee';
  scorecard[13].name := 'Chance';

  for i := 1 to NUM_CATEGORIES do
  begin
    scorecard[i].score := 0;
    scorecard[i].used := false;
  end;
  upperScore := 0;
  lowerScore := 0;
  bonusScore := 0;
  totalScore := 0;
end;

procedure RollDice;
var
  i: integer;
begin
  for i := 1 to NUM_DICE do
  begin
    if not keep[i] then
    begin
      dice[i] := Random(6) + 1;
    end;
  end;
  rollsLeft := rollsLeft - 1;
end;

procedure DrawDie(x, y, value: integer; kept: boolean);
var
  bg: byte;
  pip: array[1..3, 1..3] of char;
  r, c: integer;
begin
  bg := LightGray;
  if kept then
    bg := LightGreen;
  for r := 1 to 3 do
    for c := 1 to 3 do
      pip[r, c] := ' ';
  case value of
    1: pip[2, 2] := 'o';
    2: begin pip[1, 1] := 'o'; pip[3, 3] := 'o'; end;
    3: begin pip[1, 1] := 'o'; pip[2, 2] := 'o'; pip[3, 3] := 'o'; end;
    4: begin pip[1, 1] := 'o'; pip[1, 3] := 'o'; pip[3, 1] := 'o'; pip[3, 3] := 'o'; end;
    5: begin pip[1, 1] := 'o'; pip[1, 3] := 'o'; pip[2, 2] := 'o'; pip[3, 1] := 'o'; pip[3, 3] := 'o'; end;
    6: begin pip[1, 1] := 'o'; pip[1, 3] := 'o'; pip[2, 1] := 'o'; pip[2, 3] := 'o'; pip[3, 1] := 'o'; pip[3, 3] := 'o'; end;
  end;
  TextColor(Black);
  TextBackground(bg);
  GotoXY(x + hOffset, y + vOffset);
  Write('+---+');
  GotoXY(x + hOffset, y + 1 + vOffset);
  Write('|', pip[1, 1], pip[1, 2], pip[1, 3], '|');
  GotoXY(x + hOffset, y + 2 + vOffset);
  Write('|', pip[2, 1], pip[2, 2], pip[2, 3], '|');
  GotoXY(x + hOffset, y + 3 + vOffset);
  Write('|', pip[3, 1], pip[3, 2], pip[3, 3], '|');
  GotoXY(x + hOffset, y + 4 + vOffset);
  Write('+---+');
  NormVideo;
  TextBackground(Black);
end;

procedure DisplayDice;
var
  i: integer;
begin
  for i := 1 to NUM_DICE do
    DrawDie(5 + (i - 1) * 6, 5, dice[i], keep[i]);
  TextColor(White);
  TextBackground(Black);
  GotoXY(5 + hOffset, 11 + vOffset);
  Write('Rolls Left: ', rollsLeft:1);
  //ClrEol;
end;

procedure DisplayScorecard;
var
  labelStr: string[2];
begin
  TextColor(Yellow);
  GotoXY(40 + hOffset, 2 + vOffset);
  Write('Upper Section');
  //ClrEol;  

  NormVideo;
  TextBackground(Black);
  for k := 1 to 6 do
  begin
    if scorecard[k].used then TextColor(LightGreen) else TextColor(White);
    GotoXY(40 + hOffset, 2 + k + vOffset);
    labelStr := IntToStr(k);
    if Length(labelStr) < 2 then labelStr := ' ' + labelStr;
    Write(labelStr, '. ', scorecard[k].name:12);
    if scorecard[k].used then
    begin
      scoreStr := IntToStr(scorecard[k].score);
      Write(scoreStr:4);
    end
    else
      Write(' (-)');
    //ClrEol; 
  end;

  TextColor(White);
  GotoXY(40 + hOffset, 10 + vOffset); Write('Upper Bonus:');
  if bonusScore > 0 then
  begin
    scoreStr := IntToStr(bonusScore);
    Write(scoreStr:4)
  end
  else Write('   -');
  //ClrEol; 

  GotoXY(40 + hOffset, 11 + vOffset); Write('Upper Total:');
  if upperScore > 0 then
  begin
    scoreStr := IntToStr(upperScore);
    Write(scoreStr:4)
  end
  else Write('   -');
  //ClrEol;

  TextColor(Yellow);
  GotoXY(40 + hOffset, 15 + vOffset); Write('Lower Section');
  //ClrEol;

  NormVideo;
  TextBackground(Black);
  for k := 7 to NUM_CATEGORIES do
  begin
    if scorecard[k].used then TextColor(LightGreen) else TextColor(White);
    GotoXY(40 + hOffset, 14 + (k-6) + vOffset);
    if k <= 9 then
      labelStr := IntToStr(k)
    else
      labelStr := Chr(Ord('A') + (k - 10));
    if Length(labelStr) < 2 then labelStr := ' ' + labelStr;
    Write(labelStr, '. ', scorecard[k].name:12);
    if scorecard[k].used then
    begin
      scoreStr := IntToStr(scorecard[k].score);
      Write(scoreStr:4);
    end
    else
      Write(' (-)');
    //ClrEol;
  end;

  TextColor(White);
  GotoXY(40 + hOffset, 22 + vOffset); Write('Lower Total:');
  if lowerScore > 0 then
  begin
    scoreStr := IntToStr(lowerScore);
    Write(scoreStr:4)
  end
  else Write('   -');
  //ClrEol;

  GotoXY(40 + hOffset, 24 + vOffset);
  TextColor(Yellow);
  Write('GRAND TOTAL:');
  NormVideo;
  TextBackground(Black);
  Write(' ');
  if totalScore > 0 then
  begin
    scoreStr := IntToStr(totalScore);
    TextColor(Yellow); Write(scoreStr:4); TextColor(White);
  end
  else Write('   -');
  //ClrEol;
  NormVideo;
  TextBackground(Black);
end;

procedure ToggleKeep(var userAction: char);
var
  dieNum: integer;
begin
  userAction := ' ';
  TextColor(Yellow);
  Print(5, 13, 'Enter dice number (1-5) to toggle keep, or (R)oll, (S)core: ');
  //ClrEol;
  NormVideo;
  TextBackground(Black);
  TextColor(White);

  GotoXY(60 + hOffset, 8 + vOffset); //ClrEol;
  GotoXY(60 + hOffset, 8 + vOffset);

  repeat
    inputChar := ReadKey;

    if (UpCase(inputChar) = 'R') or (UpCase(inputChar) = 'S') then
    begin
      userAction := UpCase(inputChar);
    end
    else if (inputChar >= '1') and (inputChar <= '5') then
    begin
      dieNum := Ord(inputChar) - Ord('0');
      keep[dieNum] := not keep[dieNum];
      DisplayDice;
      TextColor(Yellow);
      Print(5, 13, 'Enter dice number (1-5) to toggle keep, or (R)oll, (S)core: ');
      //ClrEol;
      NormVideo;
      TextBackground(Black);
      TextColor(White);
      GotoXY(60 + hOffset, 8 + vOffset);
    end
    else
    begin
      Beep;
      GotoXY(60 + hOffset, 8 + vOffset);
    end;
  until (userAction = 'R') or (userAction = 'S');
end;

// All scoring functions are unchanged...
procedure CountDice(var counts: array[1..6] of integer); var i: integer; begin for i := 1 to 6 do counts[i] := 0; for i := 1 to NUM_DICE do counts[dice[i]] := counts[dice[i]] + 1; end;
function ScoreUpper(valueToScore: integer): integer; var score: integer; counts: array[1..6] of integer; begin CountDice(counts); ScoreUpper := counts[valueToScore] * valueToScore; end;
function ScoreNOfAKind(n: integer): integer; var i, score: integer; counts: array[1..6] of integer; found: boolean; begin CountDice(counts); found := false; for i := 1 to 6 do begin if counts[i] >= n then found := true; end; if found then begin score := 0; for i := 1 to NUM_DICE do score := score + dice[i]; ScoreNOfAKind := score; end else ScoreNOfAKind := 0; end;
function ScoreFullHouse: integer; var i: integer; counts: array[1..6] of integer; has2, has3: boolean; begin CountDice(counts); has2 := false; has3 := false; for i := 1 to 6 do begin if counts[i] = 2 then has2 := true; if counts[i] = 3 then has3 := true; end; if has2 and has3 then ScoreFullHouse := 25 else ScoreFullHouse := 0; end;
function ScoreStraight(minLength: integer): integer; var i, currentRun: integer; counts: array[1..6] of integer; score: integer; begin CountDice(counts); score := 0; currentRun := 0; for i := 1 to 6 do begin if counts[i] > 0 then currentRun := currentRun + 1 else currentRun := 0; if currentRun >= minLength then begin if minLength = 4 then score := 30; if minLength = 5 then score := 40; Break; end; end; ScoreStraight := score; end;
function ScoreShipzee: integer; var i: integer; counts: array[1..6] of integer; found: boolean; begin CountDice(counts); found := false; for i := 1 to 6 do if counts[i] >= 5 then found := true; if found then ScoreShipzee := 50 else ScoreShipzee := 0; end;
function ScoreChance: integer; var i, score: integer; begin score := 0; for i := 1 to NUM_DICE do score := score + dice[i]; ScoreChance := score; end;

procedure ChooseCategory;
var
  validChoice: boolean;
  choiceChar: char;
  tempChoice: integer;
begin
  TextColor(Yellow);
  Print(5, 10, 'Choose category (1-9, A-D): ');
  //ClrEol;
  NormVideo;
  TextBackground(Black);
  TextColor(White);
  repeat
    validChoice := false;
    GotoXY(35 + hOffset, 10 + vOffset); //ClrEol;
    GotoXY(35 + hOffset, 10 + vOffset);

    choiceChar := ReadKey;

    if (choiceChar >= '1') and (choiceChar <= '9') then
      tempChoice := Ord(choiceChar) - Ord('0')
    else if (UpCase(choiceChar) >= 'A') and (UpCase(choiceChar) <= 'D') then
      tempChoice := 10 + (Ord(UpCase(choiceChar)) - Ord('A'))
    else
      tempChoice := -1;

    if (tempChoice >= 1) and (tempChoice <= NUM_CATEGORIES) then
    begin
      if scorecard[tempChoice].used then
      begin
        TextColor(LightRed);
        Print(5, 11, 'Category already used. Choose another.'); //ClrEol; Beep;
        TextColor(White);
        GotoXY(35 + hOffset, 10 + vOffset);
      end
      else
      begin
        categoryChoice := tempChoice;
        validChoice := true;
        Write(UpCase(choiceChar));
      end;
    end
    else
    begin
      TextColor(LightRed);
      Print(5, 11, 'Invalid choice. Enter 1-9 or A-D.'); //ClrEol; Beep;
      TextColor(White);
      GotoXY(35 + hOffset, 10 + vOffset);
    end;
  until validChoice;
end;

procedure ScoreTurn;
var
  score: integer;
begin
  score := 0;
  case categoryChoice of
    1: score := ScoreUpper(1); 2: score := ScoreUpper(2); 3: score := ScoreUpper(3);
    4: score := ScoreUpper(4); 5: score := ScoreUpper(5); 6: score := ScoreUpper(6);
    7: score := ScoreNOfAKind(3); 8: score := ScoreNOfAKind(4); 9: score := ScoreFullHouse;
    10: score := ScoreStraight(4); 11: score := ScoreStraight(5); 12: score := ScoreShipzee;
    13: score := ScoreChance;
  end;
  scorecard[categoryChoice].score := score;
  scorecard[categoryChoice].used := true;
  if categoryChoice <= 6 then upperScore := upperScore + score else lowerScore := lowerScore + score;
  if (upperScore >= 63) and (bonusScore = 0) then bonusScore := 35;
  totalScore := upperScore + bonusScore + lowerScore;
  DisplayScorecard;
end;

// --- Main Game ---

begin
  // <-- MODIFIED: Set background, calculate offsets
  Randomize;
  hOffset := (ScreenCols - GAME_WIDTH) div 2;
  vOffset := (ScreenRows - GAME_HEIGHT) div 2;
  if hOffset < 0 then hOffset := 0;
  if vOffset < 0 then vOffset := 0;

  repeat
    ClearScreenWithColor(Black);
    HideCursor;

    InitializeScorecard;
    turn := 0;
    gameOver := false;
    userChoice := ' ';

    repeat
      ClearScreenWithColor(Black); // Clear screen at start of each turn

      GotoXY(5 + hOffset, 2 + vOffset);
      TextColor(Cyan);
      Write('--- Turn ');
      turnStr := IntToStr(turn + 1);
      Write(turnStr);
      Write(' of ');
      totalStr := IntToStr(NUM_CATEGORIES);
      Write(totalStr);
      Write(' ---');
      NormVideo;
      TextBackground(Black);
      TextColor(White);
      //ClrEol;

      DisplayScorecard;

      for i := 1 to NUM_DICE do keep[i] := false;
      rollsLeft := MAX_ROLLS;
      userChoice := ' ';

      repeat
        RollDice;
        DisplayDice;
        if rollsLeft > 0 then
        begin
          ToggleKeep(userChoice);
        end
        else
        begin
          userChoice := 'S';
        end;
      until (userChoice = 'S') or (rollsLeft <= 0);

      DisplayDice;
      ChooseCategory;
      ScoreTurn;

      turn := turn + 1;
      TextColor(White);
      if turn >= NUM_CATEGORIES then gameOver := true;

      if not gameOver then
      begin
        Print(5, 24, 'Press any key for next turn...'); //ClrEol;
        inputChar := ReadKey;
        while KeyPressed do
        begin
          inputChar := ReadKey;
        end;
      end;
    until gameOver;

    ClearScreenWithColor(Black);
    DisplayScorecard;
    TextColor(Yellow);
    GotoXY(1 + hOffset, 12 + vOffset); Write('>>> GAME OVER <<<');
    NormVideo;
    TextBackground(Black);
    TextColor(White);
    GotoXY(15 + hOffset, 14 + vOffset);
    Write('Final Score: ');
    scoreStr := IntToStr(totalScore);
    Write(scoreStr);
    ShowCursor;
    GotoXY(15 + hOffset, 16 + vOffset);
    Write('Play again? (Y/N): ');
    repeat
      userChoice := UpCase(ReadKey);
    until userChoice in ['Y', 'N'];
  until userChoice = 'N';

  GotoXY(1, ScreenRows);
  ShowCursor;
end.
