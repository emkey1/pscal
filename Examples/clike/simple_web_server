#!/usr/bin/env clike

// Simple CLike web server
// - Listens on port 5555 by default
// - Creates /tmp/clike_htdocs.[PID] and writes index.html
// - Multithreaded: spawns a handler thread per connection
// - Note: current socketBind binds all interfaces; by default we only advertise
//   localhost. Serving is minimal and for demo/testing.

int Port = 5555;
str RootDir;
str IndexPath;
str Body;
text GFile;

// Max concurrent handler wrappers
const int MaxThreads = 8;
int connSlots[MaxThreads];
int nextSlot = 0;

// Helpers
int endswith(str s, str suffix) {
  int ls = length(s);
  int lf = length(suffix);
  if (lf > ls) return 0;
  str tail = copy(s, ls - lf + 1, lf);
  return tail == suffix ? 1 : 0;
}

str contentType(str path) {
  if (endswith(path, ".html") || endswith(path, ".htm")) return "text/html";
  if (endswith(path, ".css")) return "text/css";
  if (endswith(path, ".js")) return "application/javascript";
  if (endswith(path, ".json")) return "application/json";
  if (endswith(path, ".txt")) return "text/plain";
  if (endswith(path, ".png")) return "image/png";
  if (endswith(path, ".jpg") || endswith(path, ".jpeg")) return "image/jpeg";
  return "application/octet-stream";
}

// Percent-decode %XX sequences (valid hex only). Leaves other characters unchanged.
str decodePercent(str s) {
  str out = "";
  int i = 1;
  while (i <= length(s)) {
    if (copy(s, i, 1) == "%" && i + 2 <= length(s)) {
      str h1 = copy(s, i + 1, 1);
      str h2 = copy(s, i + 2, 1);
      int v1 = -1; int v2 = -1;
      // hex digit to value
      if (h1 >= "0" && h1 <= "9") v1 = ord(h1) - ord("0");
      else if (h1 >= "a" && h1 <= "f") v1 = 10 + (ord(h1) - ord("a"));
      else if (h1 >= "A" && h1 <= "F") v1 = 10 + (ord(h1) - ord("A"));
      if (h2 >= "0" && h2 <= "9") v2 = ord(h2) - ord("0");
      else if (h2 >= "a" && h2 <= "f") v2 = 10 + (ord(h2) - ord("a"));
      else if (h2 >= "A" && h2 <= "F") v2 = 10 + (ord(h2) - ord("A"));
      if (v1 >= 0 && v2 >= 0) {
        int val = v1 * 16 + v2;
        out = out + char(val);
        i = i + 3;
        continue;
      }
    }
    out = out + copy(s, i, 1);
    i = i + 1;
  }
  return out;
}

// Remove all occurrences of ".." to prevent directory traversal.
// Normalize a relative path: remove "..", remove "./" and collapse "//".
str normalizePath(str s) {
  // Canonicalize path by processing segments and handling '.' and '..'.
  // Input is expected to be relative (no leading '/').
  str out = "";
  int i = 1;
  while (i <= length(s)) {
    // Skip any slashes
    while (i <= length(s) && copy(s, i, 1) == "/") i = i + 1;
    if (i > length(s)) break;
    // Capture next segment until slash or end
    int j = i;
    while (j <= length(s) && copy(s, j, 1) != "/") j = j + 1;
    int segLen = j - i;
    str seg = copy(s, i, segLen);
    if (seg == "" || seg == ".") {
      // skip
    } else if (seg == "..") {
      // pop last segment from out if any
      if (length(out) > 0) {
        int k = 1; int last = 0;
        while (k <= length(out)) { if (copy(out, k, 1) == "/") last = k; k = k + 1; }
        if (last > 0) out = copy(out, 1, last - 1); else out = "";
      }
    } else {
      out = (length(out) > 0) ? out + "/" + seg : seg;
    }
    i = j + 1;
  }
  return out;
}

void serveConn(int c) {
  // Read request
  mstream req = socketreceive(c, 2048);
  str reqText = mstreambuffer(req);
  // Parse request line robustly: take first line then split by spaces
  int ln = pos(reqText, "\r\n");
  if (ln == 0) ln = pos(reqText, "\n");
  str firstLine = (ln > 0) ? copy(reqText, 1, ln - 1) : reqText;
  int sp1 = pos(firstLine, " ");
  str method = "";
  str path = "/";
  if (sp1 > 0) {
    method = copy(firstLine, 1, sp1 - 1);
    str rest = copy(firstLine, sp1 + 1, length(firstLine) - sp1);
    int sp2 = pos(rest, " ");
    if (sp2 > 0) path = copy(rest, 1, sp2 - 1);
  }
  // Strip query string
  int qidx = pos(path, "?");
  if (qidx > 0) path = copy(path, 1, qidx - 1);
  // Percent-decode the URL path
  path = decodePercent(path);

  str respBody;
  int code = 200;
  str ctype = "text/html";
  if (path == "/") {
    // Directory listing of RootDir
    str listing = "<html><body><h1>Index of /</h1><ul>";
    str name = findfirst(RootDir);
    while (name != "") {
      listing = listing + "<li><a href='/" + name + "'>" + name + "</a></li>";
      name = findnext();
    }
    listing = listing + "</ul></body></html>";
    respBody = listing;
    code = 200;
    ctype = "text/html";
  } else if (path == "/index.html") {
    respBody = Body;
    code = 200;
    ctype = "text/html";
  } else {
    // Serve file under RootDir
    str rel = (copy(path, 1, 1) == "/") ? copy(path, 2, length(path) - 1) : path;
    rel = normalizePath(rel);
    str fullPath = RootDir + "/" + rel;
    mstream ms = mstreamcreate();
    int ok = mstreamloadfromfile(&ms, fullPath);
    if (ok) {
      respBody = mstreambuffer(ms);
      code = 200;
      ctype = contentType(rel);
      mstreamfree(&ms);
    } else {
      respBody = "<html><body>Not Found</body></html>";
      code = 404;
      ctype = "text/html";
      mstreamfree(&ms);
    }
  }
  int len = length(respBody);
  str status = (code == 200) ? "200 OK" : "404 Not Found";
  str hdr = "HTTP/1.1 " + status + "\r\n"
            + "Content-Type: " + ctype + "\r\n"
            + "Content-Length: " + inttostr(len) + "\r\n\r\n";
  socketsend(c, hdr);
  socketsend(c, respBody);
  printf("[%s] %s -> %d\n", method, path, code);
  socketclose(c);
}

void handler0() { serveConn(connSlots[0]); }
void handler1() { serveConn(connSlots[1]); }
void handler2() { serveConn(connSlots[2]); }
void handler3() { serveConn(connSlots[3]); }
void handler4() { serveConn(connSlots[4]); }
void handler5() { serveConn(connSlots[5]); }
void handler6() { serveConn(connSlots[6]); }
void handler7() { serveConn(connSlots[7]); }

void spawnHandler(int c) {
  int slot = nextSlot % MaxThreads;
  nextSlot = nextSlot + 1;
  connSlots[slot] = c;
  switch (slot) {
    case 0: spawn handler0(); break;
    case 1: spawn handler1(); break;
    case 2: spawn handler2(); break;
    case 3: spawn handler3(); break;
    case 4: spawn handler4(); break;
    case 5: spawn handler5(); break;
    case 6: spawn handler6(); break;
    case 7: spawn handler7(); break;
  }
}

void initFiles() {
  int pid = getpid();
  str pidStr = inttostr(pid);
  RootDir = "/tmp/clike_htdocs." + pidStr;
  mkdir(RootDir);
  IndexPath = RootDir + "/index.html";
  Body = "<html><body>Hello from the CLike web server</body></html>";
  // Create an index.html file if it does not exist yet
  text F;
  F = fopen(IndexPath, "r");
  if (F != NULL) {
    fclose(F);
  } else {
    GFile = fopen(IndexPath, "w");
    fprintf(GFile, "%s\n", Body);
    fclose(GFile);
  }
}

int main() {
  initFiles();
  // Optional: read port and root dir from args: [port] [rootdir]
  if (paramcount() >= 1) {
    str a1 = paramstr(1);
    int parsed = 0; int code = -1;
    val(a1, &parsed, &code);
    if (code == 0 && parsed > 0 && parsed < 65536) {
      Port = parsed;
      if (paramcount() >= 2) {
        RootDir = paramstr(2);
        IndexPath = RootDir + "/index.html";
      }
    } else {
      // First arg is root dir
      RootDir = a1;
      IndexPath = RootDir + "/index.html";
      if (paramcount() >= 2) {
        str a2 = paramstr(2);
        parsed = 0; code = -1;
        val(a2, &parsed, &code);
        if (code == 0 && parsed > 0 && parsed < 65536) Port = parsed;
      }
    }
    // Ensure directory exists and index.html present
    mkdir(RootDir);
    text F2;
    F2 = fopen(IndexPath, "r");
    if (F2 != NULL) { fclose(F2); }
    else {
      GFile = fopen(IndexPath, "w");
      fprintf(GFile, "%s\n", Body);
      fclose(GFile);
    }
  }
  printf("Serving %s on http://127.0.0.1:%d\n", IndexPath, Port);


  printf("Root: %s\n", RootDir);

  int srv = socketcreate(0);
  if (srv < 0) { printf("socketcreate failed\n"); return 1; }
  // Bind and listen; current API binds all interfaces (INADDR_ANY)
  // Bind explicitly to localhost by default
  int bindrc = socketbindaddr(srv, "127.0.0.1", Port);
  if (bindrc != 0) {
    printf("socketbind failed: %d\n", socketlasterror());
    return 1;
  }
  if (socketlisten(srv, 16) != 0) {
    printf("socketlisten failed: %d\n", socketlasterror());
    return 1;
  }
  printf("Waiting for connections... (Ctrl+C to quit)\n");
  while (1) {
    int c = socketaccept(srv);
    if (c >= 0) {
      spawnHandler(c);
    } else {
      // Small sleep to avoid busy loop on transient errors
      delay(10);
    }
  }
  socketclose(srv);
  return 0;
}
