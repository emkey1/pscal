#!/usr/bin/env clike

// Simple CLike web server
// - Listens on port 5555 by default
// - Creates /tmp/clike_htdocs.[PID] and writes index.html
// - Multithreaded: spawns a handler thread per connection
// - Note: current socketBind binds all interfaces; by default we only advertise
//   localhost. Serving is minimal and for demo/testing.

int Port = 5555;
str RootDir;
str IndexPath;
str Body;
text GFile;

// Max concurrent handler wrappers
const int MaxThreads = 8;
int connSlots[MaxThreads];
int nextSlot = 0;

// Helpers
int endswith(str s, str suffix) {
  int ls = length(s);
  int lf = length(suffix);
  if (lf > ls) return 0;
  str tail = copy(s, ls - lf + 1, lf);
  return tail == suffix ? 1 : 0;
}

str contentType(str path) {
  if (endswith(path, ".html") || endswith(path, ".htm")) return "text/html";
  if (endswith(path, ".css")) return "text/css";
  if (endswith(path, ".js")) return "application/javascript";
  if (endswith(path, ".json")) return "application/json";
  if (endswith(path, ".txt")) return "text/plain";
  if (endswith(path, ".png")) return "image/png";
  if (endswith(path, ".jpg") || endswith(path, ".jpeg")) return "image/jpeg";
  return "application/octet-stream";
}

// Remove all occurrences of ".." to prevent directory traversal.
str stripDotDot(str s) {
  str out = "";
  int i = 1;
  while (i <= length(s)) {
    if (i + 1 <= length(s) && copy(s, i, 2) == "..") {
      i = i + 2;
    } else {
      out = out + copy(s, i, 1);
      i = i + 1;
    }
  }
  return out;
}

void serveConn(int c) {
  // Read (ignore) request
  mstream req = socketreceive(c, 2048);
  str reqText = mstreambuffer(req);
  // Parse request line minimally: method SP path SP ...
  int sp1 = pos(reqText, " ");
  str method = (sp1 > 0) ? copy(reqText, 1, sp1 - 1) : "";
  str rest = (sp1 > 0) ? copy(reqText, sp1 + 2, length(reqText) - sp1) : "";
  int sp2 = pos(rest, " ");
  str path = (sp2 > 0) ? copy(rest, 1, sp2 - 1) : "/";

  str respBody;
  int code = 200;
  str ctype = "text/html";
  if (path == "/") {
    // Directory listing of RootDir
    str listing = "<html><body><h1>Index of /</h1><ul>";
    str name = findfirst(RootDir);
    while (name != "") {
      listing = listing + "<li><a href='/" + name + "'>" + name + "</a></li>";
      name = findnext();
    }
    listing = listing + "</ul></body></html>";
    respBody = listing;
    code = 200;
    ctype = "text/html";
  } else if (path == "/index.html") {
    respBody = Body;
    code = 200;
    ctype = "text/html";
  } else {
    // Serve file under RootDir
    str rel = (copy(path, 1, 1) == "/") ? copy(path, 2, length(path) - 1) : path;
    rel = stripDotDot(rel);
    str fullPath = RootDir + "/" + rel;
    mstream ms = mstreamcreate();
    int ok = mstreamloadfromfile(&ms, fullPath);
    if (ok) {
      respBody = mstreambuffer(ms);
      code = 200;
      ctype = contentType(rel);
    } else {
      respBody = "<html><body>Not Found</body></html>";
      code = 404;
      ctype = "text/html";
    }
  }
  int len = length(respBody);
  str status = (code == 200) ? "200 OK" : "404 Not Found";
  str hdr = "HTTP/1.1 " + status + "\r\n"
            + "Content-Type: " + ctype + "\r\n"
            + "Content-Length: " + inttostr(len) + "\r\n\r\n";
  socketsend(c, hdr);
  socketsend(c, respBody);
  printf("[%s] %s -> %d\n", method, path, code);
  socketclose(c);
}

void handler0() { serveConn(connSlots[0]); }
void handler1() { serveConn(connSlots[1]); }
void handler2() { serveConn(connSlots[2]); }
void handler3() { serveConn(connSlots[3]); }
void handler4() { serveConn(connSlots[4]); }
void handler5() { serveConn(connSlots[5]); }
void handler6() { serveConn(connSlots[6]); }
void handler7() { serveConn(connSlots[7]); }

void spawnHandler(int c) {
  int slot = nextSlot % MaxThreads;
  nextSlot = nextSlot + 1;
  connSlots[slot] = c;
  switch (slot) {
    case 0: spawn handler0(); break;
    case 1: spawn handler1(); break;
    case 2: spawn handler2(); break;
    case 3: spawn handler3(); break;
    case 4: spawn handler4(); break;
    case 5: spawn handler5(); break;
    case 6: spawn handler6(); break;
    case 7: spawn handler7(); break;
  }
}

void initFiles() {
  int pid = getpid();
  str pidStr = inttostr(pid);
  RootDir = "/tmp/clike_htdocs." + pidStr;
  mkdir(RootDir);
  IndexPath = RootDir + "/index.html";
  Body = "<html><body>Hello from the CLike web server</body></html>";
  // Create an index.html file in the htdocs directory.
  GFile = fopen(IndexPath, "w");
  fprintf(GFile, "%s\n", Body);
  fclose(GFile);
}

int main() {
  initFiles();
  // Optional: read port from argv[1]
  if (paramcount() >= 1) {
    str p = paramstr(1);
    int parsed = 0;
    int code = -1;
    val(p, &parsed, &code);
    if (code == 0 && parsed > 0 && parsed < 65536) {
      Port = parsed;
    }
  }
  printf("Serving %s on http://127.0.0.1:%d\n", IndexPath, Port);


  printf("Root: %s\n", RootDir);

  int srv = socketcreate(0);
  if (srv < 0) { printf("socketcreate failed\n"); return 1; }
  // Bind and listen; current API binds all interfaces (INADDR_ANY)
  // Bind explicitly to localhost by default
  int bindrc = socketbindaddr(srv, "127.0.0.1", Port);
  if (bindrc != 0) {
    printf("socketbind failed: %d\n", socketlasterror());
    return 1;
  }
  if (socketlisten(srv, 16) != 0) {
    printf("socketlisten failed: %d\n", socketlasterror());
    return 1;
  }
  printf("Waiting for connections... (Ctrl+C to quit)\n");
  while (1) {
    int c = socketaccept(srv);
    if (c >= 0) {
      spawnHandler(c);
    } else {
      // Small sleep to avoid busy loop on transient errors
      delay(10);
    }
  }
  socketclose(srv);
  return 0;
}
