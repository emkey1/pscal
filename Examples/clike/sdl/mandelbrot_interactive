#!/usr/bin/env clike
/*
 * SDL Mandelbrot renderer using the MandelbrotRow builtin with threading.
 * Left click to zoom in, right click to zoom out, Q to quit.
 */

const int Width = 1200;
const int Height = 900;
const int MaxIterations = 200;
const int BytesPerPixel = 4;
const int ScreenUpdateInterval = 1; /* update every row for responsiveness */
const double ZoomFactor = 2.0;
const int ThreadCount = 4;
const int ButtonLeft = 1;
const int ButtonRight = 4;
/* SDL keycodes for arrow keys */
const int KEY_LEFT = 1073741904;
const int KEY_RIGHT = 1073741903;
const int KEY_UP = 1073741906;
const int KEY_DOWN = 1073741905;

str ConfiguredFontPath = "@PSCAL_INSTALL_ROOT_RESOLVED@/fonts/Roboto/static/Roboto-Regular.ttf";

byte pixelData[Width * Height * BytesPerPixel];
int rowDone[Height];
int threadStart[ThreadCount];
int threadEnd[ThreadCount];

double minRe = -2.0;
double maxRe = 1.0;
double minIm = -1.2;
double maxIm;
double reFactor;
double imFactor;

int textureID;
int rowMutex;
int quitMutex;
int abortMutex;
int quit = 0;
int needRender = 1;
int prevButtons = 0;
int abortRender = 0;
int computing = 0;
int nextPresentRow = 0;
int tid[ThreadCount];
int textReady = 0;


#ifdef SDL_ENABLED
int getQuit() {
    int q;
    lock(quitMutex);
    q = quit;
    unlock(quitMutex);
    return q;
}

void setQuit(int v) {
    lock(quitMutex);
    quit = v;
    unlock(quitMutex);
}

int getAbortRender() {
    int a;
    lock(abortMutex);
    a = abortRender;
    unlock(abortMutex);
    return a;
}

void setAbortRender(int v) {
    lock(abortMutex);
    abortRender = v;
    unlock(abortMutex);
}

int tryInitFont(str path, int fontSize) {
    /*
     * getenv() in the VM returns an empty string when the variable is not
     * present.  Comparing the string directly against NULL triggers a runtime
     * type error because strings cannot be compared with NIL in CLike.  Treat
     * an empty string as "not available" instead.
     */
    if (strlen(path) == 0) return 0;
    if (!fileexists(path)) return 0;
    inittextsystem(path, fontSize);
    return 1;
}

/*
 * Helpers to coordinate the worker threads and process user input events while
 * keeping the UI responsive.
 */
void resetThreadIds() {
    int i;
    for (i = 0; i < ThreadCount; i++) {
        tid[i] = -1;
    }
}

void zoomAt(int px, int py, double factor) {
    double reStep = (maxRe - minRe) / (Width - 1);
    double imStep = (maxIm - minIm) / (Height - 1);
    double centerRe = minRe + (px + 0.5) * reStep;
    double centerIm = maxIm - (py + 0.5) * imStep;
    double widthRe = (maxRe - minRe) * factor;
    double heightIm = (maxIm - minIm) * factor;

    minRe = centerRe - widthRe / 2.0;
    maxRe = centerRe + widthRe / 2.0;
    minIm = centerIm - heightIm / 2.0;
    maxIm = centerIm + heightIm / 2.0;
}

void joinThreads() {
    int i;
    for (i = 0; i < ThreadCount; i++) {
        if (tid[i] >= 0) {
            join tid[i];
            tid[i] = -1;
        }
    }
}

void startRender() {
    int i, rowsPerThread, extra, startY, endY;

    setAbortRender(0);
    maxIm = minIm + (maxRe - minRe) * Height / Width;
    reFactor = (maxRe - minRe) / (Width - 1);
    imFactor = (maxIm - minIm) / (Height - 1);

    for (i = 0; i < Height; i++) {
        rowDone[i] = 0;
    }

    rowsPerThread = Height / ThreadCount;
    extra = Height % ThreadCount;
    startY = 0;
    for (i = 0; i < ThreadCount; i++) {
        endY = startY + rowsPerThread - 1;
        if (extra > 0) {
            endY++;
            extra--;
        }
        threadStart[i] = startY;
        threadEnd[i] = endY;
        startY = endY + 1;
    }

    if (threadStart[0] <= threadEnd[0]) tid[0] = spawn computeRowsThread0(); else tid[0] = -1;
    if (threadStart[1] <= threadEnd[1]) tid[1] = spawn computeRowsThread1(); else tid[1] = -1;
    if (threadStart[2] <= threadEnd[2]) tid[2] = spawn computeRowsThread2(); else tid[2] = -1;
    if (threadStart[3] <= threadEnd[3]) tid[3] = spawn computeRowsThread3(); else tid[3] = -1;

    computing = 1;
    nextPresentRow = 0;
}

void updateScreenDuringRender() {
    updatetexture(textureID, pixelData);
    cleardevice();
    rendercopy(textureID);
    if (textReady) {
        outtextxy(8, 8, "Rendering...");
    }
    updatescreen();
}

void pollRenderProgress() {
    int readyRows;
    int shouldUpdate = 0;

    if (!computing) {
        return;
    }

    readyRows = nextPresentRow;
    while (readyRows < Height) {
        int done;
        lock(rowMutex);
        done = rowDone[readyRows];
        unlock(rowMutex);
        if (!done) {
            break;
        }
        readyRows++;
        if (((readyRows % ScreenUpdateInterval) == 0) || readyRows == Height) {
            shouldUpdate = 1;
        }
    }

    if (shouldUpdate) {
        nextPresentRow = readyRows;
        updateScreenDuringRender();
    } else {
        nextPresentRow = readyRows;
    }

    if (getAbortRender() || nextPresentRow == Height) {
        int aborted = getAbortRender();
        joinThreads();
        setAbortRender(0);
        computing = 0;
        nextPresentRow = 0;
        if (!aborted) {
            updatetexture(textureID, pixelData);
            cleardevice();
            rendercopy(textureID);
            updatescreen();
        }
    }
}

int handleInput() {
    int changed = 0;
    int key;
    int x = 0;
    int y = 0;
    int buttons = 0;
    int insideWindow = 0;
    int winW;
    int winH;
    int freshLeft;
    int freshRight;

    graphloop(0);

    key = pollkeyany();
    while (key != 0) {
        if (key == 'q' || key == 'Q') {
            setQuit(1);
            return changed;
        } else {
            double widthRe = (maxRe - minRe);
            double heightIm = (maxIm - minIm);
            double dx = widthRe * 0.5;
            double dy = heightIm * 0.5;
            if (key == KEY_LEFT) {
                minRe -= dx;
                maxRe -= dx;
                changed = 1;
            } else if (key == KEY_RIGHT) {
                minRe += dx;
                maxRe += dx;
                changed = 1;
            } else if (key == KEY_UP) {
                minIm += dy;
                maxIm += dy;
                changed = 1;
            } else if (key == KEY_DOWN) {
                minIm -= dy;
                maxIm -= dy;
                changed = 1;
            }
        }
        key = pollkeyany();
    }

    getmousestate(&x, &y, &buttons, &insideWindow);
    if (!insideWindow) {
        buttons = 0;
    }

    winW = getmaxx() + 1;
    winH = getmaxy() + 1;

    if (insideWindow && winW > 0 && winH > 0) {
        if (x < 0) x = 0;
        if (y < 0) y = 0;
        if (x >= winW) x = winW - 1;
        if (y >= winH) y = winH - 1;
        if (winW != Width) {
            x = (x * Width) / winW;
            if (x >= Width) x = Width - 1;
        }
        if (winH != Height) {
            y = (y * Height) / winH;
            if (y >= Height) y = Height - 1;
        }
    }

    freshLeft = ((buttons & ButtonLeft) != 0) && ((prevButtons & ButtonLeft) == 0);
    freshRight = ((buttons & ButtonRight) != 0) && ((prevButtons & ButtonRight) == 0);

    if (freshLeft) {
        zoomAt(x, y, 1.0 / ZoomFactor);
        changed = 1;
    } else if (freshRight) {
        zoomAt(x, y, ZoomFactor);
        changed = 1;
    }

    prevButtons = buttons;

    if (changed) {
        needRender = 1;
        if (computing) {
            setAbortRender(1);
        }
    }

    return changed;
}

void computeRows(int startY, int endY) {
    int row[Width], x, y, n, R, G, B, idx;
    double c_im;
    for (y = startY; y <= endY && !getQuit(); y++) {
        if (getAbortRender()) break;
        c_im = maxIm - y * imFactor;
        mandelbrotrow(minRe, reFactor, c_im, MaxIterations, Width - 1, &row);
        idx = y * Width * BytesPerPixel;
        for (x = 0; x < Width; x++) {
            n = row[x];
            if (n == MaxIterations) { R = G = B = 0; }
            else {
                R = (n * 5) % 256;
                G = (n * 7 + 85) % 256;
                B = (n * 11 + 170) % 256;
            }
            pixelData[idx + 0] = R;
            pixelData[idx + 1] = G;
            pixelData[idx + 2] = B;
            pixelData[idx + 3] = 255;
            idx += BytesPerPixel;
        }
        lock(rowMutex);
        rowDone[y] = 1;
        unlock(rowMutex);
    }
}

void computeRowsThread0() { computeRows(threadStart[0], threadEnd[0]); }
void computeRowsThread1() { computeRows(threadStart[1], threadEnd[1]); }
void computeRowsThread2() { computeRows(threadStart[2], threadEnd[2]); }
void computeRowsThread3() { computeRows(threadStart[3], threadEnd[3]); }
#endif

int main() {
#ifdef SDL_ENABLED
    const int fontSize = 18;
    str envFontPath;

    printf("Calculating Mandelbrot set. The window will update as rows are drawn...\n");
    initgraph(Width, Height, "Mandelbrot in CLike (threaded)");
    envFontPath = getenv("PSCAL_FONT_PATH");
    if (!textReady) textReady = tryInitFont(envFontPath, fontSize);
    if (!textReady) textReady = tryInitFont(ConfiguredFontPath, fontSize);
    if (!textReady) {
        printf("Warning: Unable to locate Roboto font. Text rendering disabled.\n");
    }
    textureID = createtexture(Width, Height);
    if (textureID < 0) { printf("Error: unable to create texture.\n"); halt(); }
    cleardevice(); updatescreen();

    rowMutex = mutex();
    quitMutex = mutex();
    abortMutex = mutex();

    resetThreadIds();

    while (!getQuit()) {
        pollRenderProgress();
        if (!computing && needRender) {
            startRender();
            needRender = 0;
            updateScreenDuringRender();
        }
        handleInput();
        delay(1);
    }

    if (computing) {
        setAbortRender(1);
        while (computing) {
            pollRenderProgress();
            delay(1);
        }
    }

    destroytexture(textureID);
    if (textReady) {
        quittextsystem();
    }
    closegraph();
    return 0;
#else
    printf("SDL support not enabled.\n");
    return 1;
#endif
}
