#!/usr/bin/env clike
/*
 * SDL Mandelbrot renderer using the MandelbrotRow builtin with threading.
 * Left click to zoom in, right click to zoom out, Q to quit.
 */

const int Width = 1200;
const int Height = 900;
const int MaxIterations = 200;
const int BytesPerPixel = 4;
const int ScreenUpdateInterval = 16;
const double ZoomFactor = 2.0;
const int ThreadCount = 4;
const int ButtonLeft = 1;
const int ButtonRight = 4;

byte pixelData[Width * Height * BytesPerPixel];
int rowDone[Height];
int threadStart[ThreadCount];
int threadEnd[ThreadCount];

double minRe = -2.0;
double maxRe = 1.0;
double minIm = -1.2;
double maxIm;
double reFactor;
double imFactor;

int textureID;
int rowMutex;
int quitMutex;
int inputMutex;
int quit = 0;
int redraw = 1;
int mouseX = 0, mouseY = 0, mouseButtons = 0, prevButtons = 0;

int getQuit() { 
    int q; 
    lock(quitMutex); 
    q = quit; 
    unlock(quitMutex); 
    return q; 
}

void setQuit(int v) { 
    lock(quitMutex); 
    quit = v; 
    unlock(quitMutex); 
}

void computeRows(int startY, int endY) {
    int row[Width], x, y, n, R, G, B, idx;
    double c_im;
    for (y = startY; y <= endY && !getQuit(); y++) {
        c_im = maxIm - y * imFactor;
        mandelbrotrow(minRe, reFactor, c_im, MaxIterations, Width - 1, &row);
        idx = y * Width * BytesPerPixel;
        lock(rowMutex);
        for (x = 0; x < Width; x++) {
            n = row[x];
            if (n == MaxIterations) { R = G = B = 0; }
            else {
                R = (n * 5) % 256;
                G = (n * 7 + 85) % 256;
                B = (n * 11 + 170) % 256;
            }
            pixelData[idx + 0] = R;
            pixelData[idx + 1] = G;
            pixelData[idx + 2] = B;
            pixelData[idx + 3] = 255;
            idx += BytesPerPixel;
        }
        rowDone[y] = 1;
        unlock(rowMutex);
    }
}

void computeRowsThread0() { computeRows(threadStart[0], threadEnd[0]); }
void computeRowsThread1() { computeRows(threadStart[1], threadEnd[1]); }
void computeRowsThread2() { computeRows(threadStart[2], threadEnd[2]); }
void computeRowsThread3() { computeRows(threadStart[3], threadEnd[3]); }

void mouseThread() {
    int x, y, b;
    while (!getQuit()) {
        graphloop(0);
        getmousestate(&x, &y, &b);
        lock(inputMutex);
        prevButtons = mouseButtons;
        mouseX = x;
        mouseY = y;
        mouseButtons = b;
        unlock(inputMutex);
    }
}

int main() {
    int tid[ThreadCount], i, y, rowsPerThread, extra, startY, endY;
    int inputTid;

    printf("Calculating Mandelbrot set. The window will update as rows are drawn...\n");
    initgraph(Width, Height, "Mandelbrot in CLike (threaded)");
    textureID = createtexture(Width, Height);
    if (textureID < 0) { printf("Error: unable to create texture.\n"); halt(); }
    cleardevice(); updatescreen();

    rowMutex = mutex();
    quitMutex = mutex();
    inputMutex = mutex();
    inputTid = spawn mouseThread();

    while (!getQuit()) {
        graphloop(0);

        if (redraw) {
            maxIm = minIm + (maxRe - minRe) * Height / Width;
            reFactor = (maxRe - minRe) / (Width - 1);
            imFactor = (maxIm - minIm) / (Height - 1);
            for (i = 0; i < Height; i++) rowDone[i] = 0;

            rowsPerThread = Height / ThreadCount;
            extra = Height % ThreadCount;
            startY = 0;
            for (i = 0; i < ThreadCount; i++) {
                endY = startY + rowsPerThread - 1;
                if (extra > 0) { 
                    endY++; 
                    extra--; 
                }
                //printf("Thread(%d): startY: %d endY: %d\n", i, startY, endY);
                threadStart[i] = startY;
                threadEnd[i] = endY;
                startY = endY + 1;
            }

            tid[0] = spawn computeRowsThread0();
            tid[1] = spawn computeRowsThread1();
            tid[2] = spawn computeRowsThread2();
            tid[3] = spawn computeRowsThread3();

            y = 0;
            while (y < Height && !getQuit()) {
                int done, update;
                lock(rowMutex);
                done = rowDone[y];
                /*
                 * "done" is stored as an integer in rowDone[y].  The logical
                 * operators in CLike require both operands to be of the same
                 * type (either both integers or both booleans).  The expression
                 * on the right-hand side produces a boolean result, so we
                 * explicitly compare "done" against zero to convert it to a
                 * boolean before using the && operator.  This avoids a runtime
                 * type error when mixing INTEGER and BOOLEAN values.
                 */
                update = ((done != 0) && (((y + 1) % ScreenUpdateInterval) == 0 || y == Height - 1)) ? 1 : 0;
                if (update)
                    updatetexture(textureID, pixelData);
                if (done)
                    y++;
                unlock(rowMutex);

                if (update) {
                    cleardevice();
                    rendercopy(textureID);
                    updatescreen();
                }
                if (keypressed()) {
                    char c = readkey();
                    if (toupper(c) == 'Q') setQuit(1);
                }
                if (!done || update)
                    graphloop(0);
            }

            for (i = 0; i < ThreadCount; i++)
                join tid[i];

            if (!getQuit()) {
                updatetexture(textureID, pixelData);
                cleardevice();
                rendercopy(textureID);
                updatescreen();
                redraw = 0;
            }
        }

        if (keypressed()) {
            char c = readkey();
            if (toupper(c) == 'Q') { setQuit(1); continue; }
        }

        int mx, my, buttons, prev;
        lock(inputMutex);
        mx = mouseX; my = mouseY; buttons = mouseButtons; prev = prevButtons;
        unlock(inputMutex);

        if (((buttons & ButtonLeft) != 0) && ((prev & ButtonLeft) == 0)) {
            double centerRe = minRe + mx * reFactor;
            double centerIm = maxIm - my * imFactor;
            double newWidth = (maxRe - minRe) / ZoomFactor;
            double newHeight = (maxIm - minIm) / ZoomFactor;
            minRe = centerRe - newWidth / 2.0;
            maxRe = centerRe + newWidth / 2.0;
            minIm = centerIm - newHeight / 2.0;
            redraw = 1;
        } else if (((buttons & ButtonRight) != 0) && ((prev & ButtonRight) == 0)) {
            double centerRe = minRe + mx * reFactor;
            double centerIm = maxIm - my * imFactor;
            double newWidth = (maxRe - minRe) * ZoomFactor;
            double newHeight = (maxIm - minIm) * ZoomFactor;
            minRe = centerRe - newWidth / 2.0;
            maxRe = centerRe + newWidth / 2.0;
            minIm = centerIm - newHeight / 2.0;
            redraw = 1;
        }
    }
    join inputTid;
    destroytexture(textureID);
    closegraph();
    return 0;
}
