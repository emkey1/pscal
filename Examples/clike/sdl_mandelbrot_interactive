#!/usr/bin/env clike
/*
 * Threaded SDL Mandelbrot set renderer using mandelbrotrow.
 * The window updates as rows are drawn. Press Q in the console to quit.
 */

const int WindowWidth = 1200;
const int WindowHeight = 900;
const int MaxIterations = 200;
const double StartMinRe = -2.0;
const double StartMaxRe = 1.0;
const int ScreenUpdateInterval = 16;
const int MandelBytesPerPixel = 4;

byte pixelData[WindowWidth * WindowHeight * MandelBytesPerPixel];
int textureID;

double ImRange;
double MinRe;
double MaxRe;
double MinIm;
double MaxIm;
double ReFactor;
double ImFactor;
int MaxX;
int MaxY;

int threadCount = 4;
int threadStart[4];
int threadEnd[4];

int rowDone[WindowHeight];
int quit = 0;

int rowMutex;
int quitMutex;
int inputMutex;

int clickType;
int clickX;
int clickY;

int getQuit() {
    int q;
    lock(quitMutex);
    q = quit;
    unlock(quitMutex);
    return q;
}

void setQuit(int v) {
    lock(quitMutex);
    quit = v;
    unlock(quitMutex);
}

void resetView() {
    MinRe = StartMinRe;
    MaxRe = StartMaxRe;
    ImRange = (MaxRe - MinRe) * MaxY / MaxX;
    MinIm = -ImRange / 2.0;
    MaxIm = MinIm + ImRange;
    ReFactor = (MaxRe - MinRe) / (MaxX - 1);
    ImFactor = (MaxIm - MinIm) / (MaxY - 1);
}

void zoomAt(int mouseX, int mouseY, double scale) {
    double c_re = MinRe + mouseX * ReFactor;
    double c_im = MaxIm - mouseY * ImFactor;
    double newWidth = (MaxRe - MinRe) * scale;
    double newHeight = (MaxIm - MinIm) * scale;
    MinRe = c_re - newWidth / 2.0;
    MaxRe = c_re + newWidth / 2.0;
    MinIm = c_im - newHeight / 2.0;
    MaxIm = c_im + newHeight / 2.0;
    ImRange = MaxIm - MinIm;
    ReFactor = (MaxRe - MinRe) / (MaxX - 1);
    ImFactor = (MaxIm - MinIm) / (MaxY - 1);
}

void computeRows(int startY, int endY) {
    int row[WindowWidth];
    int x, y, n, R, G, B, bufferBaseIdx;
    double c_im;

    for (y = startY; y <= endY && !getQuit(); y++) {
        c_im = MaxIm - y * ImFactor;
        mandelbrotrow(MinRe, ReFactor, c_im, MaxIterations, MaxX, row);
        lock(rowMutex);
        for (x = 0; x <= MaxX; x++) {
            n = row[x];
            if (n == MaxIterations) { R = G = B = 0; }
            else {
                R = (n * 5) % 256;
                G = (n * 7 + 85) % 256;
                B = (n * 11 + 170) % 256;
            }
            bufferBaseIdx = (y * (MaxX + 1) + x) * MandelBytesPerPixel;
            pixelData[bufferBaseIdx] = R;
            pixelData[bufferBaseIdx + 1] = G;
            pixelData[bufferBaseIdx + 2] = B;
            pixelData[bufferBaseIdx + 3] = 255;
        }
        rowDone[y] = 1;
        unlock(rowMutex);
    }
}

void computeRowsThread0() { computeRows(threadStart[0], threadEnd[0]); }
void computeRowsThread1() { computeRows(threadStart[1], threadEnd[1]); }
void computeRowsThread2() { computeRows(threadStart[2], threadEnd[2]); }
void computeRowsThread3() { computeRows(threadStart[3], threadEnd[3]); }

void renderMandelbrot() {
    int i, startY, endY, rowsPerThread, extra, tid[4], y, done, needRedraw;

    for (i = 0; i <= MaxY; i++) rowDone[i] = 0;

    rowsPerThread = (MaxY + 1) / threadCount;
    extra = (MaxY + 1) % threadCount;
    startY = 0;
    for (i = 0; i < threadCount; i++) {
        endY = startY + rowsPerThread - 1;
        if (extra > 0) { endY++; extra--; }
        threadStart[i] = startY;
        threadEnd[i] = endY;
        startY = endY + 1;
    }

    tid[0] = spawn computeRowsThread0();
    tid[1] = spawn computeRowsThread1();
    tid[2] = spawn computeRowsThread2();
    tid[3] = spawn computeRowsThread3();

    y = 0;
    while (y <= MaxY && !getQuit()) {
        lock(rowMutex);
        done = rowDone[y];
        needRedraw = 0;
        if (done) {
            if (((y + 1) % ScreenUpdateInterval) == 0 || y == MaxY) {
                updatetexture(textureID, pixelData);
                needRedraw = 1;
            }
            y++;
        }
        unlock(rowMutex);
        if (needRedraw) {
            cleardevice();
            rendercopy(textureID);
            updatescreen();
        } else if (!done) {
            delay(0);
        }
    }

    for (i = 0; i < threadCount; i++)
        join tid[i];
}

int main() {
    int mouseX, mouseY, buttons, prev_buttons = 0;


    printf("Threaded Mandelbrot (mandelbrotrow). Left click to zoom in, right click to zoom out, middle click to reset. Press Q in the console to quit.\n");
    initgraph(WindowWidth, WindowHeight, "Threaded Mandelbrot (mandelbrotrow)");
    textureID = createtexture(WindowWidth, WindowHeight);
    if (textureID < 0) { printf("Error: unable to create texture.\n"); halt(); }
    cleardevice(); updatescreen();
    MaxX = getmaxx(); MaxY = getmaxy();

    rowMutex = mutex();
    quitMutex = mutex();

    resetView();
    renderMandelbrot();

    while (!getQuit()) {
        graphloop(16);
        if (keypressed()) {
            char c = readkey();
            if (toupper(c) == 'Q') {
                setQuit(1);
            }
        }
        // GetMouseState uses VAR parameters, so we pass the variables directly
        // instead of their addresses. Passing pointers here prevents the
        // returned values from updating our variables, which made mouse clicks
        // appear unresponsive.
        getmousestate(mouseX, mouseY, buttons);
        if ((buttons & 1) && !(prev_buttons & 1)) {
            zoomAt(mouseX, mouseY, 0.5);
            renderMandelbrot();
        } else if ((buttons & 4) && !(prev_buttons & 4)) {
            zoomAt(mouseX, mouseY, 2.0);
            renderMandelbrot();
        } else if ((buttons & 2) && !(prev_buttons & 2)) {
            resetView();
            renderMandelbrot();
        }
        prev_buttons = buttons;
    }

    destroytexture(textureID); closegraph();
    return 0;

}

