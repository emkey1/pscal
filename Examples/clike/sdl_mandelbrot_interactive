#!/usr/bin/env clike
/*
 * SDL Mandelbrot renderer using the MandelbrotRow builtin with threading.
 * Left click to zoom in, right click to zoom out, Q to quit.
 */

const int Width = 1200;
const int Height = 900;
const int MaxIterations = 200;
const int BytesPerPixel = 4;
const int ScreenUpdateInterval = 1; /* update every row for responsiveness */
const double ZoomFactor = 2.0;
const int ThreadCount = 4;
const int ButtonLeft = 1;
const int ButtonRight = 4;
/* SDL keycodes for arrow keys */
const int KEY_LEFT = 1073741904;
const int KEY_RIGHT = 1073741903;
const int KEY_UP = 1073741906;
const int KEY_DOWN = 1073741905;

byte pixelData[Width * Height * BytesPerPixel];
int rowDone[Height];
int threadStart[ThreadCount];
int threadEnd[ThreadCount];

double minRe = -2.0;
double maxRe = 1.0;
double minIm = -1.2;
double maxIm;
double reFactor;
double imFactor;

int textureID;
int rowMutex;
int quitMutex;
int quit = 0;
int redraw = 1;
int prevButtons = 0;
int clickButton = 0, clickX = 0, clickY = 0;

#ifdef SDL_ENABLED
int getQuit() {
    int q;
    lock(quitMutex);
    q = quit;
    unlock(quitMutex);
    return q;
}

void setQuit(int v) {
    lock(quitMutex);
    quit = v;
    unlock(quitMutex);
}

int tryInitFont(str path, int fontSize) {
    /*
     * getenv() in the VM returns an empty string when the variable is not
     * present.  Comparing the string directly against NULL triggers a runtime
     * type error because strings cannot be compared with NIL in CLike.  Treat
     * an empty string as "not available" instead.
     */
    if (strlen(path) == 0) return 0;
    if (!fileexists(path)) return 0;
    inittextsystem(path, fontSize);
    return 1;
}

/*
 * Poll SDL briefly and detect a fresh left/right click that occurred inside
 * the window. Click coordinates are clamped to [0..Width-1]/[0..Height-1].
 * Sets (clickButton, clickX, clickY) when a new click is found.
 */
void pollMouse() {
    int x = 0, y = 0, b = 0;
    graphloop(1);           /* Pump events */
    getmousestate(&x, &y, &b);

    /* Fresh press detection: bit goes from 0 -> 1 */
    int freshLeft  = ((b & ButtonLeft)  != 0) && ((prevButtons & ButtonLeft)  == 0);
    int freshRight = ((b & ButtonRight) != 0) && ((prevButtons & ButtonRight) == 0);

    /* Use actual window dimensions to validate click is inside the window */
    int winW = getmaxx() + 1;  /* getmaxx returns max index */
    int winH = getmaxy() + 1;
    int inside = (x >= 0 && x < winW && y >= 0 && y < winH);
    if (!inside) {
        prevButtons = b;
        return; /* ignore clicks outside */
    }

    /* Map from window coordinates to texture coordinates if sizes differ */
    if (winW != Width && winW > 0) {
        x = (x * Width) / winW;
        if (x >= Width) x = Width - 1;
    }
    if (winH != Height && winH > 0) {
        y = (y * Height) / winH;
        if (y >= Height) y = Height - 1;
    }

    if (freshLeft) {
        clickButton = ButtonLeft;
        clickX = x;
        clickY = y;
        printf("DBG click: LEFT raw=(%d,%d) win=(%d,%d) scaled=(%d,%d) b=%d prev=%d\n",
               x, y, winW, winH, clickX, clickY, b, prevButtons);
    } else if (freshRight) {
        clickButton = ButtonRight;
        clickX = x;
        clickY = y;
        printf("DBG click: RIGHT raw=(%d,%d) win=(%d,%d) scaled=(%d,%d) b=%d prev=%d\n",
               x, y, winW, winH, clickX, clickY, b, prevButtons);
    }
    prevButtons = b;
}

void computeRows(int startY, int endY) {
    int row[Width], x, y, n, R, G, B, idx;
    double c_im;
    for (y = startY; y <= endY && !getQuit(); y++) {
        c_im = maxIm - y * imFactor;
        mandelbrotrow(minRe, reFactor, c_im, MaxIterations, Width - 1, &row);
        idx = y * Width * BytesPerPixel;
        for (x = 0; x < Width; x++) {
            n = row[x];
            if (n == MaxIterations) { R = G = B = 0; }
            else {
                R = (n * 5) % 256;
                G = (n * 7 + 85) % 256;
                B = (n * 11 + 170) % 256;
            }
            pixelData[idx + 0] = R;
            pixelData[idx + 1] = G;
            pixelData[idx + 2] = B;
            pixelData[idx + 3] = 255;
            idx += BytesPerPixel;
        }
        lock(rowMutex);
        rowDone[y] = 1;
        unlock(rowMutex);
    }
}

void computeRowsThread0() { computeRows(threadStart[0], threadEnd[0]); }
void computeRowsThread1() { computeRows(threadStart[1], threadEnd[1]); }
void computeRowsThread2() { computeRows(threadStart[2], threadEnd[2]); }
void computeRowsThread3() { computeRows(threadStart[3], threadEnd[3]); }
#endif

int main() {
#ifdef SDL_ENABLED
    int tid[ThreadCount], i, y, rowsPerThread, extra, startY, endY;
    int textReady;
    const int fontSize = 18;
    str envFontPath;
    double reStep, imStep, centerRe, centerIm, zoomScale, newWidth, newHeight;
    int keyCode;

    printf("Calculating Mandelbrot set. The window will update as rows are drawn...\n");
    initgraph(Width, Height, "Mandelbrot in CLike (threaded)");
    textReady = 0;
    envFontPath = getenv("PSCAL_FONT_PATH");
    if (!textReady) textReady = tryInitFont(envFontPath, fontSize);
    if (!textReady) textReady = tryInitFont("/usr/local/pscal/fonts/Roboto/static/Roboto-Regular.ttf", fontSize);
    if (!textReady) textReady = tryInitFont("/usr/local/share/pscal/fonts/Roboto/static/Roboto-Regular.ttf", fontSize);
    if (!textReady) textReady = tryInitFont("/usr/local/Pscal/fonts/Roboto/static/Roboto-Regular.ttf", fontSize);
    if (!textReady) textReady = tryInitFont("/usr/local/share/Pscal/fonts/Roboto/static/Roboto-Regular.ttf", fontSize);
    if (!textReady) textReady = tryInitFont("/Library/Pscal/fonts/Roboto/static/Roboto-Regular.ttf", fontSize);
    if (!textReady) textReady = tryInitFont("fonts/Roboto/static/Roboto-Regular.ttf", fontSize);
    if (!textReady) textReady = tryInitFont("../fonts/Roboto/static/Roboto-Regular.ttf", fontSize);
    if (!textReady) textReady = tryInitFont("../../fonts/Roboto/static/Roboto-Regular.ttf", fontSize);
    if (!textReady) {
        printf("Warning: Unable to locate Roboto font. Text rendering disabled.\n");
    }
    textureID = createtexture(Width, Height);
    if (textureID < 0) { printf("Error: unable to create texture.\n"); halt(); }
    cleardevice(); updatescreen();

    rowMutex = mutex();
    quitMutex = mutex();

    while (!getQuit()) {
        pollMouse();

        if (redraw) {
            maxIm = minIm + (maxRe - minRe) * Height / Width;
            reFactor = (maxRe - minRe) / (Width - 1);
            imFactor = (maxIm - minIm) / (Height - 1);
            for (i = 0; i < Height; i++) rowDone[i] = 0;

            rowsPerThread = Height / ThreadCount;
            extra = Height % ThreadCount;
            startY = 0;
            for (i = 0; i < ThreadCount; i++) {
                endY = startY + rowsPerThread - 1;
                if (extra > 0) { 
                    endY++; 
                    extra--; 
                }
                //printf("Thread(%d): startY: %d endY: %d\n", i, startY, endY);
                threadStart[i] = startY;
                threadEnd[i] = endY;
                startY = endY + 1;
            }

            tid[0] = spawn computeRowsThread0();
            tid[1] = spawn computeRowsThread1();
            tid[2] = spawn computeRowsThread2();
            tid[3] = spawn computeRowsThread3();

            y = 0;
            while (y < Height && !getQuit()) {
                int done = 0;
                int update = 0;
                lock(rowMutex);
                if (rowDone[y]) {
                    done = 1;
                    if (((y + 1) % ScreenUpdateInterval) == 0 || y == Height - 1) {
                        update = 1;
                    }
                }
                unlock(rowMutex);

                if (done)
                    y++;

                if (update) {
                    /* Upload pixels after releasing rowMutex so worker threads stay busy. */
                    updatetexture(textureID, pixelData);
                    cleardevice();
                    rendercopy(textureID);
                    updatescreen();
                }
                if (keypressed()) {
                    keyCode = readkey();
                    if (toupper(keyCode) == 'Q') setQuit(1);
                }
                if (!done || update)
                    pollMouse();
            }

            for (i = 0; i < ThreadCount; i++)
                join tid[i];

            if (!getQuit()) {
                updatetexture(textureID, pixelData);
                cleardevice();
                rendercopy(textureID);
                if (textReady) {
                    outtextxy(8, 8, "Rendering...");
                }
                updatescreen();
                redraw = 0;
            }
        }
        /* Keyboard controls: Q to quit, arrows to pan by half a screen */
        {
            int key = pollkey();
            if (key != 0) {
                if (key == 'q' || key == 'Q') {
                    setQuit(1);
                    continue;
                }
                double widthRe = (maxRe - minRe);
                double heightIm = (maxIm - minIm);
                double dx = widthRe * 0.5;
                double dy = heightIm * 0.5;
                if (key == KEY_LEFT) {
                    minRe -= dx; maxRe -= dx; redraw = 1;
                } else if (key == KEY_RIGHT) {
                    minRe += dx; maxRe += dx; redraw = 1;
                } else if (key == KEY_UP) {
                    /* Move view up in complex plane: increase both Im bounds */
                    minIm += dy; maxIm += dy; redraw = 1;
                } else if (key == KEY_DOWN) {
                    /* Move view down: decrease both Im bounds */
                    minIm -= dy; maxIm -= dy; redraw = 1;
                }
            }
        }

        if (clickButton == ButtonLeft || clickButton == ButtonRight) {
            /* Map pixel -> complex plane using current ranges (center of pixel). */
            reStep = (maxRe - minRe) / (Width - 1);
            imStep = (maxIm - minIm) / (Height - 1);
            centerRe = minRe + (clickX + 0.5) * reStep;
            centerIm = maxIm - (clickY + 0.5) * imStep;
            zoomScale = (clickButton == ButtonLeft)
                           ? (1.0 / ZoomFactor)
                           : ZoomFactor;
            newWidth = (maxRe - minRe) * zoomScale;
            newHeight = (maxIm - minIm) * zoomScale;

            printf("DBG zoom: button=%s click=(%d,%d) reStep=%0.9f imStep=%0.9f\n",
                   (clickButton==ButtonLeft?"LEFT":"RIGHT"), clickX, clickY,
                   reStep, imStep);
            printf("DBG zoom: before minRe=%0.9f maxRe=%0.9f minIm=%0.9f maxIm=%0.9f\n",
                   minRe, maxRe, minIm, maxIm);
            printf("DBG zoom: centerRe=%0.9f centerIm=%0.9f newWidth=%0.9f newHeight=%0.9f scale=%0.9f\n",
                   centerRe, centerIm, newWidth, newHeight, zoomScale);

            minRe = centerRe - newWidth / 2.0;
            maxRe = centerRe + newWidth / 2.0;
            minIm = centerIm - newHeight / 2.0;
            maxIm = centerIm + newHeight / 2.0;
            printf("DBG zoom: after  minRe=%0.9f maxRe=%0.9f minIm=%0.9f maxIm=%0.9f\n",
                   minRe, maxRe, minIm, maxIm);

            redraw = 1;
            clickButton = 0; /* consume click */
        }
    }
    destroytexture(textureID);
    if (textReady) {
        quittextsystem();
    }
    closegraph();
    return 0;
#else
    printf("SDL support not enabled.\n");
    return 1;
#endif
}
