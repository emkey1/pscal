#!/usr/bin/env clike
/*
 * SDL Mandelbrot renderer using the MandelbrotRow builtin.
 * Left click to zoom in, right click to zoom out, Q to quit.
 */

int main() {
    int width = 1600;
    int height = 900;
    int maxIterations = 200;
    double minRe = -2.0;
    double maxRe = 1.0;
    double minIm = -1.2;
    double maxIm;
    double reFactor;
    double imFactor;
    double zoomFactor = 4.0;

    int bytesPerPixel = 4;
    int row[width];
    byte pixelData[width * height * bytesPerPixel];
    int textureID;
    int screenUpdateInterval = 16; // update screen every 16 rows
    int quit = 0;
    int redraw = 1;
    int mouseX = 0, mouseY = 0, mouseButtons = 0, prevButtons = 0;
    int ButtonLeft = 1;
    int ButtonRight = 4;

    printf("Calculating Mandelbrot set. The window will update as rows are drawn...\n");
    initgraph(width, height, "Mandelbrot in CLike (builtin)");
    textureID = createtexture(width, height);
    if (textureID < 0) {
        printf("Error: unable to create texture.\n");
        halt();
    }
    cleardevice();
    updatescreen();

    int n,R,G,B;

    while (!quit) {
        if (redraw) {
            maxIm = minIm + (maxRe - minRe) * height / width;
            reFactor = (maxRe - minRe) / (width - 1);
            imFactor = (maxIm - minIm) / (height - 1);
            for (int y = 0; y < height; y++) {
                double c_im = maxIm - y * imFactor;
                mandelbrotrow(minRe, reFactor, c_im, maxIterations, width - 1, &row);
                int idx = y * width * bytesPerPixel;
                for (int x = 0; x < width; x++) {
                    n = row[x];
                    if (n == maxIterations) {
                        R = 0;
                        G = 0;
                        B = 0;
                    } else {
                        R = (n * 5) % 256;
                        G = (n * 7 + 85) % 256;
                        B = (n * 11 + 170) % 256;
                    }
                    pixelData[idx + 0] = R;
                    pixelData[idx + 1] = G;
                    pixelData[idx + 2] = B;
                    pixelData[idx + 3] = 255;
                    idx += bytesPerPixel;
                }
                if (((y + 1) % screenUpdateInterval) == 0 || y == height - 1) {
                    updatetexture(textureID, pixelData);
                    cleardevice();
                    rendercopy(textureID);
                    updatescreen();
                    graphloop(0);
                }
            }
            updatetexture(textureID, pixelData);
            cleardevice();
            rendercopy(textureID);
            updatescreen();
            redraw = 0;
        }

        if (keypressed()) {
            char c = readkey();
            if (upcase(c) == 'Q') {
                quit = 1;
            }
        }

        getmousestate(&mouseX, &mouseY, &mouseButtons);
        if (((mouseButtons & ButtonLeft) != 0) && ((prevButtons & ButtonLeft) == 0)) {
            double centerRe = minRe + mouseX * reFactor;
            double centerIm = maxIm - mouseY * imFactor;
            double newWidth = (maxRe - minRe) / zoomFactor;
            double newHeight = (maxIm - minIm) / zoomFactor;
            minRe = centerRe - newWidth / 2.0;
            maxRe = centerRe + newWidth / 2.0;
            minIm = centerIm - newHeight / 2.0;
            redraw = 1;
        } else if (((mouseButtons & ButtonRight) != 0) && ((prevButtons & ButtonRight) == 0)) {
            double centerRe = minRe + mouseX * reFactor;
            double centerIm = maxIm - mouseY * imFactor;
            double newWidth = (maxRe - minRe) * zoomFactor;
            double newHeight = (maxIm - minIm) * zoomFactor;
            minRe = centerRe - newWidth / 2.0;
            maxRe = centerRe + newWidth / 2.0;
            minIm = centerIm - newHeight / 2.0;
            redraw = 1;
        }
        prevButtons = mouseButtons;

        graphloop(16);
    }

    destroytexture(textureID);
    closegraph();
    return 0;
}
