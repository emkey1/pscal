{
  "version": 1,
  "default_extension": "rea",
  "notes": "Generated by build_manifest.py",
  "tests": [
    {
      "id": "block_shadow_preserves_outer",
      "name": "Shadowing preserves outer value",
      "category": "block_scope",
      "description": "Inner block shadows outer variable without mutating the outer binding.",
      "expect": "runtime_ok",
      "code": "int main() {\n    int outer = 1;\n    printf(\"outer=%d, \", outer);\n    {\n        int outer = 2;\n        printf(\"inner=%d, \", outer);\n    }\n    printf(\"outer_after=%d\", outer);\n    return 0;\n}",
      "expected_stdout": "outer=1, inner=2, outer_after=1"
    },
    {
      "id": "block_conditional_inner_isolated",
      "name": "Conditional block keeps locals isolated",
      "category": "block_scope",
      "description": "Variables declared inside a conditional do not leak and outer bindings stay intact.",
      "expect": "runtime_ok",
      "code": "int main() {\n    int flag = 1;\n    int total = 0;\n    if (flag > 0) {\n        int flag = 5;\n        total = total + flag;\n    }\n    writeln(\"total=\", total);\n    writeln(\"flag=\", flag);\n    return 0;\n}",
      "expected_stdout": "total=5\nflag=1"
    },
    {
      "id": "block_loop_variable_redeclare",
      "name": "Loop variable confined to loop scope",
      "category": "block_scope",
      "description": "Loop index is confined to the loop body so a new binding may reuse the name afterward.",
      "expect": "runtime_ok",
      "code": "int main() {\n    int sum = 0;\n    for (int i = 0; i < 3; i = i + 1) {\n        sum = sum + i;\n    }\n    int i = 42;\n    writeln(\"loop_sum=\", sum, \", after=\", i);\n    return 0;\n}",
      "expected_stdout": "loop_sum=3, after=42"
    },
    {
      "id": "block_inner_reference_error",
      "name": "Referencing inner binding after block",
      "category": "block_scope",
      "description": "Using a block-local variable after the block should be rejected.",
      "expect": "compile_error",
      "code": "int main() {\n    {\n        int hidden = 3;\n    }\n    return hidden;\n}",
      "expected_stderr_substring": "not in scope",
      "failure_reason": "Block locals must not be reachable after the block closes."
    },
    {
      "id": "block_duplicate_declaration_error",
      "name": "Duplicate binding within same scope",
      "category": "block_scope",
      "description": "Redeclaring an identifier in the same block is illegal.",
      "expect": "compile_error",
      "code": "int main() {\n    int value = 1;\n    int value = 2;\n    return value;\n}",
      "expected_stderr_substring": "duplicate",
      "failure_reason": "The compiler must reject duplicate declarations in one scope."
    },
    {
      "id": "block_loop_variable_leak_error",
      "name": "Loop index not visible outside",
      "category": "block_scope",
      "description": "Loop indices cannot be referenced after the loop completes.",
      "expect": "compile_error",
      "code": "int main() {\n    for (int i = 0; i < 2; i = i + 1) {\n        writeln(i);\n    }\n    return i;\n}",
      "expected_stderr_substring": "not in scope",
      "failure_reason": "For-loop locals must not leak into the enclosing scope."
    },
    {
      "id": "block_random_shadowing_ok",
      "name": "Randomised shadowing respects scope",
      "category": "block_scope",
      "description": "Random identifiers and nested braces still preserve lexical scope.",
      "expect": "runtime_ok",
      "code": "        int main() {\n            int {{outer_name}} = 10;\n{{shadow_block}}\n            writeln(\"after=\", {{outer_name}});\n            return 0;\n        }",
      "expected_stdout": "shadow-ok\nafter=10",
      "placeholders": {
        "outer_name": {
          "type": "identifier",
          "min_length": 5,
          "ensure_unique": true
        },
        "shadow_block": {
          "type": "nested_block",
          "indent": "    ",
          "min_depth": 1,
          "max_depth": 3,
          "header": "if (true)",
          "placeholders": {
            "shadow_name": {
              "type": "identifier",
              "min_length": 5,
              "avoid_placeholders": [
                "outer_name"
              ]
            },
            "delta_val": {
              "type": "int",
              "min": 1,
              "max": 3
            },
            "end_comment": {
              "type": "comment",
              "words": [
                "random",
                "block"
              ]
            }
          },
          "body": [
            "int {{shadow_name}} = {{outer_name}} + {{delta_val}};",
            "if ({{shadow_name}} > 0) {",
            "    writeln(\"shadow-ok\");",
            "}"
          ],
          "trailing": "{{end_comment}}"
        }
      }
    },
    {
      "id": "block_random_leak_error",
      "name": "Randomised leak is rejected",
      "category": "block_scope",
      "description": "Random identifiers still cannot escape their block scope.",
      "expect": "compile_error",
      "code": "int main() {\n    if (true) {\n        int {{temp_name}} = 5;\n        writeln({{temp_name}});\n    }\n    return {{temp_name}};\n}",
      "expected_stderr_substring": "not in scope",
      "failure_reason": "Identifiers introduced in conditional blocks must not be visible outside.",
      "placeholders": {
        "temp_name": {
          "type": "identifier",
          "min_length": 4
        }
      }
    },
    {
      "id": "function_parameter_shadows_global",
      "name": "Parameter shadows outer binding",
      "category": "function_scope",
      "description": "Function parameters hide globals of the same name without mutating them.",
      "expect": "runtime_ok",
      "code": "int total = 7;\nint bump(int total) {\n    return total + 1;\n}\nint main() {\n    writeln(\"bump=\", bump(3));\n    writeln(\"global=\", total);\n    return 0;\n}",
      "expected_stdout": "bump=4\nglobal=7"
    },
    {
      "id": "function_default_param_reads_outer",
      "name": "Default argument sees lexical scope",
      "category": "function_scope",
      "description": "Default parameter expressions evaluate in the enclosing lexical environment.",
      "expect": "runtime_ok",
      "code": "const int BASE = 5;\nint adjust(int value = BASE) {\n    return value + 2;\n}\nint main() {\n    writeln(\"default=\", adjust());\n    writeln(\"explicit=\", adjust(3));\n    return 0;\n}",
      "expected_stdout": "default=7\nexplicit=5"
    },
    {
      "id": "function_mutual_recursion_scope",
      "name": "Mutual recursion keeps locals private",
      "category": "function_scope",
      "description": "Nested recursion should not pollute outer scopes or rely on shared locals.",
      "expect": "runtime_ok",
      "code": "int oddSum(int n);\nint evenSum(int n) {\n    if (n <= 0) {\n        return 0;\n    }\n    return n + oddSum(n - 1);\n}\nint oddSum(int n) {\n    if (n <= 0) {\n        return 0;\n    }\n    return n + evenSum(n - 1);\n}\nint main() {\n    writeln(\"sum=\", evenSum(4));\n    return 0;\n}",
      "expected_stdout": "sum=10"
    },
    {
      "id": "function_duplicate_parameter_error",
      "name": "Duplicate parameter names rejected",
      "category": "function_scope",
      "description": "A function may not define two parameters with the same identifier.",
      "expect": "compile_error",
      "code": "int clash(int value, int value) {\n    return value;\n}\nint main() {\n    return clash(1, 2);\n}",
      "expected_stderr_substring": "duplicate",
      "failure_reason": "Parameter lists must have unique identifiers per function signature."
    },
    {
      "id": "function_parameter_leak_error",
      "name": "Parameter visibility limited to function",
      "category": "function_scope",
      "description": "Parameters cannot be referenced outside of their defining function.",
      "expect": "compile_error",
      "code": "int box(int payload) {\n    return payload + 1;\n}\nint main() {\n    box(41);\n    return payload;\n}",
      "expected_stderr_substring": "not in scope",
      "failure_reason": "Function parameters must not leak into caller scope."
    },
    {
      "id": "function_forward_reference_local_error",
      "name": "Locals are not globally visible",
      "category": "function_scope",
      "description": "Another function cannot access a local variable defined elsewhere.",
      "expect": "compile_error",
      "code": "int helper() {\n    return scratch;\n}\nint main() {\n    int scratch = 9;\n    return helper();\n}",
      "expected_stderr_substring": "not in scope",
      "failure_reason": "Locals belong to their function activation only."
    },
    {
      "id": "function_random_shadowing_ok",
      "name": "Randomised parameter shadow",
      "category": "function_scope",
      "description": "Seeded random identifiers still respect function scope and globals.",
      "expect": "runtime_ok",
      "code": "int {{global_name}} = 2;\nint {{func_name}}(int {{param_name}}) {\n    int {{local_name}} = {{param_name}} + {{global_name}};\n    writeln(\"inner-ok\");\n    return {{param_name}} - {{global_name}};\n}\nint main() {\n    writeln(\"result=\", {{func_name}}(5));\n    writeln(\"global=\", {{global_name}});\n    return 0;\n}",
      "expected_stdout": "inner-ok\nresult=3\nglobal=2",
      "placeholders": {
        "global_name": {
          "type": "identifier",
          "min_length": 5
        },
        "func_name": {
          "type": "identifier",
          "min_length": 5,
          "avoid_placeholders": [
            "global_name"
          ]
        },
        "param_name": {
          "type": "identifier",
          "min_length": 4,
          "avoid_placeholders": [
            "global_name",
            "func_name"
          ]
        },
        "local_name": {
          "type": "identifier",
          "min_length": 4,
          "avoid_placeholders": [
            "global_name",
            "func_name",
            "param_name"
          ]
        }
      }
    },
    {
      "id": "function_random_leak_error",
      "name": "Randomised parameter leak rejected",
      "category": "function_scope",
      "description": "Seeded random names still cannot leak parameters outside the function.",
      "expect": "compile_error",
      "code": "int {{builder_name}}(int {{param_name}}) {\n    return {{param_name}};\n}\nint main() {\n    {{builder_name}}(1);\n    return {{param_name}};\n}",
      "expected_stderr_substring": "not in scope",
      "failure_reason": "Function parameters are local to their defining function.",
      "placeholders": {
        "builder_name": {
          "type": "identifier",
          "min_length": 5
        },
        "param_name": {
          "type": "identifier",
          "min_length": 4
        }
      }
    },
    {
      "id": "closure_reference_capture_runtime",
      "name": "Closure captures by reference",
      "category": "closure_scope",
      "description": "A nested function observes the updated outer variable on subsequent calls.",
      "expect": "runtime_ok",
      "code": "int main() {\n    int base = 3;\n    int add(int delta) {\n        return base + delta;\n    }\n    writeln(\"first=\", add(2));\n    base = 10;\n    writeln(\"second=\", add(1));\n    return 0;\n}",
      "expected_stdout": "first=5\nsecond=11"
    },
    {
      "id": "closure_incrementer_stateful",
      "name": "Closure keeps private state",
      "category": "closure_scope",
      "description": "A closure mutates an outer variable each time it executes.",
      "expect": "runtime_ok",
      "code": "int main() {\n    int counter = 0;\n    int inc() {\n        counter = counter + 1;\n        return counter;\n    }\n    writeln(\"inc1=\", inc());\n    writeln(\"inc2=\", inc());\n    return 0;\n}",
      "expected_stdout": "inc1=1\ninc2=2"
    },
    {
      "id": "closure_nested_capture",
      "name": "Nested closures capture multiple levels",
      "category": "closure_scope",
      "description": "An inner closure sees both its parent's locals and outer lexical bindings.",
      "expect": "runtime_ok",
      "code": "int main() {\n    int factor = 2;\n    int outer(int n) {\n        int inner(int m) {\n            return (n + m) * factor;\n        }\n        return inner(3);\n    }\n    writeln(\"combo=\", outer(4));\n    return 0;\n}",
      "expected_stdout": "combo=14"
    },
    {
      "id": "closure_escape_local_error",
      "name": "Escaping closure carries its locals",
      "category": "closure_scope",
      "description": "Returning a closure that captures a local now yields a callable value that updates its environment.",
      "expect": "runtime_ok",
      "code": "int (*makeAdder(int seed))(int) {\n    int base = seed;\n    int inner(int delta) {\n        base = base + delta;\n        return base;\n    }\n    return inner;\n}\nint main() {\n    int (*adder)(int) = makeAdder(5);\n    writeln(\"first=\", adder(2));\n    writeln(\"second=\", adder(3));\n    return 0;\n}",
      "expected_stdout": "first=7\nsecond=10"
    },
    {
      "id": "closure_loop_capture_error",
      "name": "Loop capture survives past the loop",
      "category": "closure_scope",
      "description": "Closures capturing loop indices can be stored and invoked after the loop completes.",
      "expect": "runtime_ok",
      "code": "int (*saved)(void);\nint main() {\n    for (int i = 1; i <= 3; i = i + 1) {\n        int capture(void) {\n            return i;\n        }\n        saved = capture;\n    }\n    writeln(\"value=\", saved());\n    writeln(\"again=\", saved());\n    return 0;\n}",
      "expected_stdout": "value=3\nagain=3"
    },
    {
      "id": "closure_missing_capture_error",
      "name": "Closure referencing unknown name",
      "category": "closure_scope",
      "description": "Closures must fail when referencing identifiers that are not in scope.",
      "expect": "compile_error",
      "code": "int main() {\n    int outer = 3;\n    int inner() {\n        return ghost + outer;\n    }\n    return inner();\n}",
      "expected_stderr_substring": "ghost",
      "failure_reason": "Lexical resolution inside closures must match normal scope rules."
    },
    {
      "id": "closure_random_reference_capture",
      "name": "Randomised closure retains reference",
      "category": "closure_scope",
      "description": "Random identifiers and extra braces still capture the correct outer binding.",
      "expect": "runtime_ok",
      "code": "        int main() {\n            int {{outer_name}} = 5;\n            int {{inner_name}}(int {{param_name}}) {\n                {{outer_name}} = {{outer_name}} + {{param_name}};\n                writeln(\"close-ok\");\n                return {{outer_name}};\n            }\n{{invoke_block}}\n            writeln(\"final=\", {{outer_name}});\n            return 0;\n        }",
      "expected_stdout": "close-ok\ndone 6\nfinal=6",
      "placeholders": {
        "outer_name": {
          "type": "identifier",
          "min_length": 5
        },
        "inner_name": {
          "type": "identifier",
          "min_length": 5,
          "avoid_placeholders": [
            "outer_name"
          ]
        },
        "param_name": {
          "type": "identifier",
          "min_length": 3,
          "avoid_placeholders": [
            "outer_name",
            "inner_name"
          ]
        },
        "invoke_block": {
          "type": "nested_block",
          "indent": "    ",
          "min_depth": 1,
          "max_depth": 2,
          "header": "if (true)",
          "placeholders": {
            "block_comment": {
              "type": "comment",
              "words": [
                "closure",
                "random"
              ]
            }
          },
          "body": [
            "writeln(\"done\", {{inner_name}}(1));"
          ],
          "trailing": "{{block_comment}}"
        }
      }
    },
    {
      "id": "closure_random_escape_error",
      "name": "Randomised escaping closure rejected",
      "category": "closure_scope",
      "description": "Random identifiers still cannot allow a closure that captures locals to escape.",
      "expect": "compile_error",
      "code": "int (*{{maker_name}}(int seed))(int) {\n    int {{captured_name}} = seed;\n    int {{inner_name}}(int delta) {\n        return {{captured_name}} + delta;\n    }\n    return {{inner_name}};\n}\nint main() {\n    int (*{{alias_name}})(int) = {{maker_name}}(2);\n    return {{alias_name}}(1);\n}",
      "expected_stderr_substring": "lifetime",
      "failure_reason": "Escaping closures must fail regardless of identifier spelling.",
      "placeholders": {
        "maker_name": {
          "type": "identifier",
          "min_length": 5
        },
        "captured_name": {
          "type": "identifier",
          "min_length": 5
        },
        "inner_name": {
          "type": "identifier",
          "min_length": 5
        },
        "alias_name": {
          "type": "identifier",
          "min_length": 5
        }
      }
    },
    {
      "id": "module_public_symbol_visible",
      "name": "Imported module exposes public symbols",
      "category": "module_scope",
      "description": "An imported module makes exported functions available to the caller.",
      "expect": "runtime_ok",
      "code": "#import \"{{support_dir}}/modules/mod_public.rea\";\nint main() {\n    writeln(\"value=\", ModPublic.getValue());\n    return 0;\n}",
      "expected_stdout": "value=12",
      "files": [
        {
          "path": "modules/mod_public.rea",
          "code": "module ModPublic {\n    export const int VALUE = 12;\n    export int getValue() {\n        return VALUE;\n    }\n    const int hiddenHelper = 99;\n}"
        }
      ]
    },
    {
      "id": "module_alias_local_precedence",
      "name": "Local symbol beats imported alias",
      "category": "module_scope",
      "description": "A locally declared symbol hides an imported one of the same simple name.",
      "expect": "runtime_ok",
      "code": "#import \"{{support_dir}}/modules/mod_alias_base.rea\" as DataModule;\nint answer() {\n    return 1;\n}\nint main() {\n    writeln(\"local=\", answer());\n    writeln(\"qualified=\", DataModule.answer());\n    return 0;\n}",
      "expected_stdout": "local=1\nqualified=42",
      "files": [
        {
          "path": "modules/mod_alias_base.rea",
          "code": "module DataModule {\n    export int answer() {\n        return 42;\n    }\n}"
        }
      ]
    },
    {
      "id": "module_reexport_transitive",
      "name": "Re-export forwards symbols",
      "category": "module_scope",
      "description": "Modules may re-export imports so downstream users see the forwarded names.",
      "expect": "runtime_ok",
      "code": "#import \"{{support_dir}}/modules/layer_b.rea\";\nint main() {\n    writeln(\"forward=\", LayerB.forwarded());\n    return 0;\n}",
      "expected_stdout": "forward=9",
      "files": [
        {
          "path": "modules/layer_a.rea",
          "code": "module LayerA {\n    export const int VALUE = 9;\n    export int forwarded() {\n        return VALUE;\n    }\n}"
        },
        {
          "path": "modules/layer_b.rea",
          "code": "#import \"{{support_dir}}/modules/layer_a.rea\";\nmodule LayerB {\n    export int forwarded() {\n        return LayerA.forwarded();\n    }\n}"
        }
      ]
    },
    {
      "id": "module_private_symbol_hidden_error",
      "name": "Private module member is hidden",
      "category": "module_scope",
      "description": "Attempting to reference a non-exported module member must fail.",
      "expect": "compile_error",
      "code": "#import \"{{support_dir}}/modules/mod_private.rea\";\nint main() {\n    return ModPrivate.secret;\n}",
      "expected_stderr_substring": "not exported",
      "failure_reason": "Non-exported module members must remain private to the module.",
      "files": [
        {
          "path": "modules/mod_private.rea",
          "code": "module ModPrivate {\n    const int secret = 77;\n    export int surface() {\n        return secret;\n    }\n}"
        }
      ]
    },
    {
      "id": "module_alias_unqualified_error",
      "name": "Alias requires qualification",
      "category": "module_scope",
      "description": "Using an aliased module member without its alias qualifier should fail.",
      "expect": "compile_error",
      "code": "#import \"{{support_dir}}/modules/mod_util.rea\" as Util;\nint main() {\n    return helper();\n}",
      "expected_stderr_substring": "not in scope",
      "failure_reason": "Aliased imports must be referenced through the chosen alias.",
      "files": [
        {
          "path": "modules/mod_util.rea",
          "code": "module Util {\n    export int helper() {\n        return 5;\n    }\n}"
        }
      ]
    },
    {
      "id": "module_conflicting_import_error",
      "name": "Ambiguous import rejected",
      "category": "module_scope",
      "description": "Conflicting imported symbols with the same name must trigger an ambiguity error.",
      "expect": "compile_error",
      "code": "#import \"{{support_dir}}/modules/mod_left.rea\";\n#import \"{{support_dir}}/modules/mod_right.rea\";\nint main() {\n    return shared();\n}",
      "expected_stderr_substring": "ambiguous",
      "failure_reason": "Using an unqualified name shared by imports should be diagnosed as ambiguous.",
      "files": [
        {
          "path": "modules/mod_left.rea",
          "code": "module Left {\n    export int shared() {\n        return 1;\n    }\n}"
        },
        {
          "path": "modules/mod_right.rea",
          "code": "module Right {\n    export int shared() {\n        return 2;\n    }\n}"
        }
      ]
    },
    {
      "id": "module_random_alias_pass",
      "name": "Random alias import succeeds",
      "category": "module_scope",
      "description": "Randomised module and alias names still resolve correctly with qualification.",
      "expect": "runtime_ok",
      "code": "#import \"{{support_dir}}/modules/{{module_file}}\" as {{alias_name}};\nint main() {\n    writeln(\"module-ok\", {{alias_name}}.fingerprint());\n    return 0;\n}",
      "expected_stdout": "module-ok 314",
      "placeholders": {
        "module_file": {
          "type": "literal",
          "value": "mod_rand.rea"
        },
        "alias_name": {
          "type": "identifier",
          "min_length": 5
        }
      },
      "files": [
        {
          "path": "modules/mod_rand.rea",
          "code": "module RandMod {\n    export int fingerprint() {\n        return 314;\n    }\n}"
        }
      ]
    },
    {
      "id": "module_random_ambiguous_error",
      "name": "Random ambiguous import rejected",
      "category": "module_scope",
      "description": "Randomised conflicting import names must still be reported as ambiguous.",
      "expect": "compile_error",
      "code": "#import \"{{support_dir}}/modules/mod_x.rea\";\n#import \"{{support_dir}}/modules/mod_y.rea\";\nint main() {\n    return {{conflict_name}}();\n}",
      "expected_stderr_substring": "ambiguous",
      "failure_reason": "Ambiguity diagnostics must not depend on identifier spelling.",
      "placeholders": {
        "conflict_name": {
          "type": "literal",
          "value": "shared"
        }
      },
      "files": [
        {
          "path": "modules/mod_x.rea",
          "code": "module XMod {\n    export int shared() {\n        return 12;\n    }\n}"
        },
        {
          "path": "modules/mod_y.rea",
          "code": "module YMod {\n    export int shared() {\n        return 18;\n    }\n}"
        }
      ]
    },
    {
      "id": "const_global_visible_in_blocks",
      "name": "Global constant visible everywhere",
      "category": "const_scope",
      "description": "Global constants remain readable inside nested blocks without mutation.",
      "expect": "runtime_ok",
      "code": "const int LIMIT = 7;\nint main() {\n    int total = LIMIT + 3;\n    writeln(\"total=\", total);\n    return 0;\n}",
      "expected_stdout": "total=10"
    },
    {
      "id": "const_shadow_by_local_allowed",
      "name": "Mutable shadow of const allowed",
      "category": "const_scope",
      "description": "A local mutable binding may shadow a constant without altering the constant value.",
      "expect": "runtime_ok",
      "code": "const int LIMIT = 5;\nint main() {\n    int globalCopy = LIMIT;\n    int LIMIT = 2;\n    writeln(\"local=\", LIMIT);\n    writeln(\"global=\", globalCopy);\n    return 0;\n}",
      "expected_stdout": "local=2\nglobal=5"
    },
    {
      "id": "const_function_scope_independent",
      "name": "Function-scoped const independent",
      "category": "const_scope",
      "description": "Constants declared inside functions should not collide with outer constants.",
      "expect": "runtime_ok",
      "code": "const int LIMIT = 4;\nint compute() {\n    const int LIMIT = 2;\n    return LIMIT;\n}\nint main() {\n    writeln(\"inner=\", compute());\n    writeln(\"outer=\", LIMIT);\n    return 0;\n}",
      "expected_stdout": "inner=2\nouter=4"
    },
    {
      "id": "const_reassignment_error",
      "name": "Direct reassignment of const fails",
      "category": "const_scope",
      "description": "Reassigning a constant should produce an error.",
      "expect": "compile_error",
      "code": "const int LIMIT = 5;\nint main() {\n    LIMIT = 6;\n    return 0;\n}",
      "expected_stderr_substring": "const",
      "failure_reason": "Constants must be immutable after initialization."
    },
    {
      "id": "const_block_reassignment_error",
      "name": "Block reassignment of const fails",
      "category": "const_scope",
      "description": "Constants remain immutable even when referenced inside nested blocks.",
      "expect": "compile_error",
      "code": "const int LIMIT = 5;\nint main() {\n    if (true) {\n        LIMIT = LIMIT + 1;\n    }\n    return LIMIT;\n}",
      "expected_stderr_substring": "const",
      "failure_reason": "Nested blocks must respect constant immutability."
    },
    {
      "id": "const_shadow_const_mutation_error",
      "name": "Shadowed const still immutable",
      "category": "const_scope",
      "description": "Shadowing a constant with another constant keeps immutability enforcement.",
      "expect": "compile_error",
      "code": "int main() {\n    const int LIMIT = 3;\n    const int LIMIT = 4;\n    LIMIT = 5;\n    return LIMIT;\n}",
      "expected_stderr_substring": "const",
      "failure_reason": "Constant shadow should not permit reassignment."
    },
    {
      "id": "const_class_member_initializer_uses_prior_const",
      "name": "Class const initialisers see earlier consts",
      "category": "const_scope",
      "description": "Constants declared inside a class may reference earlier constants from the same class.",
      "expect": "runtime_ok",
      "code": "const int GLOBAL_SHIFT = 3;\n\nclass Layout {\n    const int BaseY = 10;\n    const int Height = BaseY + GLOBAL_SHIFT + 2;\n    int captured;\n\n    void Layout() {\n        myself.captured = Height;\n    }\n\n    int combined() {\n        return Height + BaseY;\n    }\n}\n\nint main() {\n    Layout layout = new Layout();\n    writeln(\"captured=\", layout.captured);\n    writeln(\"combined=\", layout.combined());\n    return 0;\n}",
      "expected_stdout": "captured=15\ncombined=25"
    },
    {
      "id": "const_random_shadow_pass",
      "name": "Randomised const shadow allowed",
      "category": "const_scope",
      "description": "Random identifiers demonstrate const shadowing with unique local names.",
      "expect": "runtime_ok",
      "code": "const int {{const_name}} = 8;\nint main() {\n    int {{local_name}} = {{const_name}} - 3;\n    writeln(\"shadow-const=\", {{const_name}});\n    writeln(\"shadow-local=\", {{local_name}});\n    return 0;\n}",
      "expected_stdout": "shadow-const=8\nshadow-local=5",
      "placeholders": {
        "const_name": {
          "type": "identifier",
          "min_length": 5
        },
        "local_name": {
          "type": "identifier",
          "min_length": 5,
          "avoid_placeholders": [
            "const_name"
          ]
        }
      }
    },
    {
      "id": "const_random_assign_error",
      "name": "Randomised const reassignment rejected",
      "category": "const_scope",
      "description": "Random identifier names still trigger errors when const bindings are reassigned.",
      "expect": "compile_error",
      "code": "const int {{const_name}} = 3;\nint main() {\n    {{const_name}} = 4;\n    return {{const_name}};\n}",
      "expected_stderr_substring": "const",
      "failure_reason": "Const immutability must not depend on identifier spelling.",
      "placeholders": {
        "const_name": {
          "type": "identifier",
          "min_length": 4
        }
      }
    },
    {
      "id": "type_alias_basic_usage",
      "name": "Type alias introduces new name",
      "category": "type_scope",
      "description": "A simple type alias can be used as a type without affecting values.",
      "expect": "runtime_ok",
      "code": "type alias Count = int;\nint main() {\n    Count value = 5;\n    writeln(\"count=\", value);\n    return 0;\n}",
      "expected_stdout": "count=5"
    },
    {
      "id": "type_value_identifier_independent",
      "name": "Type and value identifiers independent",
      "category": "type_scope",
      "description": "A value can reuse a type alias name without colliding with the alias itself.",
      "expect": "runtime_ok",
      "code": "type alias Number = int;\nint main() {\n    int Number = 3;\n    Number aliasValue = 4;\n    writeln(\"alias=\", aliasValue);\n    writeln(\"shadow=\", Number);\n    return 0;\n}",
      "expected_stdout": "alias=4\nshadow=3"
    },
    {
      "id": "type_generic_parameter_scope",
      "name": "Generic parameter scoped to definition",
      "category": "type_scope",
      "description": "Generic type parameters should be visible only inside their declaration.",
      "expect": "runtime_ok",
      "code": "type alias Box<T> = T;\nT unwrap<T>(T value) {\n    return value;\n}\nint main() {\n    writeln(\"boxed=\", unwrap<int>(6));\n    return 0;\n}",
      "expected_stdout": "boxed=6"
    },
    {
      "id": "type_alias_redefinition_error",
      "name": "Alias redefinition rejected",
      "category": "type_scope",
      "description": "Defining the same type alias twice in one scope must fail.",
      "expect": "compile_error",
      "code": "type alias Id = int;\ntype alias Id = float;\nint main() {\n    Id value = 1;\n    return value;\n}",
      "expected_stderr_substring": "type alias",
      "failure_reason": "Type aliases must be unique within their scope."
    },
    {
      "id": "type_parameter_leak_error",
      "name": "Generic parameter does not leak",
      "category": "type_scope",
      "description": "Generic parameters should not be visible outside their declaration.",
      "expect": "compile_error",
      "code": "type alias Wrapper<T> = T;\nWrapper<int> makeInt() {\n    return 1;\n}\nint main() {\n    T leaked = makeInt();\n    return leaked;\n}",
      "expected_stderr_substring": "not in scope",
      "failure_reason": "Generic type parameters are scoped to their declaration site."
    },
    {
      "id": "type_value_space_conflict_error",
      "name": "Type name cannot shadow in same space",
      "category": "type_scope",
      "description": "Declaring a type alias that conflicts with an existing type should fail.",
      "expect": "compile_error",
      "code": "type alias int = float;\nint main() {\n    int value = 1;\n    return value;\n}",
      "expected_stderr_substring": "type name",
      "failure_reason": "Built-in type names must not be re-aliased in the same namespace."
    },
    {
      "id": "type_random_alias_pass",
      "name": "Randomised alias usage works",
      "category": "type_scope",
      "description": "Random alias names should behave the same as fixed ones.",
      "expect": "runtime_ok",
      "code": "type alias {{alias_name}} = int;\nint main() {\n    {{alias_name}} value = 11;\n    writeln(\"alias-ok=\", value);\n    return 0;\n}",
      "expected_stdout": "alias-ok=11",
      "placeholders": {
        "alias_name": {
          "type": "identifier",
          "min_length": 5
        }
      }
    },
    {
      "id": "type_random_param_leak_error",
      "name": "Randomised generic leak rejected",
      "category": "type_scope",
      "description": "Generic parameter leaks must be rejected regardless of identifier spelling.",
      "expect": "compile_error",
      "code": "type alias Holder<{{param}}> = {{param}};\n{{param}} make();\nint main() {\n    {{param}} value = 0;\n    return value;\n}",
      "expected_stderr_substring": "not in scope",
      "failure_reason": "Generic scope rules cannot depend on parameter naming.",
      "placeholders": {
        "param": {
          "type": "identifier",
          "min_length": 4
        }
      }
    },
    {
      "id": "pattern_match_scopes_binding",
      "name": "Pattern binding scoped to branch",
      "category": "pattern_scope",
      "description": "Variables bound in a match arm remain limited to that arm.",
      "expect": "runtime_ok",
      "code": "int main() {\n    int value = 5;\n    match value {\n        case 5 -> {\n            int branch = value + 1;\n            writeln(\"branch=\", branch);\n        }\n        default -> writeln(\"fallback\");\n    }\n    writeln(\"original=\", value);\n    return 0;\n}",
      "expected_stdout": "branch=6\noriginal=5"
    },
    {
      "id": "pattern_guard_respects_scope",
      "name": "Pattern guards see bound names",
      "category": "pattern_scope",
      "description": "Pattern guards should use the freshly bound variables without leaking them.",
      "expect": "runtime_ok",
      "code": "int main() {\n    match 3 {\n        case x if x > 2 -> writeln(\"guard=\", x);\n        default -> writeln(\"miss\");\n    }\n    return 0;\n}",
      "expected_stdout": "guard=3"
    },
    {
      "id": "exception_handler_scoped",
      "name": "Exception variable scoped to handler",
      "category": "pattern_scope",
      "description": "Exception handler variables must not leak outside the catch block.",
      "expect": "runtime_ok",
      "code": "void fail() {\n    throw 7;\n}\nint main() {\n    try {\n        fail();\n    } catch (int err) {\n        writeln(\"caught=\", err);\n    }\n    writeln(\"after try\");\n    return 0;\n}",
      "expected_stdout": "caught=7\nafter try"
    },
    {
      "id": "pattern_variable_leak_error",
      "name": "Pattern binding does not leak",
      "category": "pattern_scope",
      "description": "Referencing a pattern-bound variable outside the match arm should fail.",
      "expect": "compile_error",
      "code": "int main() {\n    match 1 {\n        case value -> writeln(value);\n        default -> writeln(0);\n    }\n    return value;\n}",
      "expected_stderr_substring": "not in scope",
      "failure_reason": "Pattern variables are scoped to the arm in which they are bound."
    },
    {
      "id": "exception_variable_leak_error",
      "name": "Exception variable cannot escape",
      "category": "pattern_scope",
      "description": "Exception handler identifiers should not be visible after the catch block.",
      "expect": "compile_error",
      "code": "int main() {\n    try {\n        throw 1;\n    } catch (int err) {\n        writeln(\"caught\");\n    }\n    return err;\n}",
      "expected_stderr_substring": "not in scope",
      "failure_reason": "Catch variables must be scoped to the handler."
    },
    {
      "id": "pattern_duplicate_binding_error",
      "name": "Duplicate pattern binding rejected",
      "category": "pattern_scope",
      "description": "Binding the same identifier twice in one pattern should raise an error.",
      "expect": "compile_error",
      "code": "int main() {\n    match 1 {\n        case (x, x) -> return x;\n        default -> return 0;\n    }\n}",
      "expected_stderr_substring": "duplicate",
      "failure_reason": "Pattern bindings must use unique identifiers per arm."
    },
    {
      "id": "pattern_random_binding_pass",
      "name": "Random pattern binding respects scope",
      "category": "pattern_scope",
      "description": "Random identifier names in patterns still obey scoping rules.",
      "expect": "runtime_ok",
      "code": "int main() {\n    match 2 {\n        case {{binding}} -> writeln(\"rand=\", {{binding}} + 1);\n        default -> writeln(\"miss\");\n    }\n    writeln(\"done\");\n    return 0;\n}",
      "expected_stdout": "rand=3\ndone",
      "placeholders": {
        "binding": {
          "type": "identifier",
          "min_length": 4
        }
      }
    },
    {
      "id": "exception_random_leak_error",
      "name": "Random catch variable leak rejected",
      "category": "pattern_scope",
      "description": "Random identifier names in catch blocks must not leak.",
      "expect": "compile_error",
      "code": "int main() {\n    try {\n        throw 2;\n    } catch (int {{catch_name}}) {\n        writeln(\"handled\");\n    }\n    return {{catch_name}};\n}",
      "expected_stderr_substring": "not in scope",
      "failure_reason": "Catch scope cannot depend on identifier spelling.",
      "placeholders": {
        "catch_name": {
          "type": "identifier",
          "min_length": 5
        }
      }
    },
    {
      "id": "name_resolution_prefers_inner",
      "name": "Inner binding wins over outer",
      "category": "resolution_scope",
      "description": "Lexical lookup should select the innermost binding first.",
      "expect": "runtime_ok",
      "code": "int value = 1;\nint main() {\n    int globalCopy = value;\n    int value = 2;\n    writeln(\"inner=\", value);\n    writeln(\"outer=\", globalCopy);\n    return 0;\n}",
      "expected_stdout": "inner=2\nouter=1"
    },
    {
      "id": "name_resolution_local_over_import",
      "name": "Local symbol overrides imported",
      "category": "resolution_scope",
      "description": "Local bindings must override imported names unless qualified.",
      "expect": "runtime_ok",
      "code": "#import \"{{support_dir}}/resolution/mod_numbers.rea\" as Numbers;\nint total = 42;\nint main() {\n    int total = 99;\n    writeln(\"local=\", total);\n    writeln(\"qualified=\", Numbers.total());\n    return 0;\n}",
      "expected_stdout": "local=99\nqualified=42",
      "files": [
        {
          "path": "resolution/mod_numbers.rea",
          "code": "module Numbers {\n    export int total() {\n        return 42;\n    }\n}"
        }
      ]
    },
    {
      "id": "name_resolution_alias_required",
      "name": "Alias provides unique path",
      "category": "resolution_scope",
      "description": "Qualified references via alias should resolve even when names clash.",
      "expect": "runtime_ok",
      "code": "#import \"{{support_dir}}/resolution/mod_alpha.rea\" as Alpha;\n#import \"{{support_dir}}/resolution/mod_beta.rea\" as Beta;\nint main() {\n    writeln(\"alpha=\", Alpha.ident());\n    writeln(\"beta=\", Beta.ident());\n    return 0;\n}",
      "expected_stdout": "alpha=1\nbeta=2",
      "files": [
        {
          "path": "resolution/mod_alpha.rea",
          "code": "module Alpha {\n    export int ident() {\n        return 1;\n    }\n}"
        },
        {
          "path": "resolution/mod_beta.rea",
          "code": "module Beta {\n    export int ident() {\n        return 2;\n    }\n}"
        }
      ]
    },
    {
      "id": "name_resolution_ambiguous_import_error",
      "name": "Ambiguous reference rejected",
      "category": "resolution_scope",
      "description": "Using an unqualified name that exists in multiple imports must be an error.",
      "expect": "compile_error",
      "code": "#import \"{{support_dir}}/resolution/mod_left.rea\";\n#import \"{{support_dir}}/resolution/mod_right.rea\";\nint main() {\n    return ident();\n}",
      "expected_stderr_substring": "ambiguous",
      "failure_reason": "Name resolution must report ambiguity across imports.",
      "files": [
        {
          "path": "resolution/mod_left.rea",
          "code": "module Left {\n    export int ident() {\n        return 3;\n    }\n}"
        },
        {
          "path": "resolution/mod_right.rea",
          "code": "module Right {\n    export int ident() {\n        return 4;\n    }\n}"
        }
      ]
    },
    {
      "id": "name_resolution_unknown_identifier_error",
      "name": "Unknown identifier reported",
      "category": "resolution_scope",
      "description": "Referencing an undefined name must produce a clear error.",
      "expect": "compile_error",
      "code": "int main() {\n    return missingName;\n}",
      "expected_stderr_substring": "missingName",
      "failure_reason": "Resolver must flag missing identifiers."
    },
    {
      "id": "name_resolution_alias_required_error",
      "name": "Alias required for conflicting imports",
      "category": "resolution_scope",
      "description": "Referencing conflicting imports without aliasing should fail.",
      "expect": "compile_error",
      "code": "#import \"{{support_dir}}/resolution/mod_alpha.rea\";\n#import \"{{support_dir}}/resolution/mod_beta.rea\";\nint main() {\n    return ident();\n}",
      "expected_stderr_substring": "ambiguous",
      "failure_reason": "Conflicts require explicit qualification."
    },
    {
      "id": "name_resolution_random_shadow_pass",
      "name": "Random inner shadow chosen",
      "category": "resolution_scope",
      "description": "Random identifier names still prefer the innermost binding.",
      "expect": "runtime_ok",
      "code": "int {{outer_name}} = 10;\nint main() {\n    int {{outer_name}} = 20;\n    writeln(\"inner=\", {{outer_name}});\n    return 0;\n}",
      "expected_stdout": "inner=20",
      "placeholders": {
        "outer_name": {
          "type": "identifier",
          "min_length": 5
        }
      }
    },
    {
      "id": "name_resolution_random_ambiguous_error",
      "name": "Random ambiguous reference rejected",
      "category": "resolution_scope",
      "description": "Ambiguity diagnostics remain even with random names.",
      "expect": "compile_error",
      "code": "#import \"{{support_dir}}/resolution/mod_u.rea\";\n#import \"{{support_dir}}/resolution/mod_v.rea\";\nint main() {\n    return {{shared_name}}();\n}",
      "expected_stderr_substring": "ambiguous",
      "failure_reason": "Ambiguity must be reported regardless of identifier spelling.",
      "placeholders": {
        "shared_name": {
          "type": "literal",
          "value": "shared"
        }
      },
      "files": [
        {
          "path": "resolution/mod_u.rea",
          "code": "module UMod {\n    export int shared() {\n        return 8;\n    }\n}"
        },
        {
          "path": "resolution/mod_v.rea",
          "code": "module VMod {\n    export int shared() {\n        return 9;\n    }\n}"
        }
      ]
    },
    {
      "id": "hoist_function_call_before_decl",
      "name": "Functions hoisted for forward call",
      "category": "hoisting_scope",
      "description": "Functions should be callable before their definition appears.",
      "expect": "runtime_ok",
      "code": "int addOne(int value);\nint main() {\n    writeln(\"result=\", addOne(2));\n    return 0;\n}\nint addOne(int value) {\n    return value + 1;\n}",
      "expected_stdout": "result=3"
    },
    {
      "id": "hoist_mutual_recursion_forward",
      "name": "Mutual recursion resolves via hoisting",
      "category": "hoisting_scope",
      "description": "Mutually recursive functions declared later should still resolve.",
      "expect": "runtime_ok",
      "code": "bool odd(int n);\nbool even(int n) {\n    if (n == 0) {\n        return true;\n    }\n    return odd(n - 1);\n}\nbool odd(int n) {\n    if (n == 0) {\n        return false;\n    }\n    return even(n - 1);\n}\nint main() {\n    writeln(\"even?\", even(4));\n    writeln(\"odd?\", odd(5));\n    return 0;\n}",
      "expected_stdout": "even?true\nodd?true"
    },
    {
      "id": "hoist_procedure_forward_decl",
      "name": "Procedures hoisted before body",
      "category": "hoisting_scope",
      "description": "Procedures declared later should be callable without prototypes.",
      "expect": "runtime_ok",
      "code": "void logMessage();\nint main() {\n    logMessage();\n    return 0;\n}\nvoid logMessage() {\n    writeln(\"log-ok\");\n}",
      "expected_stdout": "log-ok"
    },
    {
      "id": "hoist_variable_use_before_decl_error",
      "name": "Variable not hoisted",
      "category": "hoisting_scope",
      "description": "Variables should not be accessible before their declaration.",
      "expect": "compile_error",
      "code": "int main() {\n    total = 5;\n    int total = 1;\n    return total;\n}",
      "expected_stderr_substring": "not in scope",
      "failure_reason": "Variables are not hoisted like functions."
    },
    {
      "id": "hoist_const_use_before_decl_error",
      "name": "Const not hoisted",
      "category": "hoisting_scope",
      "description": "Constants should not be used before they are declared.",
      "expect": "compile_error",
      "code": "const int LIMIT = value;\nconst int value = 5;\nint main() {\n    return LIMIT;\n}",
      "expected_stderr_substring": "not in scope",
      "failure_reason": "Const initializers must only reference earlier declarations."
    },
    {
      "id": "hoist_nested_function_not_visible_error",
      "name": "Nested hoisting limited to scope",
      "category": "hoisting_scope",
      "description": "Nested functions should not be callable before they are defined in the same scope.",
      "expect": "compile_error",
      "code": "int main() {\n    return inner();\n    int inner() {\n        return 2;\n    }\n}",
      "expected_stderr_substring": "not in scope",
      "failure_reason": "Nested definitions are not hoisted above their declaration site."
    },
    {
      "id": "hoist_random_function_pass",
      "name": "Random function hoist works",
      "category": "hoisting_scope",
      "description": "Random function names should still support forward calls.",
      "expect": "runtime_ok",
      "code": "int {{func_name}}(int v);\nint main() {\n    writeln(\"rand=\", {{func_name}}(4));\n    return 0;\n}\nint {{func_name}}(int v) {\n    return v + 6;\n}",
      "expected_stdout": "rand=10",
      "placeholders": {
        "func_name": {
          "type": "identifier",
          "min_length": 5
        }
      }
    },
    {
      "id": "hoist_random_variable_error",
      "name": "Random variable not hoisted",
      "category": "hoisting_scope",
      "description": "Random names should still obey non-hoisting rules for variables.",
      "expect": "compile_error",
      "code": "int main() {\n    {{var_name}} = 1;\n    int {{var_name}} = 2;\n    return {{var_name}};\n}",
      "expected_stderr_substring": "not in scope",
      "failure_reason": "Variable hoisting must be disallowed regardless of identifier.",
      "placeholders": {
        "var_name": {
          "type": "identifier",
          "min_length": 4
        }
      }
    },
    {
      "id": "integration_scope_closure_module_mix",
      "name": "Integration of modules, closures, and shadowing",
      "category": "integration",
      "description": "Combines module imports, closures, shadowing, and lexical lookups in one scenario.",
      "expect": "runtime_ok",
      "code": "#import \"{{support_dir}}/integration/helpers.rea\" as Helpers;\nint global = 10;\nint main() {\n    int global = Helpers.baseValue();\n    int outer = 1;\n    int compute(int delta) {\n        int inner(int step) {\n            int outer = step + delta;\n            return outer + Helpers.SHIFT;\n        }\n        return inner(global);\n    }\n    int total = compute(2);\n    writeln(\"total=\", total);\n    writeln(\"shadowed_global=\", global);\n    writeln(\"module_shift=\", Helpers.SHIFT);\n    return 0;\n}",
      "expected_stdout": "total=10\nshadowed_global=5\nmodule_shift=3",
      "files": [
        {
          "path": "integration/helpers.rea",
          "code": "module Helpers {\n    export int baseValue() {\n        return 5;\n    }\n    export const int SHIFT = 3;\n}"
        }
      ]
    },
    {
      "id": "class_constructor_sets_and_reads",
      "name": "Constructors assign fields and methods observe them",
      "category": "class_scope",
      "description": "Instantiating a class should run its constructor, and instance methods should read updated fields via implicit self.",
      "expect": "runtime_ok",
      "code": "class Counter {\n    int value;\n\n    void Counter(int start) {\n        my.value = start;\n    }\n\n    void increment() {\n        my.value = my.value + 1;\n    }\n\n    int current() {\n        return my.value;\n    }\n}\n\nint main() {\n    Counter counter = new Counter(5);\n    counter.increment();\n    writeln(\"current=\", counter.current());\n    return 0;\n}",
      "expected_stdout": "current=6"
    },
    {
      "id": "class_method_my_alias_updates_fields",
      "name": "`my` and `myself` aliases mutate object state",
      "category": "class_scope",
      "description": "Both `my` and `myself` should reference the implicit receiver inside methods, enabling field swaps across aliases.",
      "expect": "runtime_ok",
      "code": "class Pair {\n    int left;\n    int right;\n\n    void Pair(int l, int r) {\n        my.left = l;\n        myself.right = r;\n    }\n\n    void swap() {\n        int temp = my.left;\n        my.left = myself.right;\n        myself.right = temp;\n    }\n}\n\nint main() {\n    Pair pair = new Pair(1, 2);\n    pair.swap();\n    writeln(\"left=\", pair.left);\n    writeln(\"right=\", pair.right);\n    return 0;\n}",
      "expected_stdout": "left=2\nright=1"
    },
    {
      "id": "class_inheritance_super_constructor_and_method",
      "name": "Subclass can call super constructor and methods",
      "category": "class_scope",
      "description": "A subclass constructor should invoke its parent constructor via `super`, and overridden methods may delegate back to the parent.",
      "expect": "runtime_ok",
      "code": "class BaseCounter {\n    int total;\n\n    void BaseCounter(int start) {\n        my.total = start;\n    }\n\n    void add(int amount) {\n        my.total = my.total + amount;\n    }\n\n    int current() {\n        return my.total;\n    }\n}\n\nclass BonusCounter extends BaseCounter {\n    void BonusCounter(int start) {\n        super(start);\n    }\n\n    void add(int amount) {\n        super.add(amount + 1);\n    }\n\n    int current() {\n        return super.current();\n    }\n}\n\nint main() {\n    BonusCounter counter = new BonusCounter(2);\n    counter.add(3);\n    writeln(\"total=\", counter.current());\n    return 0;\n}",
      "expected_stdout": "total=6"
    },
    {
      "id": "class_unknown_parent_error",
      "name": "Extending an unknown parent is rejected",
      "category": "class_scope",
      "description": "Referencing a non-existent superclass should emit a semantic error identifying the missing parent.",
      "expect": "compile_error",
      "code": "class Orphan extends MissingParent {\n    int value;\n}\n\nint main() {\n    return 0;\n}",
      "expected_stderr_substring": "Unknown parent class",
      "failure_reason": "Inheritance chains must reference classes that have been declared."
    },
    {
      "id": "class_duplicate_field_error",
      "name": "Duplicate class fields are rejected",
      "category": "class_scope",
      "description": "A class may not declare two fields with the same identifier.",
      "expect": "compile_error",
      "code": "class Point {\n    int x;\n    int x;\n}\n\nint main() {\n    Point point = new Point();\n    return 0;\n}",
      "expected_stderr_substring": "Duplicate field",
      "failure_reason": "Field identifiers must be unique within a class body."
    },
    {
      "id": "class_unknown_field_access_error",
      "name": "Accessing missing fields surfaces an error",
      "category": "class_scope",
      "description": "Referencing a field that is not declared on the receiver class should produce a helpful diagnostic.",
      "expect": "compile_error",
      "code": "class Bucket {\n    int capacity;\n\n    int remaining() {\n        return my.level;\n    }\n}\n\nint main() {\n    Bucket bucket = new Bucket();\n    return bucket.remaining();\n}",
      "expected_stderr_substring": "Unknown field",
      "failure_reason": "Only declared fields may be accessed through `my`/`myself`."
    },
    {
      "id": "thread_wrappers_spawn_queue",
      "name": "Thread helpers expose VM worker controls",
      "category": "integration",
      "description": "thread_spawn_named and thread_pool_submit wrap the VM worker pool with JSON-friendly helpers.",
      "expect": "runtime_ok",
      "code": "int main() {\n    int named = thread_spawn_named(\"delay\", \"rea_worker\", 5);\n    int named_wait = WaitForThread(named);\n    int named_ok = (named_wait == 0) ? 1 : 0;\n\n    int pooled = thread_pool_submit(\"delay\", \"rea_pool\", 5);\n    int pooled_wait = WaitForThread(pooled);\n    int lookup = thread_lookup(\"rea_pool\");\n    int pooled_ok = (pooled_wait == 0) ? 1 : 0;\n    int lookup_match = (lookup == pooled) ? 1 : 0;\n    int stats_len = length(thread_stats());\n\n    printf(\"named_status=%d\\n\", named_ok);\n    printf(\"pooled_status=%d lookup_match=%d stats=%d\\n\", pooled_ok, lookup_match, stats_len);\n    return 0;\n}",
      "expected_stdout": "named_status=1\npooled_status=1 lookup_match=1 stats=1"
    }
  ]
}
