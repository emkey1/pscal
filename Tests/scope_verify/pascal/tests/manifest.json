{
  "version": 1,
  "default_extension": "pas",
  "notes": "Generated by build_manifest.py",
  "tests": [
    {
      "id": "routine_local_shadow_preserves_global",
      "name": "Local variable shadows global without mutation",
      "category": "routine_scope",
      "description": "Procedure-local variable with same name as global should shadow without mutating the outer binding.",
      "expect": "runtime_ok",
      "code": "program RoutineLocalShadow;\nvar\n  counter: Integer;\n\nprocedure Run;\nvar\n  counter: Integer;\nbegin\n  counter := 10;\n  writeln('inner=', counter);\nend;\n\nbegin\n  counter := 3;\n  writeln('outer_before=', counter);\n  Run;\n  writeln('outer_after=', counter);\nend.",
      "expected_stdout": "outer_before=3\ninner=10\nouter_after=3"
    },
    {
      "id": "routine_parameter_shadows_global",
      "name": "Parameter shadows global",
      "category": "routine_scope",
      "description": "Passing an argument should shadow a global of the same name without altering the global value.",
      "expect": "runtime_ok",
      "code": "program RoutineParameterShadow;\nvar\n  total: Integer;\n\nprocedure Add(total: Integer);\nbegin\n  writeln('param=', total);\nend;\n\nbegin\n  total := 5;\n  Add(7);\n  writeln('global=', total);\nend.",
      "expected_stdout": "param=7\nglobal=5"
    },
    {
      "id": "routine_nested_procedure_captures_outer",
      "name": "Nested procedure captures outer variable",
      "category": "routine_scope",
      "description": "Nested procedures should capture and mutate variables from the enclosing scope.",
      "expect": "runtime_ok",
      "code": "program RoutineNestedCapture;\nvar\n  total: Integer;\n\nprocedure Accumulate(start: Integer);\nvar\n  index: Integer;\n\n  procedure Step(amount: Integer);\n  begin\n    total := total + amount;\n  end;\n\nbegin\n  for index := 1 to 3 do\n  begin\n    Step(index * start);\n  end;\nend;\n\nbegin\n  total := 0;\n  Accumulate(1);\n  writeln('total=', total);\nend.",
      "expected_stdout": "total=6"
    },
    {
      "id": "routine_nested_function_captures_outer",
      "name": "Nested function captures outer values",
      "category": "routine_scope",
      "description": "Nested functions should capture both local and outer-scope variables while leaving globals untouched.",
      "expect": "runtime_ok",
      "code": "program RoutineNestedFunction;\nvar\n  globalBase: Integer;\n\nfunction Factory(offset: Integer): Integer;\nvar\n  localBase: Integer;\n\n  function Accumulate(step: Integer): Integer;\n  begin\n    Accumulate := localBase + offset + step + globalBase;\n  end;\n\nbegin\n  localBase := offset * 2;\n  Factory := Accumulate(1);\nend;\n\nbegin\n  globalBase := 7;\n  writeln('result=', Factory(3));\n  writeln('global=', globalBase);\nend.",
      "expected_stdout": "result=17\nglobal=7"
    },
    {
      "id": "routine_nested_function_leak_error",
      "name": "Nested function cannot escape its scope",
      "category": "routine_scope",
      "description": "Calling a nested helper from the outer scope now raises a semantic error instead of failing at runtime.",
      "expect": "runtime_error",
      "code": "program RoutineNestedFunctionLeak;\n\nfunction Outer(value: Integer): Integer;\n  function Hidden(delta: Integer): Integer;\n  begin\n    Hidden := value + delta;\n  end;\nbegin\n  Outer := Hidden(1);\nend;\n\nbegin\n  writeln(Outer(2));\n  writeln(Hidden(3));\nend.",
      "expected_stderr_substring": "Undefined global variable 'hidden'",
      "failure_reason": "Calling a nested function from the global scope resolves against globals and now fails at runtime."
    },
    {
      "id": "routine_parameter_leak_error",
      "name": "Parameter access outside routine fails at runtime",
      "category": "routine_scope",
      "description": "Accessing a routine parameter from the outer scope triggers a runtime failure.",
      "expect": "runtime_error",
      "code": "program RoutineParameterLeak;\n\nprocedure Echo(value: Integer);\nbegin\n  writeln('inside=', value);\nend;\n\nbegin\n  Echo(3);\n  writeln(value);\nend.",
      "expected_stderr_substring": "Undefined global variable",
      "failure_reason": "Routine parameters are not visible outside the routine body; runtime reports an undefined variable."
    },
    {
      "id": "routine_duplicate_local_error",
      "name": "Duplicate local declarations reuse the last binding",
      "category": "routine_scope",
      "description": "The current compiler accepts duplicate local identifiers and keeps the last declared slot.",
      "expect": "runtime_ok",
      "code": "program RoutineDuplicateLocal;\n\nprocedure Demo;\nvar\n  temp: Integer;\n  temp: Integer;\nbegin\n  temp := 1;\n  writeln(temp);\nend;\n\nbegin\n  Demo;\nend.",
      "expected_stdout": "1",
      "failure_reason": "Duplicate locals are tolerated; ensure behaviour remains consistent."
    },
    {
      "id": "routine_loop_variable_persists_after",
      "name": "For-loop control variable persists",
      "category": "routine_scope",
      "description": "Standard Pascal keeps the for-loop variable in scope after the loop with its successor value.",
      "expect": "runtime_ok",
      "code": "program RoutineLoopVariablePersists;\nvar\n  i: Integer;\n  total: Integer;\nbegin\n  total := 0;\n  for i := 1 to 3 do\n  begin\n    total := total + i;\n  end;\n  writeln('sum=', total);\n  writeln('after_loop=', i);\nend.",
      "expected_stdout": "sum=6\nafter_loop=4"
    },
    {
      "id": "routine_nested_parameter_shadow_preserves_outer",
      "name": "Nested parameter shadow leaves outer locals intact",
      "category": "routine_scope",
      "description": "Nested procedures may reuse parameter names without mutating captured outer locals or globals.",
      "expect": "runtime_ok",
      "code": "program RoutineNestedParameterShadow;\nvar\n  value: Integer;\n\nprocedure Outer;\nvar\n  value: Integer;\n\n  procedure Inner(value: Integer);\n  begin\n    writeln('inner=', value);\n  end;\n\nbegin\n  value := 3;\n  Inner(5);\n  writeln('outer=', value);\nend;\n\nbegin\n  value := 7;\n  Outer;\n  writeln('global=', value);\nend.",
      "expected_stdout": "inner=5\nouter=3\nglobal=7"
    },
    {
      "id": "routine_proc_ptr_assignment_var_mismatch",
      "name": "Procedure pointer assignment enforces VAR parameters",
      "category": "routine_scope",
      "description": "Assignments to procedure pointers must preserve VAR/OUT passing conventions.",
      "expect": "compile_error",
      "code": "program ProcPtrAssignVarMismatch;\ntype\n  TVarHandler = procedure(var value: Integer);\n  TValueHandler = procedure(value: Integer);\n\nprocedure UsesVar(var value: Integer);\nbegin\n  value := value + 1;\nend;\n\nprocedure UsesValue(value: Integer);\nbegin\nend;\n\nvar\n  handler: TVarHandler;\n\nbegin\n  handler := @UsesVar;\n  handler := @UsesValue;\nend.",
      "expected_stderr_substring": "passing convention mismatch"
    },
    {
      "id": "routine_proc_ptr_call_var_passthrough",
      "name": "Procedure pointer call preserves VAR semantics",
      "category": "routine_scope",
      "description": "Calling through a procedure pointer should pass VAR parameters by reference and observe mutations.",
      "expect": "runtime_ok",
      "code": "program ProcPtrCallVar;\ntype\n  TVarHandler = procedure(var value: Integer);\n\nprocedure Increment(var value: Integer);\nbegin\n  value := value + 5;\nend;\n\nvar\n  handler: TVarHandler;\n  counter: Integer;\n\nbegin\n  handler := @Increment;\n  counter := 3;\n  handler(counter);\n  writeln('counter=', counter);\nend.",
      "expected_stdout": "counter=8"
    },
    {
      "id": "routine_sibling_local_access_error",
      "name": "Sibling routine cannot access another's local",
      "category": "routine_scope",
      "description": "Attempting to read a local variable from a different routine triggers a runtime failure.",
      "expect": "runtime_error",
      "code": "program RoutineSiblingLocalAccess;\n\nprocedure Producer;\nvar\n  hidden: Integer;\nbegin\n  hidden := 1;\n  writeln('producer=', hidden);\nend;\n\nprocedure Consumer;\nbegin\n  writeln(hidden);\nend;\n\nbegin\n  Producer;\n  Consumer;\nend.",
      "expected_stderr_substring": "Undefined global variable",
      "failure_reason": "Locals belong to their routine activation; sibling procedures must not see each other's locals."
    },
    {
      "id": "control_flow_goto_skips_body",
      "name": "Goto skips inner statements",
      "category": "control_flow",
      "description": "A goto should jump over statements and continue execution at the label.",
      "expect": "runtime_ok",
      "code": "program GotoSkip;\nlabel\n  Done;\nvar\n  value: Integer;\nbegin\n  value := 0;\n  goto Done;\n  value := 42;\nDone:\n  if value = 0 then\n    writeln('skip');\nend.",
      "expected_stdout": "skip"
    },
    {
      "id": "control_flow_goto_undefined_label_error",
      "name": "Goto rejects missing label",
      "category": "control_flow",
      "description": "A goto targeting an undeclared label should raise a compile-time error.",
      "expect": "compile_error",
      "code": "program BadGoto;\nlabel\n  Declared;\nbegin\n  goto Missing;\nDeclared:\n  writeln('should not run');\nend.",
      "expected_stderr_substring": "goto target 'missing'"
    },
    {
      "id": "control_flow_duplicate_label_error",
      "name": "Duplicate label declaration is rejected",
      "category": "control_flow",
      "description": "Label blocks must not repeat the same label name.",
      "expect": "compile_error",
      "code": "program DuplicateLabel;\nlabel\n  Here, Here;\nbegin\n  writeln('never runs');\nend.",
      "expected_stderr_substring": "label 'here' is declared more than once"
    },
    {
      "id": "integration_blackjack_compiles",
      "name": "Goto integrates across routines",
      "category": "control_flow",
      "description": "A larger routine tree with labels and gotos across nested scopes should compile.",
      "expect": "compile_ok",
      "code": "program GotoIntegration;\nlabel\n  Finish;\nvar\n  value: Integer;\n\nprocedure RunGame;\nlabel\n  Restart;\nvar\n  local: Integer;\nbegin\n  local := 0;\nRestart:\n  local := local + 1;\n  if local < 2 then\n    goto Restart;\n  value := local;\nend;\n\nbegin\n  value := 0;\n  RunGame;\nFinish:\n  writeln('value=', value);\nend."
    },
    {
      "id": "closure_reference_capture_runtime",
      "name": "Closure sees updated outer value",
      "category": "closure_scope",
      "description": "Nested functions observe updated locals when invoked multiple times within the same activation.",
      "expect": "runtime_ok",
      "code": "program ClosureReferenceCapture;\n\nprocedure Demo;\nvar\n  base: Integer;\n\n  function Add(delta: Integer): Integer;\n  begin\n    Add := base + delta;\n  end;\n\nbegin\n  base := 3;\n  writeln('first=', Add(2));\n  base := 10;\n  writeln('second=', Add(1));\nend;\n\nbegin\n  Demo;\nend.",
      "expected_stdout": "first=5\nsecond=11"
    },
    {
      "id": "closure_incrementer_stateful",
      "name": "Closure keeps private counter",
      "category": "closure_scope",
      "description": "A nested function mutates a captured local on each invocation.",
      "expect": "runtime_ok",
      "code": "program ClosureIncrementerStateful;\n\nprocedure Demo;\nvar\n  counter: Integer;\n\n  function Next: Integer;\n  begin\n    counter := counter + 1;\n    Next := counter;\n  end;\n\nbegin\n  counter := 0;\n  writeln('inc1=', Next());\n  writeln('inc2=', Next());\nend;\n\nbegin\n  Demo;\nend.",
      "expected_stdout": "inc1=1\ninc2=2"
    },
    {
      "id": "closure_return_function_runtime",
      "name": "Capturing function can be returned",
      "category": "closure_scope",
      "description": "Returning a nested function that captures locals keeps its environment alive for later calls.",
      "expect": "runtime_ok",
      "code": "program ClosureReturnFunctionRuntime;\n\ntype\n  TAdder = function(delta: Integer): Integer;\n\nfunction MakeAdder(start: Integer): TAdder;\nvar\n  total: Integer;\n\n  function Add(delta: Integer): Integer;\n  begin\n    total := total + delta;\n    Add := total;\n  end;\n\nbegin\n  total := start;\n  MakeAdder := Add;\nend;\n\nvar\n  add: TAdder;\n\nbegin\n  add := MakeAdder(10);\n  writeln('first=', add(1));\n  writeln('second=', add(2));\nend.",
      "expected_stdout": "first=11\nsecond=13"
    },
    {
      "id": "closure_store_runtime",
      "name": "Stored closure updates captured locals",
      "category": "closure_scope",
      "description": "Assigning a capturing nested procedure to a global variable keeps its captured locals alive across calls.",
      "expect": "runtime_ok",
      "code": "program ClosureStoreRuntime;\n\ntype\n  TStep = procedure(amount: Integer);\n\nvar\n  saved: TStep;\n  mirror: Integer;\n\nprocedure Build(start: Integer);\nvar\n  total: Integer;\n\n  procedure Step(amount: Integer);\n  begin\n    total := total + amount;\n    mirror := total;\n  end;\n\nbegin\n  total := start;\n  saved := Step;\n  Step(0);\nend;\n\nbegin\n  mirror := 0;\n  Build(5);\n  saved(2);\n  writeln('after_first=', mirror);\n  saved(3);\n  writeln('after_second=', mirror);\nend.",
      "expected_stdout": "after_first=7\nafter_second=10"
    },
    {
      "id": "closure_nested_capture",
      "name": "Nested closures capture multiple levels",
      "category": "closure_scope",
      "description": "Inner nested functions see both their parent's locals and outer lexical bindings.",
      "expect": "runtime_ok",
      "code": "program ClosureNestedCapture;\n\nfunction Outer(n: Integer): Integer;\nvar\n  factor: Integer;\n\n  function Inner(m: Integer): Integer;\n  begin\n    Inner := (n + m) * factor;\n  end;\n\nbegin\n  factor := 2;\n  Outer := Inner(3);\nend;\n\nbegin\n  writeln('combo=', Outer(4));\nend.",
      "expected_stdout": "combo=14"
    },
    {
      "id": "closure_escape_local_error",
      "name": "Escaping closure retains captured locals",
      "category": "closure_scope",
      "description": "Taking the address of a capturing nested procedure keeps its environment alive after returning.",
      "expect": "runtime_ok",
      "code": "program ClosureEscapeLocalRuntime;\n\ntype\n  TMaker = procedure(delta: Integer);\n\nvar\n  saved: TMaker;\n  mirror: Integer;\n\nprocedure Build(seed: Integer);\nvar\n  base: Integer;\n\n  procedure Maker(delta: Integer);\n  begin\n    base := base + delta;\n    mirror := base;\n  end;\n\nbegin\n  base := seed;\n  saved := @Maker;\n  Maker(0);\nend;\n\nbegin\n  mirror := -1;\n  Build(5);\n  writeln('initial=', mirror);\n  saved(2);\n  writeln('after_escape=', mirror);\nend.",
      "expected_stdout": "initial=5\nafter_escape=7"
    },
    {
      "id": "closure_loop_capture_error",
      "name": "Loop-assigned closure preserves loop locals",
      "category": "closure_scope",
      "description": "Storing a closure created inside a loop keeps the loop variable value alive after the loop exits.",
      "expect": "runtime_ok",
      "code": "program ClosureLoopCaptureRuntime;\n\ntype\n  TCapture = procedure;\n\nvar\n  saved: TCapture;\n  captured: Integer;\n\nprocedure Store;\nvar\n  index: Integer;\n\n  procedure Capture;\n  begin\n    captured := index;\n  end;\n\nbegin\n  for index := 1 to 2 do\n  begin\n    saved := @Capture;\n    Capture;\n  end;\nend;\n\nbegin\n  captured := -1;\n  Store;\n  writeln('during_loop=', captured);\n  captured := -1;\n  saved;\n  writeln('after_loop=', captured);\nend.",
      "expected_stdout": "during_loop=2\nafter_loop=2"
    },
    {
      "id": "closure_missing_capture_error",
      "name": "Closure referencing unknown name",
      "category": "closure_scope",
      "description": "Closures must fail when referencing identifiers that are not in scope.",
      "expect": "runtime_error",
      "code": "program ClosureMissingCaptureError;\n\nprocedure Demo;\nvar\n  outer: Integer;\n\n  function Inner: Integer;\n  begin\n    Inner := ghost + outer;\n  end;\n\nbegin\n  outer := 3;\n  writeln('value=', Inner());\nend;\n\nbegin\n  Demo;\nend.",
      "expected_stderr_substring": "Undefined global variable 'ghost'",
      "failure_reason": "Runtime resolution surfaces missing global bindings when closures reference undeclared names."
    },
    {
      "id": "const_shadow_local_overrides_global",
      "name": "Inner constant redefinition persists globally",
      "category": "const_scope",
      "description": "Re-declaring a constant inside a routine updates the global binding in this front-end.",
      "expect": "runtime_ok",
      "code": "program ConstShadow;\nconst\n  Base = 2;\n\nprocedure Show;\nconst\n  Base = 5;\nbegin\n  writeln('inner=', Base);\nend;\n\nbegin\n  Show;\n  writeln('outer=', Base);\nend.",
      "expected_stdout": "inner=5\nouter=5"
    },
    {
      "id": "const_nested_expression_uses_outer",
      "name": "Inner constant can use outer constant",
      "category": "const_scope",
      "description": "Constants declared inside a routine may reference outer constants when initialised.",
      "expect": "runtime_ok",
      "code": "program ConstNestedExpression;\nconst\n  Base = 3;\n\nprocedure Report;\nconst\n  Step = Base + 2;\nbegin\n  writeln('step=', Step);\nend;\n\nbegin\n  Report;\n  writeln('base=', Base);\nend.",
      "expected_stdout": "step=5\nbase=3"
    },
    {
      "id": "const_leak_error",
      "name": "Local constant remains visible outside",
      "category": "const_scope",
      "description": "Constants declared inside a routine continue to be accessible globally in the current implementation.",
      "expect": "runtime_ok",
      "code": "program ConstLeak;\n\nprocedure Maker;\nconst\n  Hidden = 4;\nbegin\n  writeln('hidden=', Hidden);\nend;\n\nbegin\n  Maker;\n  writeln(Hidden);\nend.",
      "expected_stdout": "hidden=4\n4",
      "failure_reason": "Document the existing constant-leak behaviour so regressions are caught."
    },
    {
      "id": "const_parameter_expression_compile_error",
      "name": "Constant expressions cannot depend on parameters",
      "category": "const_scope",
      "description": "Procedure-local constants must be compile-time evaluable; referencing a parameter should be rejected.",
      "expect": "compile_error",
      "code": "program ConstParameterExpressionError;\n\nprocedure Demo(value: Integer);\nconst\n  Double = value * 2;\nbegin\n  writeln('double=', Double);\nend;\n\nbegin\n  Demo(4);\nend.",
      "expected_stderr_substring": "must be compile-time evaluable",
      "failure_reason": "Constants are folded at compile time; parameter references violate that rule."
    },
    {
      "id": "const_forward_reference_evaluated",
      "name": "Constants may reference later declarations in same block",
      "category": "const_scope",
      "description": "Document that constant initialisers can refer to later constants within the same declaration block.",
      "expect": "runtime_ok",
      "code": "program ConstForwardReference;\nconst\n  First = Second + 1;\n  Second = 2;\nbegin\n  writeln('value=', First);\nend.",
      "expected_stdout": "value=3"
    },
    {
      "id": "type_local_shadow_allows_outer",
      "name": "Local type shadow keeps outer definition intact",
      "category": "type_scope",
      "description": "Pointer-based records demonstrate that inner type declarations don't disturb the outer definition.",
      "expect": "runtime_ok",
      "code": "program TypeLocalShadow;\ntype\n  PPair = ^TPair;\n  TPair = record\n    Left: Integer;\n    Right: Integer;\n  end;\n\nprocedure UseGlobal;\nvar\n  pair: PPair;\nbegin\n  new(pair);\n  pair^.Left := 1;\n  pair^.Right := 2;\n  writeln('global_pair=', pair^.Left + pair^.Right);\nend;\n\nprocedure UseLocal;\ntype\n  PPair = ^TPair;\n  TPair = record\n    Left: Integer;\n    Right: Integer;\n    Sum: Integer;\n  end;\nvar\n  pair: PPair;\nbegin\n  new(pair);\n  pair^.Left := 3;\n  pair^.Right := 4;\n  pair^.Sum := pair^.Left + pair^.Right;\n  writeln('local_sum=', pair^.Sum);\nend;\n\nbegin\n  UseLocal;\n  UseGlobal;\nend.",
      "expected_stdout": "local_sum=7\nglobal_pair=3"
    },
    {
      "id": "type_leak_error",
      "name": "Local type declaration leaks outside",
      "category": "type_scope",
      "description": "The compiler currently leaks procedure-local type declarations into the surrounding scope.",
      "expect": "runtime_ok",
      "code": "program TypeLeak;\n\nprocedure Factory;\ntype\n  PInternal = ^TInternal;\n  TInternal = record\n    Value: Integer;\n  end;\nvar\n  item: PInternal;\nbegin\n  new(item);\n  item^.Value := 1;\n  writeln('inside=', item^.Value);\nend;\n\nvar\n  other: PInternal;\nbegin\n  Factory;\n  new(other);\n  other^.Value := 2;\n  writeln('outside=', other^.Value);\nend.",
      "expected_stdout": "inside=1\noutside=2",
      "failure_reason": "Capture the observed leaking behaviour for regression coverage."
    },
    {
      "id": "type_sibling_leak_visible",
      "name": "Sibling routines see leaked local type",
      "category": "type_scope",
      "description": "Type declarations made inside one routine remain available to other routines in the same unit.",
      "expect": "runtime_ok",
      "code": "program TypeSiblingLeak;\n\nprocedure Maker;\ntype\n  PItem = ^TItem;\n  TItem = record\n    Value: Integer;\n  end;\nvar\n  inst: PItem;\nbegin\n  new(inst);\n  inst^.Value := 1;\n  writeln('maker=', inst^.Value);\nend;\n\nprocedure Consumer;\nvar\n  inst: PItem;\nbegin\n  new(inst);\n  inst^.Value := 2;\n  writeln('consumer=', inst^.Value);\nend;\n\nbegin\n  Maker;\n  Consumer;\nend.",
      "expected_stdout": "maker=1\nconsumer=2",
      "failure_reason": "Current implementation leaks routine-local type aliases into the global namespace."
    },
    {
      "id": "type_interface_self_return",
      "name": "Interface method may return its own type",
      "category": "type_scope",
      "description": "Ensure that interface declarations can reference themselves within method signatures.",
      "expect": "runtime_ok",
      "code": "program TypeInterfaceSelfReturn;\n\ntype\n  IFoo = interface\n    function Clone: IFoo;\n  end;\n\nvar\n  instance: IFoo;\n\nbegin\n  instance := nil;\n  if instance = nil then\n    writeln('ok')\n  else\n    writeln('fail');\nend.",
      "expected_stdout": "ok"
    },
    {
      "id": "type_forward_reference_compile_error",
      "name": "Types must be declared before use",
      "category": "resolution_scope",
      "description": "Variables declared before their type definition should fail to compile.",
      "expect": "compile_error",
      "code": "program TypeForwardReferenceError;\nvar\n  item: TRecord;\n\ntype\n  TRecord = record\n    Value: Integer;\n  end;\n\nbegin\n  item.Value := 5;\n  writeln('value=', item.Value);\nend.",
      "expected_stderr_substring": "Undefined type",
      "failure_reason": "Pascal requires types to be declared before they're referenced in variable sections."
    },
    {
      "id": "resolution_builtin_repeated_lookup_stability",
      "name": "Builtin detection remains stable across repeated lookups",
      "category": "resolution_scope",
      "description": "Exercise repeated builtin queries with case variants to ensure the hash-backed registry remains consistent.",
      "expect": "runtime_ok",
      "code": "program BuiltinRepeatedLookup;\nvar\n  first: Integer;\n  second: Integer;\nbegin\n  first := Abs(-5);\n  second := abs(-first);\n  writeln('first=', first);\n  writeln('second=', second);\n  Delay(0);\n  writeln('done');\nend.",
      "expected_stdout": "first=5\nsecond=5\ndone"
    },
    {
      "id": "integration_char_code_concat",
      "name": "Char-code literal concatenation in call arguments",
      "category": "integration",
      "description": "Ensure '#10' style char-code literals concatenate with strings inside argument expressions.",
      "expect": "runtime_ok",
      "code": "program IntegrationCharCodeConcat;\nvar\n  value: Integer;\nbegin\n  value := 1;\n  Write('a' + #10, value);\nend.",
      "expected_stdout": "a\n1"
    },
    {
      "id": "integration_adjacent_string_literals",
      "name": "Adjacent string tokens concatenate",
      "category": "integration",
      "description": "Adjacent string and char-code tokens should fold into a single literal before semantic checks.",
      "expect": "runtime_ok",
      "code": "program AdjacentLiteralRegression;\nvar\n  combined: string;\n  text: string;\n  ch: Char;\nbegin\n  printf('A'+#10'B');\n  writeln;\n  combined := 'A'+#10'B';\n  text := 'Line1'#10'Line2';\n  ch := #0'';\n  writeln('combined_len=', Length(combined));\n  writeln('text_len=', Length(text));\n  writeln('text_ord6=', Ord(text[6]));\n  writeln('char_ord=', Ord(ch));\nend.",
      "expected_stdout": "A\nB\ncombined_len=3\ntext_len=11\ntext_ord6=10\nchar_ord=0"
    },
    {
      "id": "integration_nested_scope_mix",
      "name": "Nested routines with shadowed consts and types",
      "category": "integration",
      "description": "Integration scenario combining shadowed constants, local types, and nested routines.",
      "expect": "runtime_ok",
      "code": "program IntegrationScopeMix;\nconst\n  Factor = 2;\ntype\n  PInfo = ^TInfo;\n  TInfo = record\n    Value: Integer;\n  end;\n\nprocedure Compute(start: Integer);\nconst\n  Factor = 3;\ntype\n  PLocalInfo = ^TLocalInfo;\n  TLocalInfo = record\n    Value: Integer;\n    Total: Integer;\n  end;\nvar\n  info: PLocalInfo;\n  step: Integer;\n  runningTotal: Integer;\n\n  procedure AddStep(multiplier: Integer);\n  begin\n    runningTotal := runningTotal + multiplier * start;\n  end;\n\nbegin\n  new(info);\n  info^.Value := start;\n  runningTotal := 0;\n  for step := 1 to Factor do\n  begin\n    AddStep(step);\n  end;\n  info^.Total := runningTotal;\n  writeln('inner_total=', info^.Total);\n  writeln('local_factor=', Factor);\nend;\n\nvar\n  summary: PInfo;\nbegin\n  new(summary);\n  summary^.Value := 4;\n  Compute(2);\n  writeln('outer_scaled=', summary^.Value * Factor);\nend.",
      "expected_stdout": "inner_total=12\nlocal_factor=3\nouter_scaled=12"
    },
    {
      "id": "thread_wrappers_named_and_pool",
      "name": "Threading helpers wrap VM builtins",
      "category": "integration",
      "description": "Threading unit helpers forward names, queue-only flags, and expose pool metrics.",
      "expect": "runtime_ok",
      "code": "program ThreadWrapperDemo;\nuses Threading;\n\nvar\n  namedId: Integer;\n  queueId: Integer;\n  lookupId: Integer;\n  namedStatus: Integer;\n  queuedStatus: Integer;\n  statsJson: String;\n\nbegin\n  namedId := ThreadSpawnBuiltin('delay', 5, ThreadOptionsNamed('pascal_worker'));\n  namedStatus := WaitForThread(namedId);\n  writeln('named_status=', Ord(namedStatus = 0));\n\n  queueId := ThreadPoolSubmit('delay', 5, ThreadOptionsQueue('pascal_pool'));\n  lookupId := LookupThreadByName('pascal_pool');\n  queuedStatus := WaitForThread(queueId);\n  writeln('queued_status=', Ord(queuedStatus = 0));\n  writeln('lookup_matches=', Ord(lookupId = queueId));\n  writeln('stats_len=', ThreadStatsCount);\n  statsJson := ThreadStatsJson;\n  writeln('stats_json=', statsJson);\nend.",
      "expected_stdout": "named_status=1\nqueued_status=1\nlookup_matches=1\nstats_len=1\nstats_json=[{\"id\": 2, \"name\": \"pascal_pool\", \"active\": false, \"idle\": true, \"status_success\": false, \"ready_for_reuse\": false, \"pool_generation\": 1}]"
    }
  ]
}
