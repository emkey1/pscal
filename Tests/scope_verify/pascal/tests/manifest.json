{
  "version": 1,
  "default_extension": "pas",
  "notes": "Generated by build_manifest.py",
  "tests": [
    {
      "id": "routine_local_shadow_preserves_global",
      "name": "Local variable shadows global without mutation",
      "category": "routine_scope",
      "description": "Procedure-local variable with same name as global should shadow without mutating the outer binding.",
      "expect": "runtime_ok",
      "code": "program RoutineLocalShadow;\nvar\n  counter: Integer;\n\nprocedure Run;\nvar\n  counter: Integer;\nbegin\n  counter := 10;\n  writeln('inner=', counter);\nend;\n\nbegin\n  counter := 3;\n  writeln('outer_before=', counter);\n  Run;\n  writeln('outer_after=', counter);\nend.",
      "expected_stdout": "outer_before=3\ninner=10\nouter_after=3"
    },
    {
      "id": "routine_parameter_shadows_global",
      "name": "Parameter shadows global",
      "category": "routine_scope",
      "description": "Passing an argument should shadow a global of the same name without altering the global value.",
      "expect": "runtime_ok",
      "code": "program RoutineParameterShadow;\nvar\n  total: Integer;\n\nprocedure Add(total: Integer);\nbegin\n  writeln('param=', total);\nend;\n\nbegin\n  total := 5;\n  Add(7);\n  writeln('global=', total);\nend.",
      "expected_stdout": "param=7\nglobal=5"
    },
    {
      "id": "routine_nested_procedure_captures_outer",
      "name": "Nested procedure captures outer variable",
      "category": "routine_scope",
      "description": "Nested procedures should capture and mutate variables from the enclosing scope.",
      "expect": "runtime_ok",
      "code": "program RoutineNestedCapture;\nvar\n  total: Integer;\n\nprocedure Accumulate(start: Integer);\nvar\n  index: Integer;\n\n  procedure Step(amount: Integer);\n  begin\n    total := total + amount;\n  end;\n\nbegin\n  for index := 1 to 3 do\n  begin\n    Step(index * start);\n  end;\nend;\n\nbegin\n  total := 0;\n  Accumulate(1);\n  writeln('total=', total);\nend.",
      "expected_stdout": "total=6"
    },
    {
      "id": "routine_nested_function_captures_outer",
      "name": "Nested function captures outer values",
      "category": "routine_scope",
      "description": "Nested functions should capture both local and outer-scope variables while leaving globals untouched.",
      "expect": "runtime_ok",
      "code": "program RoutineNestedFunction;\nvar\n  globalBase: Integer;\n\nfunction Factory(offset: Integer): Integer;\nvar\n  localBase: Integer;\n\n  function Accumulate(step: Integer): Integer;\n  begin\n    Accumulate := localBase + offset + step + globalBase;\n  end;\n\nbegin\n  localBase := offset * 2;\n  Factory := Accumulate(1);\nend;\n\nbegin\n  globalBase := 7;\n  writeln('result=', Factory(3));\n  writeln('global=', globalBase);\nend.",
      "expected_stdout": "result=17\nglobal=7"
    },
    {
      "id": "routine_nested_function_leak_error",
      "name": "Nested function remains private at runtime",
      "category": "routine_scope",
      "description": "Attempting to call a nested helper from the outer scope fails at runtime in the current front-end.",
      "expect": "runtime_error",
      "code": "program RoutineNestedFunctionLeak;\n\nfunction Outer(value: Integer): Integer;\n  function Hidden(delta: Integer): Integer;\n  begin\n    Hidden := value + delta;\n  end;\nbegin\n  Outer := Hidden(1);\nend;\n\nbegin\n  writeln(Outer(2));\n  writeln(Hidden(3));\nend.",
      "expected_stderr_substring": "Undefined global variable",
      "failure_reason": "Nested functions remain private; calling them from the outer scope triggers a runtime failure."
    },
    {
      "id": "routine_parameter_leak_error",
      "name": "Parameter access outside routine fails at runtime",
      "category": "routine_scope",
      "description": "Accessing a routine parameter from the outer scope triggers a runtime failure.",
      "expect": "runtime_error",
      "code": "program RoutineParameterLeak;\n\nprocedure Echo(value: Integer);\nbegin\n  writeln('inside=', value);\nend;\n\nbegin\n  Echo(3);\n  writeln(value);\nend.",
      "expected_stderr_substring": "Undefined global variable",
      "failure_reason": "Routine parameters are not visible outside the routine body; runtime reports an undefined variable."
    },
    {
      "id": "routine_duplicate_local_error",
      "name": "Duplicate local declarations reuse the last binding",
      "category": "routine_scope",
      "description": "The current compiler accepts duplicate local identifiers and keeps the last declared slot.",
      "expect": "runtime_ok",
      "code": "program RoutineDuplicateLocal;\n\nprocedure Demo;\nvar\n  temp: Integer;\n  temp: Integer;\nbegin\n  temp := 1;\n  writeln(temp);\nend;\n\nbegin\n  Demo;\nend.",
      "expected_stdout": "1",
      "failure_reason": "Duplicate locals are tolerated; ensure behaviour remains consistent."
    },
    {
      "id": "routine_loop_variable_persists_after",
      "name": "For-loop control variable persists",
      "category": "routine_scope",
      "description": "Standard Pascal keeps the for-loop variable in scope after the loop with its successor value.",
      "expect": "runtime_ok",
      "code": "program RoutineLoopVariablePersists;\nvar\n  i: Integer;\n  total: Integer;\nbegin\n  total := 0;\n  for i := 1 to 3 do\n  begin\n    total := total + i;\n  end;\n  writeln('sum=', total);\n  writeln('after_loop=', i);\nend.",
      "expected_stdout": "sum=6\nafter_loop=4"
    },
    {
      "id": "routine_nested_parameter_shadow_preserves_outer",
      "name": "Nested parameter shadow leaves outer locals intact",
      "category": "routine_scope",
      "description": "Nested procedures may reuse parameter names without mutating captured outer locals or globals.",
      "expect": "runtime_ok",
      "code": "program RoutineNestedParameterShadow;\nvar\n  value: Integer;\n\nprocedure Outer;\nvar\n  value: Integer;\n\n  procedure Inner(value: Integer);\n  begin\n    writeln('inner=', value);\n  end;\n\nbegin\n  value := 3;\n  Inner(5);\n  writeln('outer=', value);\nend;\n\nbegin\n  value := 7;\n  Outer;\n  writeln('global=', value);\nend.",
      "expected_stdout": "inner=5\nouter=3\nglobal=7"
    },
    {
      "id": "routine_sibling_local_access_error",
      "name": "Sibling routine cannot access another's local",
      "category": "routine_scope",
      "description": "Attempting to read a local variable from a different routine triggers a runtime failure.",
      "expect": "runtime_error",
      "code": "program RoutineSiblingLocalAccess;\n\nprocedure Producer;\nvar\n  hidden: Integer;\nbegin\n  hidden := 1;\n  writeln('producer=', hidden);\nend;\n\nprocedure Consumer;\nbegin\n  writeln(hidden);\nend;\n\nbegin\n  Producer;\n  Consumer;\nend.",
      "expected_stderr_substring": "Undefined global variable",
      "failure_reason": "Locals belong to their routine activation; sibling procedures must not see each other's locals."
    },
    {
      "id": "control_flow_goto_skips_body",
      "name": "Goto skips inner statements",
      "category": "control_flow",
      "description": "A goto should jump over statements and continue execution at the label.",
      "expect": "runtime_ok",
      "code": "program GotoSkip;\nlabel\n  Done;\nvar\n  value: Integer;\nbegin\n  value := 0;\n  goto Done;\n  value := 42;\nDone:\n  if value = 0 then\n    writeln('skip');\nend.",
      "expected_stdout": "skip"
    },
    {
      "id": "control_flow_goto_undefined_label_error",
      "name": "Goto rejects missing label",
      "category": "control_flow",
      "description": "A goto targeting an undeclared label should raise a compile-time error.",
      "expect": "compile_error",
      "code": "program BadGoto;\nlabel\n  Declared;\nbegin\n  goto Missing;\nDeclared:\n  writeln('should not run');\nend.",
      "expected_stderr_substring": "goto target 'missing'"
    },
    {
      "id": "control_flow_duplicate_label_error",
      "name": "Duplicate label declaration is rejected",
      "category": "control_flow",
      "description": "Label blocks must not repeat the same label name.",
      "expect": "compile_error",
      "code": "program DuplicateLabel;\nlabel\n  Here, Here;\nbegin\n  writeln('never runs');\nend.",
      "expected_stderr_substring": "label 'here' is declared more than once"
    },
    {
      "id": "integration_blackjack_compiles",
      "name": "Goto integrates across routines",
      "category": "control_flow",
      "description": "A larger routine tree with labels and gotos across nested scopes should compile.",
      "expect": "compile_ok",
      "code": "program GotoIntegration;\nlabel\n  Finish;\nvar\n  value: Integer;\n\nprocedure RunGame;\nlabel\n  Restart;\nvar\n  local: Integer;\nbegin\n  local := 0;\nRestart:\n  local := local + 1;\n  if local < 2 then\n    goto Restart;\n  value := local;\nend;\n\nbegin\n  value := 0;\n  RunGame;\nFinish:\n  writeln('value=', value);\nend."
    },
    {
      "id": "const_shadow_local_overrides_global",
      "name": "Inner constant redefinition persists globally",
      "category": "const_scope",
      "description": "Re-declaring a constant inside a routine updates the global binding in this front-end.",
      "expect": "runtime_ok",
      "code": "program ConstShadow;\nconst\n  Base = 2;\n\nprocedure Show;\nconst\n  Base = 5;\nbegin\n  writeln('inner=', Base);\nend;\n\nbegin\n  Show;\n  writeln('outer=', Base);\nend.",
      "expected_stdout": "inner=5\nouter=5"
    },
    {
      "id": "const_nested_expression_uses_outer",
      "name": "Inner constant can use outer constant",
      "category": "const_scope",
      "description": "Constants declared inside a routine may reference outer constants when initialised.",
      "expect": "runtime_ok",
      "code": "program ConstNestedExpression;\nconst\n  Base = 3;\n\nprocedure Report;\nconst\n  Step = Base + 2;\nbegin\n  writeln('step=', Step);\nend;\n\nbegin\n  Report;\n  writeln('base=', Base);\nend.",
      "expected_stdout": "step=5\nbase=3"
    },
    {
      "id": "const_leak_error",
      "name": "Local constant remains visible outside",
      "category": "const_scope",
      "description": "Constants declared inside a routine continue to be accessible globally in the current implementation.",
      "expect": "runtime_ok",
      "code": "program ConstLeak;\n\nprocedure Maker;\nconst\n  Hidden = 4;\nbegin\n  writeln('hidden=', Hidden);\nend;\n\nbegin\n  Maker;\n  writeln(Hidden);\nend.",
      "expected_stdout": "hidden=4\n4",
      "failure_reason": "Document the existing constant-leak behaviour so regressions are caught."
    },
    {
      "id": "const_parameter_expression_compile_error",
      "name": "Constant expressions cannot depend on parameters",
      "category": "const_scope",
      "description": "Procedure-local constants must be compile-time evaluable; referencing a parameter should be rejected.",
      "expect": "compile_error",
      "code": "program ConstParameterExpressionError;\n\nprocedure Demo(value: Integer);\nconst\n  Double = value * 2;\nbegin\n  writeln('double=', Double);\nend;\n\nbegin\n  Demo(4);\nend.",
      "expected_stderr_substring": "must be compile-time evaluable",
      "failure_reason": "Constants are folded at compile time; parameter references violate that rule."
    },
    {
      "id": "const_forward_reference_evaluated",
      "name": "Constants may reference later declarations in same block",
      "category": "const_scope",
      "description": "Document that constant initialisers can refer to later constants within the same declaration block.",
      "expect": "runtime_ok",
      "code": "program ConstForwardReference;\nconst\n  First = Second + 1;\n  Second = 2;\nbegin\n  writeln('value=', First);\nend.",
      "expected_stdout": "value=3"
    },
    {
      "id": "type_local_shadow_allows_outer",
      "name": "Local type shadow keeps outer definition intact",
      "category": "type_scope",
      "description": "Pointer-based records demonstrate that inner type declarations don't disturb the outer definition.",
      "expect": "runtime_ok",
      "code": "program TypeLocalShadow;\ntype\n  PPair = ^TPair;\n  TPair = record\n    Left: Integer;\n    Right: Integer;\n  end;\n\nprocedure UseGlobal;\nvar\n  pair: PPair;\nbegin\n  new(pair);\n  pair^.Left := 1;\n  pair^.Right := 2;\n  writeln('global_pair=', pair^.Left + pair^.Right);\nend;\n\nprocedure UseLocal;\ntype\n  PPair = ^TPair;\n  TPair = record\n    Left: Integer;\n    Right: Integer;\n    Sum: Integer;\n  end;\nvar\n  pair: PPair;\nbegin\n  new(pair);\n  pair^.Left := 3;\n  pair^.Right := 4;\n  pair^.Sum := pair^.Left + pair^.Right;\n  writeln('local_sum=', pair^.Sum);\nend;\n\nbegin\n  UseLocal;\n  UseGlobal;\nend.",
      "expected_stdout": "local_sum=7\nglobal_pair=3"
    },
    {
      "id": "type_leak_error",
      "name": "Local type declaration leaks outside",
      "category": "type_scope",
      "description": "The compiler currently leaks procedure-local type declarations into the surrounding scope.",
      "expect": "runtime_ok",
      "code": "program TypeLeak;\n\nprocedure Factory;\ntype\n  PInternal = ^TInternal;\n  TInternal = record\n    Value: Integer;\n  end;\nvar\n  item: PInternal;\nbegin\n  new(item);\n  item^.Value := 1;\n  writeln('inside=', item^.Value);\nend;\n\nvar\n  other: PInternal;\nbegin\n  Factory;\n  new(other);\n  other^.Value := 2;\n  writeln('outside=', other^.Value);\nend.",
      "expected_stdout": "inside=1\noutside=2",
      "failure_reason": "Capture the observed leaking behaviour for regression coverage."
    },
    {
      "id": "type_sibling_leak_visible",
      "name": "Sibling routines see leaked local type",
      "category": "type_scope",
      "description": "Type declarations made inside one routine remain available to other routines in the same unit.",
      "expect": "runtime_ok",
      "code": "program TypeSiblingLeak;\n\nprocedure Maker;\ntype\n  PItem = ^TItem;\n  TItem = record\n    Value: Integer;\n  end;\nvar\n  inst: PItem;\nbegin\n  new(inst);\n  inst^.Value := 1;\n  writeln('maker=', inst^.Value);\nend;\n\nprocedure Consumer;\nvar\n  inst: PItem;\nbegin\n  new(inst);\n  inst^.Value := 2;\n  writeln('consumer=', inst^.Value);\nend;\n\nbegin\n  Maker;\n  Consumer;\nend.",
      "expected_stdout": "maker=1\nconsumer=2",
      "failure_reason": "Current implementation leaks routine-local type aliases into the global namespace."
    },
    {
      "id": "type_forward_reference_compile_error",
      "name": "Types must be declared before use",
      "category": "resolution_scope",
      "description": "Variables declared before their type definition should fail to compile.",
      "expect": "compile_error",
      "code": "program TypeForwardReferenceError;\nvar\n  item: TRecord;\n\ntype\n  TRecord = record\n    Value: Integer;\n  end;\n\nbegin\n  item.Value := 5;\n  writeln('value=', item.Value);\nend.",
      "expected_stderr_substring": "Undefined type",
      "failure_reason": "Pascal requires types to be declared before they're referenced in variable sections."
    },
    {
      "id": "resolution_builtin_repeated_lookup_stability",
      "name": "Builtin detection remains stable across repeated lookups",
      "category": "resolution_scope",
      "description": "Exercise repeated builtin queries with case variants to ensure the hash-backed registry remains consistent.",
      "expect": "runtime_ok",
      "code": "program BuiltinRepeatedLookup;\nvar\n  first: Integer;\n  second: Integer;\nbegin\n  first := Abs(-5);\n  second := abs(-first);\n  writeln('first=', first);\n  writeln('second=', second);\n  Delay(0);\n  writeln('done');\nend.",
      "expected_stdout": "first=5\nsecond=5\ndone"
    },
    {
      "id": "integration_nested_scope_mix",
      "name": "Nested routines with shadowed consts and types",
      "category": "integration",
      "description": "Integration scenario combining shadowed constants, local types, and nested routines.",
      "expect": "runtime_ok",
      "code": "program IntegrationScopeMix;\nconst\n  Factor = 2;\ntype\n  PInfo = ^TInfo;\n  TInfo = record\n    Value: Integer;\n  end;\n\nprocedure Compute(start: Integer);\nconst\n  Factor = 3;\ntype\n  PLocalInfo = ^TLocalInfo;\n  TLocalInfo = record\n    Value: Integer;\n    Total: Integer;\n  end;\nvar\n  info: PLocalInfo;\n  step: Integer;\n  runningTotal: Integer;\n\n  procedure AddStep(multiplier: Integer);\n  begin\n    runningTotal := runningTotal + multiplier * start;\n  end;\n\nbegin\n  new(info);\n  info^.Value := start;\n  runningTotal := 0;\n  for step := 1 to Factor do\n  begin\n    AddStep(step);\n  end;\n  info^.Total := runningTotal;\n  writeln('inner_total=', info^.Total);\n  writeln('local_factor=', Factor);\nend;\n\nvar\n  summary: PInfo;\nbegin\n  new(summary);\n  summary^.Value := 4;\n  Compute(2);\n  writeln('outer_scaled=', summary^.Value * Factor);\nend.",
      "expected_stdout": "inner_total=12\nlocal_factor=3\nouter_scaled=12"
    }
  ]
}
