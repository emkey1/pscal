#!/usr/bin/env python3
import os, signal, sys, time, tempfile, subprocess, socket
from pathlib import Path

ROOT = Path(__file__).resolve().parents[2]
CLIKE = ROOT / 'build' / 'bin' / 'clike'
SERVER_SRC = ROOT / 'Examples' / 'clike' / 'simple_web_server'
PORT = None  # will be assigned dynamically

htdocs = Path(tempfile.mkdtemp(prefix='sws_'))
# Prepare a file with a space in the name
(htdocs / 'file name.txt').write_text('hello-file', encoding='utf-8')

srv = None

def cleanup(signum=None, frame=None):
    global srv
    try:
        if srv and srv.poll() is None:
            srv.terminate()
            try:
                srv.wait(2)
            except Exception:
                srv.kill()
    finally:
        # best effort cleanup of temp dir
        try:
            _cleanup_logs()
        except Exception:
            pass
    sys.exit(0)

signal.signal(signal.SIGTERM, cleanup)
signal.signal(signal.SIGINT, cleanup)

# Proactively kill any process currently listening on our test port
def kill_port(port: str):
    try:
        # Find PIDs listening on the port (macOS/Linux with lsof available)
        res = subprocess.run(['lsof', f'-tiTCP:{port}'], stdout=subprocess.PIPE,
                             stderr=subprocess.DEVNULL, text=True, check=False)
        pids = [int(x) for x in res.stdout.strip().splitlines() if x.strip()]
        if not pids:
            return
        # Try polite shutdown first
        for pid in pids:
            try:
                os.kill(pid, signal.SIGTERM)
            except ProcessLookupError:
                pass
        # Wait up to 2 seconds
        deadline = time.time() + 2.0
        while time.time() < deadline:
            alive = []
            for pid in pids:
                try:
                    os.kill(pid, 0)
                    alive.append(pid)
                except ProcessLookupError:
                    pass
            if not alive:
                break
            time.sleep(0.1)
        # Force kill any remaining
        for pid in pids:
            try:
                os.kill(pid, signal.SIGKILL)
            except ProcessLookupError:
                pass
    except Exception:
        # Best effort only; continue if lsof not available
        pass

def pick_free_port():
    import socket as _s
    sock = _s.socket(_s.AF_INET, _s.SOCK_STREAM)
    sock.bind(("127.0.0.1", 0))
    port = sock.getsockname()[1]
    sock.close()
    return str(port)

PORT = pick_free_port()
kill_port(PORT)

# Publish port for the client to read
try:
    Path('/tmp/pscal_sws_port').write_text(PORT, encoding='utf-8')
except Exception:
    pass

if not CLIKE.exists():
    print(f"clike binary not found: {CLIKE}", file=sys.stderr)
    sys.exit(1)
if not SERVER_SRC.exists():
    print(f"Server source not found: {SERVER_SRC}", file=sys.stderr)
    sys.exit(1)

# Launch via clike with arguments: root then port (per docs)
# Capture server stdout/stderr to temp files for debugging if startup fails.
srv_out = tempfile.NamedTemporaryFile(prefix='sws_server_', suffix='.out', delete=False)
srv_err = tempfile.NamedTemporaryFile(prefix='sws_server_', suffix='.err', delete=False)
srv = subprocess.Popen(
    [str(CLIKE), str(SERVER_SRC), str(htdocs), PORT],
    stdout=srv_out,
    stderr=srv_err,
)

# Wait up to ~10 seconds for server to accept connections
deadline = time.time() + 10.0
ready = False
while time.time() < deadline:
    try:
        with socket.create_connection(("127.0.0.1", int(PORT)), timeout=1.0) as _:
            ready = True
            break
    except Exception:
        if srv.poll() is not None:
            print("Server process exited prematurely", file=sys.stderr)
            break
        time.sleep(0.2)
def _dump_server_logs():
    try:
        srv_out.flush(); srv_err.flush()
    except Exception:
        pass
    try:
        print("--- server stderr ---", file=sys.stderr)
        with open(srv_err.name, 'r', encoding='utf-8', errors='replace') as f:
            sys.stderr.write(f.read())
    except Exception:
        pass
    try:
        print("--- server stdout ---", file=sys.stderr)
        with open(srv_out.name, 'r', encoding='utf-8', errors='replace') as f:
            sys.stderr.write(f.read())
    except Exception:
        pass

if not ready:
    print("Server did not start listening in time", file=sys.stderr)
    _dump_server_logs()

# Cleanup temp log files on exit
def _cleanup_logs():
    for p in (srv_out.name, srv_err.name):
        try:
            os.unlink(p)
        except Exception:
            pass

try:
    while True:
        time.sleep(5)
except KeyboardInterrupt:
    cleanup()
