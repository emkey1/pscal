#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "shell/parser.h"
#include "shell/semantics.h"
#include "shell/codegen.h"
#include "shell/opt.h"
#include "shell/builtins.h"
#include "core/preproc.h"
#include "core/build_info.h"
#include "compiler/bytecode.h"
#include "vm/vm.h"
#include "symbol/symbol.h"

int gParamCount = 0;
char **gParamValues = NULL;

static const char *SHELL_USAGE =
    "Usage: shellfe <options> <script.sh> [args...]\n"
    "   Options:\n"
    "     -v                          Display version information.\n"
    "     --dump-ast-json             Dump parsed AST as JSON.\n"
    "     --dump-bytecode             Disassemble generated bytecode.\n"
    "     --dump-bytecode-only        Disassemble bytecode and exit.\n"
    "     --dump-ext-builtins         List builtin commands.\n"
    "     --no-cache                  Ignored (compatibility).\n"
    "     --vm-trace-head=N           Trace first N VM instructions.\n";

static char *readFile(const char *path) {
    FILE *f = fopen(path, "rb");
    if (!f) {
        fprintf(stderr, "Unable to open '%s': %s\n", path, strerror(errno));
        return NULL;
    }
    if (fseek(f, 0, SEEK_END) != 0) {
        fclose(f);
        return NULL;
    }
    long len = ftell(f);
    if (len < 0) {
        fclose(f);
        return NULL;
    }
    rewind(f);
    char *buffer = (char *)malloc((size_t)len + 1);
    if (!buffer) {
        fclose(f);
        return NULL;
    }
    size_t read = fread(buffer, 1, (size_t)len, f);
    fclose(f);
    if (read != (size_t)len) {
        free(buffer);
        return NULL;
    }
    buffer[len] = '\0';
    return buffer;
}

int main(int argc, char **argv) {
    int dump_ast_json_flag = 0;
    int dump_bytecode_flag = 0;
    int dump_bytecode_only_flag = 0;
    int dump_ext_builtins_flag = 0;
    int no_cache_flag = 0;
    int vm_trace_head = 0;
    const char *path = NULL;
    int arg_start_index = 0;

    if (argc == 1) {
        fprintf(stderr, "%s\n", SHELL_USAGE);
        return EXIT_FAILURE;
    }

    for (int i = 1; i < argc; ++i) {
        if (strcmp(argv[i], "-v") == 0) {
            printf("Shell Frontend Version: %s (latest tag: %s)\n",
                   pscal_program_version_string(), pscal_git_tag_string());
            return vmExitWithCleanup(EXIT_SUCCESS);
        } else if (strcmp(argv[i], "--dump-ast-json") == 0) {
            dump_ast_json_flag = 1;
        } else if (strcmp(argv[i], "--dump-bytecode") == 0) {
            dump_bytecode_flag = 1;
        } else if (strcmp(argv[i], "--dump-bytecode-only") == 0) {
            dump_bytecode_flag = 1;
            dump_bytecode_only_flag = 1;
        } else if (strcmp(argv[i], "--dump-ext-builtins") == 0) {
            dump_ext_builtins_flag = 1;
        } else if (strcmp(argv[i], "--no-cache") == 0) {
            no_cache_flag = 1;
            (void)no_cache_flag; // compatibility; cache not implemented
        } else if (strncmp(argv[i], "--vm-trace-head=", 16) == 0) {
            vm_trace_head = atoi(argv[i] + 16);
        } else if (argv[i][0] == '-') {
            fprintf(stderr, "Unknown option: %s\n%s\n", argv[i], SHELL_USAGE);
            return EXIT_FAILURE;
        } else {
            path = argv[i];
            arg_start_index = i + 1;
            break;
        }
    }

    if (dump_ext_builtins_flag) {
        shellDumpBuiltins(stdout);
        return vmExitWithCleanup(EXIT_SUCCESS);
    }

    if (!path) {
        fprintf(stderr, "Error: no input script provided.\n%s\n", SHELL_USAGE);
        return EXIT_FAILURE;
    }

    char *src = readFile(path);
    if (!src) {
        return EXIT_FAILURE;
    }

    const char *defines[1];
    int define_count = 0;
    char *pre_src = preprocessConditionals(src, defines, define_count);

    ShellParser parser;
    ShellProgram *program = shellParseString(pre_src ? pre_src : src, &parser);
    shellParserFree(&parser);
    if (parser.had_error || !program) {
        fprintf(stderr, "Parsing failed.\n");
        if (program) {
            shellFreeProgram(program);
        }
        free(src);
        if (pre_src) free(pre_src);
        return EXIT_FAILURE;
    }

    if (dump_ast_json_flag) {
        shellDumpAstJson(stdout, program);
        shellFreeProgram(program);
        free(src);
        if (pre_src) free(pre_src);
        return EXIT_SUCCESS;
    }

    if (arg_start_index < argc) {
        gParamCount = argc - arg_start_index;
        gParamValues = &argv[arg_start_index];
    }

    ShellSemanticContext sem_ctx;
    shellInitSemanticContext(&sem_ctx);
    ShellSemanticResult sem_result = shellAnalyzeProgram(&sem_ctx, program);
    if (sem_result.warning_count > 0) {
        fprintf(stderr, "Semantic analysis produced %d warning(s).\n", sem_result.warning_count);
    }
    if (sem_result.error_count > 0) {
        fprintf(stderr, "Semantic analysis failed with %d error(s).\n", sem_result.error_count);
        shellFreeSemanticContext(&sem_ctx);
        shellFreeProgram(program);
        free(src);
        if (pre_src) free(pre_src);
        return EXIT_FAILURE;
    }

    ShellOptConfig opt_config = { false };
    shellRunOptimizations(program, &opt_config);

    BytecodeChunk chunk;
    shellCompile(program, &chunk);

    if (dump_bytecode_flag) {
        disassembleBytecodeChunk(&chunk, path ? path : "script", NULL);
        if (dump_bytecode_only_flag) {
            freeBytecodeChunk(&chunk);
            shellFreeSemanticContext(&sem_ctx);
            shellFreeProgram(program);
            free(src);
            if (pre_src) free(pre_src);
            return EXIT_SUCCESS;
        }
    }

    VM vm;
    initVM(&vm);
    if (vm_trace_head > 0) {
        vm.trace_head_instructions = vm_trace_head;
    }

    HashTable *globals = createHashTable();
    HashTable *consts = createHashTable();
    HashTable *procedures = createHashTable();

    InterpretResult result = interpretBytecode(&vm, &chunk, globals, consts, procedures, 0);

    freeHashTable(globals);
    freeHashTable(consts);
    freeHashTable(procedures);

    freeVM(&vm);
    freeBytecodeChunk(&chunk);
    shellFreeSemanticContext(&sem_ctx);
    shellFreeProgram(program);
    free(src);
    if (pre_src) free(pre_src);

    return result == INTERPRET_OK ? EXIT_SUCCESS : EXIT_FAILURE;
}
