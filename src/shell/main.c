#include <ctype.h>
#include <errno.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include "shell/parser.h"
#include "shell/semantics.h"
#include "shell/codegen.h"
#include "shell/opt.h"
#include "shell/builtins.h"
#include "core/preproc.h"
#include "core/build_info.h"
#include "core/cache.h"
#include "compiler/bytecode.h"
#include "backend_ast/builtin.h"
#include "Pascal/globals.h"
#include "vm/vm.h"
#include "symbol/symbol.h"

int gParamCount = 0;
char **gParamValues = NULL;

static const char *SHELL_USAGE =
    "Usage: psh <options> <script.sh> [args...]\n"
    "   Options:\n"
    "     -v                          Display version information.\n"
    "     --dump-ast-json             Dump parsed AST as JSON.\n"
    "     --dump-bytecode             Disassemble generated bytecode.\n"
    "     --dump-bytecode-only        Disassemble bytecode and exit.\n"
    "     --dump-ext-builtins         List builtin commands.\n"
    "     --no-cache                  Compile fresh (ignore cached bytecode).\n"
    "     --vm-trace-head=N           Trace first N VM instructions.\n";

static const char *const kShellCompilerId = "shell";

static char *readFile(const char *path) {
    FILE *f = fopen(path, "rb");
    if (!f) {
        fprintf(stderr, "Unable to open '%s': %s\n", path, strerror(errno));
        return NULL;
    }
    if (fseek(f, 0, SEEK_END) != 0) {
        fclose(f);
        return NULL;
    }
    long len = ftell(f);
    if (len < 0) {
        fclose(f);
        return NULL;
    }
    rewind(f);
    char *buffer = (char *)malloc((size_t)len + 1);
    if (!buffer) {
        fclose(f);
        return NULL;
    }
    size_t read = fread(buffer, 1, (size_t)len, f);
    fclose(f);
    if (read != (size_t)len) {
        free(buffer);
        return NULL;
    }
    buffer[len] = '\0';
    return buffer;
}

typedef struct {
    int dump_ast_json;
    int dump_bytecode;
    int dump_bytecode_only;
    int no_cache;
    int vm_trace_head;
    bool quiet;
    const char *frontend_path;
} ShellRunOptions;

static char *readStream(FILE *stream) {
    if (!stream) {
        return NULL;
    }
    size_t capacity = 4096;
    char *buffer = (char *)malloc(capacity);
    if (!buffer) {
        return NULL;
    }
    size_t length = 0;
    while (true) {
        if (capacity - length <= 1) {
            size_t new_capacity = capacity * 2;
            char *new_buffer = (char *)realloc(buffer, new_capacity);
            if (!new_buffer) {
                free(buffer);
                return NULL;
            }
            buffer = new_buffer;
            capacity = new_capacity;
        }
        size_t chunk_size = capacity - length - 1;
        size_t read_count = fread(buffer + length, 1, chunk_size, stream);
        length += read_count;
        if (read_count < chunk_size) {
            if (ferror(stream)) {
                free(buffer);
                return NULL;
            }
            break;
        }
    }
    buffer[length] = '\0';
    return buffer;
}

static int runShellSource(const char *source,
                          const char *path,
                          const ShellRunOptions *options,
                          bool *out_exit_requested) {
    if (out_exit_requested) {
        *out_exit_requested = false;
    }
    if (!source || !options) {
        return EXIT_FAILURE;
    }

    const char *defines[1];
    int define_count = 0;
    char *pre_src = preprocessConditionals(source, defines, define_count);

    globalSymbols = createHashTable();
    constGlobalSymbols = createHashTable();
    procedure_table = createHashTable();
    if (!globalSymbols || !constGlobalSymbols || !procedure_table) {
        fprintf(stderr, "shell: failed to allocate symbol tables.\n");
        if (globalSymbols) { freeHashTable(globalSymbols); globalSymbols = NULL; }
        if (constGlobalSymbols) { freeHashTable(constGlobalSymbols); constGlobalSymbols = NULL; }
        if (procedure_table) { freeHashTable(procedure_table); procedure_table = NULL; }
        if (pre_src) free(pre_src);
        return EXIT_FAILURE;
    }
    current_procedure_table = procedure_table;
    registerAllBuiltins();

    int exit_code = EXIT_FAILURE;
    ShellProgram *program = NULL;
    ShellSemanticContext sem_ctx;
    bool sem_ctx_initialized = false;
    BytecodeChunk chunk;
    bool chunk_initialized = false;
    VM vm;
    bool vm_initialized = false;
    bool exit_flag = false;

    ShellParser parser;
    program = shellParseString(pre_src ? pre_src : source, &parser);
    shellParserFree(&parser);
    if (parser.had_error || !program) {
        fprintf(stderr, "Parsing failed.\n");
        goto cleanup;
    }

    if (options->dump_ast_json) {
        shellDumpAstJson(stdout, program);
        exit_code = EXIT_SUCCESS;
        goto cleanup;
    }

    shellInitSemanticContext(&sem_ctx);
    sem_ctx_initialized = true;
    ShellSemanticResult sem_result = shellAnalyzeProgram(&sem_ctx, program);
    if (sem_result.warning_count > 0) {
        fprintf(stderr, "Semantic analysis produced %d warning(s).\n", sem_result.warning_count);
    }
    if (sem_result.error_count > 0) {
        fprintf(stderr, "Semantic analysis failed with %d error(s).\n", sem_result.error_count);
        goto cleanup;
    }

    initBytecodeChunk(&chunk);
    chunk_initialized = true;
    bool used_cache = false;
    if (!options->no_cache && path && path[0]) {
        used_cache = loadBytecodeFromCache(path, kShellCompilerId, options->frontend_path, NULL, 0, &chunk);
    }

    if (!used_cache) {
        ShellOptConfig opt_config = { false };
        shellRunOptimizations(program, &opt_config);
        shellCompile(program, &chunk);
        if (path && path[0] && !options->no_cache) {
            saveBytecodeToCache(path, kShellCompilerId, &chunk);
        }
        if (!options->quiet) {
            fprintf(stderr, "Compilation successful. Byte code size: %d bytes, Constants: %d\n",
                    chunk.count, chunk.constants_count);
        }
        if (options->dump_bytecode) {
            fprintf(stderr, "--- Compiling Shell Script to Bytecode ---\n");
            disassembleBytecodeChunk(&chunk, path ? path : "script", procedure_table);
            if (!options->dump_bytecode_only) {
                fprintf(stderr, "\n--- executing Script with VM ---\n");
            }
        }
    } else {
        if (!options->quiet) {
            fprintf(stderr, "Loaded cached bytecode. Byte code size: %d bytes, Constants: %d\n",
                    chunk.count, chunk.constants_count);
        }
        if (options->dump_bytecode) {
            disassembleBytecodeChunk(&chunk, path ? path : "script", procedure_table);
            if (!options->dump_bytecode_only) {
                fprintf(stderr, "\n--- executing Script with VM (cached) ---\n");
            }
        }
    }

    if (options->dump_bytecode_only) {
        exit_code = EXIT_SUCCESS;
        goto cleanup;
    }

    initVM(&vm);
    vm_initialized = true;
    if (options->vm_trace_head > 0) {
        vm.trace_head_instructions = options->vm_trace_head;
    }

    InterpretResult result = interpretBytecode(&vm, &chunk, globalSymbols, constGlobalSymbols, procedure_table, 0);
    int last_status = shellRuntimeLastStatus();
    exit_flag = shellRuntimeConsumeExitRequested();
    exit_code = (result == INTERPRET_OK) ? last_status : EXIT_FAILURE;

cleanup:
    if (out_exit_requested) {
        *out_exit_requested = exit_flag;
    } else {
        (void)exit_flag;
    }
    if (vm_initialized) {
        freeVM(&vm);
    }
    if (chunk_initialized) {
        freeBytecodeChunk(&chunk);
    }
    if (sem_ctx_initialized) {
        shellFreeSemanticContext(&sem_ctx);
    }
    if (program) {
        shellFreeProgram(program);
    }
    if (globalSymbols) { freeHashTable(globalSymbols); globalSymbols = NULL; }
    if (constGlobalSymbols) { freeHashTable(constGlobalSymbols); constGlobalSymbols = NULL; }
    if (procedure_table) { freeHashTable(procedure_table); procedure_table = NULL; }
    current_procedure_table = NULL;
    if (pre_src) {
        free(pre_src);
    }
    return exit_code;
}

static void redrawInteractiveLine(const char *prompt,
                                  const char *buffer,
                                  size_t length,
                                  size_t *displayed_length) {
    size_t previous = displayed_length ? *displayed_length : 0;
    fputs("\r", stdout);
    if (prompt) {
        fputs(prompt, stdout);
    }
    if (buffer && length > 0) {
        fwrite(buffer, 1, length, stdout);
    }
    if (previous > length) {
        size_t diff = previous - length;
        for (size_t i = 0; i < diff; ++i) {
            fputc(' ', stdout);
        }
        for (size_t i = 0; i < diff; ++i) {
            fputc('\b', stdout);
        }
    }
    fflush(stdout);
    if (displayed_length) {
        *displayed_length = length;
    }
}

static bool interactiveUpdateScratch(char **scratch, const char *buffer, size_t length) {
    if (!scratch) {
        return false;
    }
    char *new_scratch = (char *)realloc(*scratch, length + 1);
    if (!new_scratch) {
        return false;
    }
    if (buffer && length > 0) {
        memcpy(new_scratch, buffer, length);
    }
    new_scratch[length] = '\0';
    *scratch = new_scratch;
    return true;
}

static char *readInteractiveLine(const char *prompt,
                                 bool *out_eof,
                                 bool *out_editor_failed) {
    if (out_eof) {
        *out_eof = false;
    }
    if (out_editor_failed) {
        *out_editor_failed = false;
    }
    if (!prompt) {
        prompt = "";
    }

    struct termios original_termios;
    if (tcgetattr(STDIN_FILENO, &original_termios) != 0) {
        if (out_editor_failed) {
            *out_editor_failed = true;
        }
        return NULL;
    }

    struct termios raw_termios = original_termios;
    raw_termios.c_lflag &= ~(ICANON | ECHO);
    raw_termios.c_cc[VMIN] = 1;
    raw_termios.c_cc[VTIME] = 0;
    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw_termios) != 0) {
        if (out_editor_failed) {
            *out_editor_failed = true;
        }
        return NULL;
    }

    size_t capacity = 128;
    char *buffer = (char *)malloc(capacity);
    if (!buffer) {
        (void)tcsetattr(STDIN_FILENO, TCSAFLUSH, &original_termios);
        if (out_editor_failed) {
            *out_editor_failed = true;
        }
        return NULL;
    }
    buffer[0] = '\0';
    size_t length = 0;
    size_t displayed_length = 0;
    size_t history_index = 0;
    char *scratch = NULL;
    interactiveUpdateScratch(&scratch, buffer, length);

    fputs(prompt, stdout);
    fflush(stdout);

    bool done = false;
    bool eof_requested = false;

    while (!done) {
        unsigned char ch = 0;
        ssize_t read_count = read(STDIN_FILENO, &ch, 1);
        if (read_count <= 0) {
            eof_requested = true;
            break;
        }

        if (ch == '\r' || ch == '\n') {
            fputc('\n', stdout);
            fflush(stdout);
            done = true;
            break;
        }

        if (ch == 4) { /* Ctrl-D */
            if (length == 0) {
                eof_requested = true;
                break;
            }
            continue;
        }

        if (ch == 3) { /* Ctrl-C */
            fputs("^C\n", stdout);
            fflush(stdout);
            length = 0;
            buffer[0] = '\0';
            displayed_length = 0;
            history_index = 0;
            interactiveUpdateScratch(&scratch, buffer, length);
            fputs(prompt, stdout);
            fflush(stdout);
            continue;
        }

        if (ch == 127 || ch == 8) { /* Backspace */
            if (length > 0) {
                length--;
                buffer[length] = '\0';
                fputs("\b \b", stdout);
                fflush(stdout);
                displayed_length = length;
                history_index = 0;
                interactiveUpdateScratch(&scratch, buffer, length);
            }
            continue;
        }

        if (ch == 27) { /* Escape sequence */
            unsigned char seq[2];
            if (read(STDIN_FILENO, &seq[0], 1) <= 0) {
                continue;
            }
            if (read(STDIN_FILENO, &seq[1], 1) <= 0) {
                continue;
            }
            if (seq[0] == '[') {
                if (seq[1] == 'A') { /* Up arrow */
                    size_t history_count = shellRuntimeHistoryCount();
                    if (history_index < history_count) {
                        if (history_index == 0) {
                            interactiveUpdateScratch(&scratch, buffer, length);
                        }
                        history_index++;
                        char *entry = NULL;
                        if (shellRuntimeHistoryGetEntry(history_index - 1, &entry)) {
                            size_t entry_len = strlen(entry);
                            if (entry_len + 1 > capacity) {
                                size_t new_capacity = entry_len + 1;
                                char *new_buffer = (char *)realloc(buffer, new_capacity);
                                if (!new_buffer) {
                                    free(entry);
                                    history_index--;
                                    fputc('\a', stdout);
                                    fflush(stdout);
                                    continue;
                                }
                                buffer = new_buffer;
                                capacity = new_capacity;
                            }
                            memcpy(buffer, entry, entry_len);
                            buffer[entry_len] = '\0';
                            length = entry_len;
                            redrawInteractiveLine(prompt, buffer, length, &displayed_length);
                        } else {
                            history_index--;
                            fputc('\a', stdout);
                            fflush(stdout);
                        }
                        free(entry);
                    } else {
                        fputc('\a', stdout);
                        fflush(stdout);
                    }
                    continue;
                } else if (seq[1] == 'B') { /* Down arrow */
                    if (history_index > 0) {
                        history_index--;
                        const char *replacement = "";
                        char *entry = NULL;
                        if (history_index > 0) {
                            if (shellRuntimeHistoryGetEntry(history_index - 1, &entry)) {
                                replacement = entry;
                            }
                        } else if (scratch) {
                            replacement = scratch;
                        }
                        size_t entry_len = strlen(replacement);
                        if (entry_len + 1 > capacity) {
                            size_t new_capacity = entry_len + 1;
                            char *new_buffer = (char *)realloc(buffer, new_capacity);
                            if (!new_buffer) {
                                free(entry);
                                fputc('\a', stdout);
                                fflush(stdout);
                                continue;
                            }
                            buffer = new_buffer;
                            capacity = new_capacity;
                        }
                        memcpy(buffer, replacement, entry_len);
                        buffer[entry_len] = '\0';
                        length = entry_len;
                        redrawInteractiveLine(prompt, buffer, length, &displayed_length);
                        if (history_index == 0) {
                            interactiveUpdateScratch(&scratch, buffer, length);
                        }
                        free(entry);
                    }
                    continue;
                }
            }
            continue;
        }

        if (!isprint(ch)) {
            fputc('\a', stdout);
            fflush(stdout);
            continue;
        }

        if (length + 1 >= capacity) {
            size_t new_capacity = capacity * 2;
            if (new_capacity <= length + 1) {
                new_capacity = length + 2;
            }
            char *new_buffer = (char *)realloc(buffer, new_capacity);
            if (!new_buffer) {
                fputc('\a', stdout);
                fflush(stdout);
                continue;
            }
            buffer = new_buffer;
            capacity = new_capacity;
        }

        buffer[length++] = (char)ch;
        buffer[length] = '\0';
        fputc((char)ch, stdout);
        fflush(stdout);
        displayed_length = length;
        history_index = 0;
        interactiveUpdateScratch(&scratch, buffer, length);
    }

    (void)tcsetattr(STDIN_FILENO, TCSAFLUSH, &original_termios);
    free(scratch);

    if (eof_requested && length == 0) {
        free(buffer);
        if (out_eof) {
            *out_eof = true;
        }
        return NULL;
    }

    if (!done) {
        free(buffer);
        if (out_editor_failed) {
            *out_editor_failed = true;
        }
        return NULL;
    }

    char *result = (char *)realloc(buffer, length + 1);
    if (!result) {
        result = buffer;
    }
    result[length] = '\0';
    return result;
}

static int runInteractiveSession(const ShellRunOptions *options) {
    ShellRunOptions exec_opts = *options;
    exec_opts.no_cache = 1;
    exec_opts.quiet = true;

    int last_status = shellRuntimeLastStatus();
    bool tty = isatty(STDIN_FILENO);

    while (true) {
        char *line = NULL;
        bool interactive_eof = false;
        bool editor_failed = false;
        if (tty) {
            line = readInteractiveLine("psh$ ", &interactive_eof, &editor_failed);
            if (!line && editor_failed) {
                tty = false;
            }
            if (!line && interactive_eof) {
                fputc('\n', stdout);
                break;
            }
        }
        size_t line_capacity = 0;
        ssize_t read = 0;
        if (!line) {
            if (isatty(STDIN_FILENO)) {
                fputs("psh$ ", stdout);
                fflush(stdout);
            }
            read = getline(&line, &line_capacity, stdin);
            if (read < 0) {
                free(line);
                if (isatty(STDIN_FILENO)) {
                    fputc('\n', stdout);
                }
                break;
            }
        } else {
            read = (ssize_t)strlen(line);
        }
        bool only_whitespace = true;
        for (ssize_t i = 0; i < read; ++i) {
            if (line[i] != ' ' && line[i] != '\t' && line[i] != '\n' && line[i] != '\r') {
                only_whitespace = false;
                break;
            }
        }
        if (only_whitespace) {
            free(line);
            continue;
        }

        char *expanded_line = NULL;
        bool used_history = false;
        char *history_error = NULL;
        if (!shellRuntimeExpandHistoryReference(line, &expanded_line, &used_history, &history_error)) {
            if (history_error) {
                fprintf(stderr, "psh: %s: event not found\n", history_error);
                free(history_error);
            } else {
                fprintf(stderr, "psh: history expansion failed\n");
            }
            free(line);
            continue;
        }
        if (used_history && isatty(STDIN_FILENO)) {
            printf("%s\n", expanded_line);
            fflush(stdout);
        }
        if (history_error) {
            free(history_error);
        }
        free(line);
        line = expanded_line;

        shellRuntimeRecordHistory(line);
        bool exit_requested = false;
        last_status = runShellSource(line, "<stdin>", &exec_opts, &exit_requested);
        free(line);
        if (exit_requested) {
            break;
        }
    }

    return last_status;
}

int main(int argc, char **argv) {
    ShellRunOptions options = {0};
    options.frontend_path = (argc > 0) ? argv[0] : "psh";
    shellRuntimeSetArg0(options.frontend_path);

    int dump_ext_builtins_flag = 0;
    const char *path = NULL;
    int arg_start_index = 0;

    for (int i = 1; i < argc; ++i) {
        if (strcmp(argv[i], "-v") == 0) {
            printf("Shell Frontend Version: %s (latest tag: %s)\n",
                   pscal_program_version_string(), pscal_git_tag_string());
            return vmExitWithCleanup(EXIT_SUCCESS);
        } else if (strcmp(argv[i], "--dump-ast-json") == 0) {
            options.dump_ast_json = 1;
        } else if (strcmp(argv[i], "--dump-bytecode") == 0) {
            options.dump_bytecode = 1;
        } else if (strcmp(argv[i], "--dump-bytecode-only") == 0) {
            options.dump_bytecode = 1;
            options.dump_bytecode_only = 1;
        } else if (strcmp(argv[i], "--dump-ext-builtins") == 0) {
            dump_ext_builtins_flag = 1;
        } else if (strcmp(argv[i], "--no-cache") == 0) {
            options.no_cache = 1;
        } else if (strncmp(argv[i], "--vm-trace-head=", 16) == 0) {
            options.vm_trace_head = atoi(argv[i] + 16);
        } else if (argv[i][0] == '-') {
            fprintf(stderr, "Unknown option: %s\n%s\n", argv[i], SHELL_USAGE);
            return EXIT_FAILURE;
        } else {
            path = argv[i];
            arg_start_index = i + 1;
            break;
        }
    }

    if (dump_ext_builtins_flag) {
        shellDumpBuiltins(stdout);
        return vmExitWithCleanup(EXIT_SUCCESS);
    }

    setenv("PSCALSHELL_LAST_STATUS", "0", 1);

    if (path) {
        char *src = readFile(path);
        if (!src) {
            return EXIT_FAILURE;
        }
        if (arg_start_index < argc) {
            gParamCount = argc - arg_start_index;
            gParamValues = &argv[arg_start_index];
        }
        shellRuntimeSetArg0(path);
        bool exit_requested = false;
        int status = runShellSource(src, path, &options, &exit_requested);
        (void)exit_requested;
        free(src);
        shellRuntimeSetArg0(options.frontend_path);
        return vmExitWithCleanup(status);
    }

    gParamCount = 0;
    gParamValues = NULL;

    if (isatty(STDIN_FILENO)) {
        int status = runInteractiveSession(&options);
        return vmExitWithCleanup(status);
    }

    char *stdin_src = readStream(stdin);
    if (!stdin_src) {
        return EXIT_FAILURE;
    }

    ShellRunOptions stdin_opts = options;
    stdin_opts.no_cache = 1;
    stdin_opts.quiet = true;
    bool exit_requested = false;
    int status = runShellSource(stdin_src, "<stdin>", &stdin_opts, &exit_requested);
    (void)exit_requested;
    free(stdin_src);
    return vmExitWithCleanup(status);
}
