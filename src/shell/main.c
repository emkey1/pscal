#include <ctype.h>
#include <errno.h>
#include <glob.h>
#include <limits.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>
#include "shell/parser.h"
#include "shell/semantics.h"
#include "shell/codegen.h"
#include "shell/opt.h"
#include "shell/builtins.h"
#include "shell/runner.h"
#include "core/preproc.h"
#include "core/build_info.h"
#include "core/cache.h"
#include "compiler/bytecode.h"
#include "backend_ast/builtin.h"
#include "Pascal/globals.h"
#include "vm/vm.h"
#include "symbol/symbol.h"

int gParamCount = 0;
char **gParamValues = NULL;

static struct termios gInteractiveOriginalTermios;
static volatile sig_atomic_t gInteractiveTermiosValid = 0;
static struct sigaction gInteractiveOldSigintAction;
static volatile sig_atomic_t gInteractiveHasOldSigint = 0;
static struct sigaction gInteractiveOldSigtstpAction;
static volatile sig_atomic_t gInteractiveHasOldSigtstp = 0;

static void interactiveRestoreTerminal(void) {
    if (gInteractiveTermiosValid) {
        (void)tcsetattr(STDIN_FILENO, TCSAFLUSH, &gInteractiveOriginalTermios);
        gInteractiveTermiosValid = 0;
    }
}

static void interactiveRestoreSigintHandler(void) {
    if (gInteractiveHasOldSigint) {
        (void)sigaction(SIGINT, &gInteractiveOldSigintAction, NULL);
        gInteractiveHasOldSigint = 0;
    }
}

static void interactiveRestoreSigtstpHandler(void) {
    if (gInteractiveHasOldSigtstp) {
        (void)sigaction(SIGTSTP, &gInteractiveOldSigtstpAction, NULL);
        gInteractiveHasOldSigtstp = 0;
    }
}

static void interactiveSigintHandler(int signo) {
    interactiveRestoreSigintHandler();
    interactiveRestoreSigtstpHandler();
    interactiveRestoreTerminal();
    raise(signo);
}

static const char *SHELL_USAGE =
    "Usage: exsh <options> <script.sh> [args...]\n"
    "   Options:\n"
    "     -v                          Display version information.\n"
    "     --dump-ast-json             Dump parsed AST as JSON.\n"
    "     --dump-bytecode             Disassemble generated bytecode.\n"
    "     --dump-bytecode-only        Disassemble bytecode and exit.\n"
    "     --dump-ext-builtins         List builtin commands.\n"
    "     --no-cache                  Compile fresh (ignore cached bytecode).\n"
    "     --vm-trace-head=N           Trace first N VM instructions.\n"
    "     -d                          Enable verbose VM error diagnostics.\n";

static char *readStream(FILE *stream) {
    if (!stream) {
        return NULL;
    }
    size_t capacity = 4096;
    char *buffer = (char *)malloc(capacity);
    if (!buffer) {
        return NULL;
    }
    size_t length = 0;
    while (true) {
        if (capacity - length <= 1) {
            size_t new_capacity = capacity * 2;
            char *new_buffer = (char *)realloc(buffer, new_capacity);
            if (!new_buffer) {
                free(buffer);
                return NULL;
            }
            buffer = new_buffer;
            capacity = new_capacity;
        }
        size_t chunk_size = capacity - length - 1;
        size_t read_count = fread(buffer + length, 1, chunk_size, stream);
        length += read_count;
        if (read_count < chunk_size) {
            if (ferror(stream)) {
                free(buffer);
                return NULL;
            }
            break;
        }
    }
    buffer[length] = '\0';
    return buffer;
}

static bool promptBufferEnsureCapacity(char **buffer, size_t *capacity, size_t needed) {
    if (!buffer || !capacity) {
        return false;
    }
    if (needed <= *capacity) {
        return true;
    }
    size_t new_capacity = *capacity ? *capacity : 64;
    while (new_capacity < needed) {
        if (new_capacity > SIZE_MAX / 2) {
            new_capacity = needed;
            break;
        }
        new_capacity *= 2;
    }
    char *new_buffer = (char *)realloc(*buffer, new_capacity);
    if (!new_buffer) {
        return false;
    }
    *buffer = new_buffer;
    *capacity = new_capacity;
    return true;
}

static bool promptBufferAppendChar(char **buffer,
                                   size_t *length,
                                   size_t *capacity,
                                   char c) {
    if (!buffer || !length || !capacity) {
        return false;
    }
    size_t needed = (*length) + 2;
    if (!promptBufferEnsureCapacity(buffer, capacity, needed)) {
        return false;
    }
    (*buffer)[*length] = c;
    (*length)++;
    (*buffer)[*length] = '\0';
    return true;
}

static bool promptBufferAppendString(char **buffer,
                                     size_t *length,
                                     size_t *capacity,
                                     const char *text) {
    if (!text) {
        return true;
    }
    size_t text_len = strlen(text);
    if (text_len == 0) {
        return true;
    }
    size_t needed = (*length) + text_len + 1;
    if (!promptBufferEnsureCapacity(buffer, capacity, needed)) {
        return false;
    }
    memcpy((*buffer) + *length, text, text_len);
    *length += text_len;
    (*buffer)[*length] = '\0';
    return true;
}

static bool promptBufferAppendTime(char **buffer,
                                   size_t *length,
                                   size_t *capacity,
                                   const char *format) {
    time_t now = time(NULL);
    struct tm tm_info;
    struct tm *tm_ptr = localtime(&now);
    if (!tm_ptr) {
        return true;
    }
    tm_info = *tm_ptr;
    char formatted[64];
    size_t written = strftime(formatted, sizeof(formatted), format, &tm_info);
    if (written == 0) {
        return true;
    }
    formatted[written] = '\0';
    return promptBufferAppendString(buffer, length, capacity, formatted);
}

static bool promptBufferAppendWorkingDir(char **buffer,
                                         size_t *length,
                                         size_t *capacity,
                                         bool basename_only) {
    char cwd[PATH_MAX];
    if (!getcwd(cwd, sizeof(cwd))) {
        return true;
    }
    char display[PATH_MAX + 2];
    strncpy(display, cwd, sizeof(display));
    display[sizeof(display) - 1] = '\0';

    const char *home = getenv("HOME");
    if (home && *home) {
        size_t home_len = strlen(home);
        if (home_len > 0 && strncmp(display, home, home_len) == 0 &&
            (display[home_len] == '/' || display[home_len] == '\0')) {
            char replaced[PATH_MAX + 2];
            replaced[0] = '~';
            size_t rest_len = strlen(display + home_len);
            if (rest_len > sizeof(replaced) - 2) {
                rest_len = sizeof(replaced) - 2;
            }
            memcpy(replaced + 1, display + home_len, rest_len + 1);
            strncpy(display, replaced, sizeof(display));
            display[sizeof(display) - 1] = '\0';
        }
    }

    size_t disp_len = strlen(display);
    while (disp_len > 1 && display[disp_len - 1] == '/') {
        display[disp_len - 1] = '\0';
        disp_len--;
    }

    const char *segment = display;
    if (basename_only) {
        if (strcmp(display, "~") == 0) {
            segment = "~";
        } else {
            char *slash = strrchr(display, '/');
            if (slash) {
                if (slash == display) {
                    if (slash[1] == '\0') {
                        segment = "/";
                    } else {
                        segment = slash + 1;
                    }
                } else if (slash[1] != '\0') {
                    segment = slash + 1;
                } else {
                    *slash = '\0';
                    slash = strrchr(display, '/');
                    if (!slash) {
                        segment = display;
                    } else if (slash[1] != '\0') {
                        segment = slash + 1;
                    } else if (slash == display) {
                        segment = "/";
                    }
                }
            }
        }
    }

    return promptBufferAppendString(buffer, length, capacity, segment);
}

static char *shellFormatPrompt(const char *input) {
    if (!input) {
        return NULL;
    }
    char *buffer = NULL;
    size_t length = 0;
    size_t capacity = 0;

    for (size_t i = 0; input[i]; ++i) {
        char c = input[i];
        if (c != '\\') {
            if (!promptBufferAppendChar(&buffer, &length, &capacity, c)) {
                free(buffer);
                return NULL;
            }
            continue;
        }

        ++i;
        char next = input[i];
        if (next == '\0') {
            if (!promptBufferAppendChar(&buffer, &length, &capacity, '\\')) {
                free(buffer);
                return NULL;
            }
            break;
        }

        switch (next) {
            case '[':
            case ']':
                break;
            case '\\':
                if (!promptBufferAppendChar(&buffer, &length, &capacity, '\\')) {
                    free(buffer);
                    return NULL;
                }
                break;
            case 'a':
                if (!promptBufferAppendChar(&buffer, &length, &capacity, '\a')) {
                    free(buffer);
                    return NULL;
                }
                break;
            case 'e':
            case 'E':
                if (!promptBufferAppendChar(&buffer, &length, &capacity, '\033')) {
                    free(buffer);
                    return NULL;
                }
                break;
            case 'n':
                if (!promptBufferAppendChar(&buffer, &length, &capacity, '\n')) {
                    free(buffer);
                    return NULL;
                }
                break;
            case 'r':
                if (!promptBufferAppendChar(&buffer, &length, &capacity, '\r')) {
                    free(buffer);
                    return NULL;
                }
                break;
            case 't':
                if (!promptBufferAppendTime(&buffer, &length, &capacity, "%H:%M:%S")) {
                    free(buffer);
                    return NULL;
                }
                break;
            case 'T':
                if (!promptBufferAppendTime(&buffer, &length, &capacity, "%I:%M:%S")) {
                    free(buffer);
                    return NULL;
                }
                break;
            case '@':
                if (!promptBufferAppendTime(&buffer, &length, &capacity, "%I:%M%p")) {
                    free(buffer);
                    return NULL;
                }
                break;
            case 'A':
                if (!promptBufferAppendTime(&buffer, &length, &capacity, "%H:%M")) {
                    free(buffer);
                    return NULL;
                }
                break;
            case 'd':
                if (!promptBufferAppendTime(&buffer, &length, &capacity, "%a %b %d")) {
                    free(buffer);
                    return NULL;
                }
                break;
            case 'D':
                if (!promptBufferAppendTime(&buffer, &length, &capacity, "%m/%d/%y")) {
                    free(buffer);
                    return NULL;
                }
                break;
            case 'w':
                if (!promptBufferAppendWorkingDir(&buffer, &length, &capacity, false)) {
                    free(buffer);
                    return NULL;
                }
                break;
            case 'W':
                if (!promptBufferAppendWorkingDir(&buffer, &length, &capacity, true)) {
                    free(buffer);
                    return NULL;
                }
                break;
            case 'u': {
                const char *user = getenv("USER");
                if (!user || !*user) {
                    user = getenv("USERNAME");
                }
                if (user && *user) {
                    if (!promptBufferAppendString(&buffer, &length, &capacity, user)) {
                        free(buffer);
                        return NULL;
                    }
                }
                break;
            }
            case 'h':
            case 'H': {
                char hostname[256];
                if (gethostname(hostname, sizeof(hostname)) == 0) {
                    hostname[sizeof(hostname) - 1] = '\0';
                    if (next == 'h') {
                        char *dot = strchr(hostname, '.');
                        if (dot) {
                            *dot = '\0';
                        }
                    }
                    if (!promptBufferAppendString(&buffer, &length, &capacity, hostname)) {
                        free(buffer);
                        return NULL;
                    }
                }
                break;
            }
            case 's':
                if (!promptBufferAppendString(&buffer, &length, &capacity, "exsh")) {
                    free(buffer);
                    return NULL;
                }
                break;
            case '$': {
                char symbol = (geteuid() == 0) ? '#' : '$';
                if (!promptBufferAppendChar(&buffer, &length, &capacity, symbol)) {
                    free(buffer);
                    return NULL;
                }
                break;
            }
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7': {
                int value = next - '0';
                size_t consumed = 0;
                while (consumed < 2 && input[i + 1] >= '0' && input[i + 1] <= '7') {
                    value = (value * 8) + (input[i + 1] - '0');
                    ++i;
                    ++consumed;
                }
                if (!promptBufferAppendChar(&buffer, &length, &capacity, (char)value)) {
                    free(buffer);
                    return NULL;
                }
                break;
            }
            case 'x':
            case 'X': {
                int value = 0;
                size_t consumed = 0;
                while (consumed < 2) {
                    char hex = input[i + 1];
                    if (!isxdigit((unsigned char)hex)) {
                        break;
                    }
                    value *= 16;
                    if (hex >= '0' && hex <= '9') {
                        value += hex - '0';
                    } else {
                        value += 10 + (tolower((unsigned char)hex) - 'a');
                    }
                    ++i;
                    ++consumed;
                }
                if (consumed == 0) {
                    if (!promptBufferAppendChar(&buffer, &length, &capacity, next)) {
                        free(buffer);
                        return NULL;
                    }
                } else {
                    if (!promptBufferAppendChar(&buffer, &length, &capacity, (char)value)) {
                        free(buffer);
                        return NULL;
                    }
                }
                break;
            }
            default:
                if (!promptBufferAppendChar(&buffer, &length, &capacity, next)) {
                    free(buffer);
                    return NULL;
                }
                break;
        }
    }

    if (!buffer) {
        buffer = strdup("");
    }
    return buffer;
}

static char *shellResolveInteractivePrompt(void) {
    const char *env_prompt = getenv("PS1");
    if (!env_prompt || !*env_prompt) {
        env_prompt = "exsh$ ";
    }
    char *formatted = shellFormatPrompt(env_prompt);
    if (formatted) {
        return formatted;
    }
    return strdup(env_prompt);
}

static size_t shellPromptLineBreakCount(const char *prompt) {
    if (!prompt) {
        return 0;
    }
    size_t count = 0;
    for (const char *cursor = prompt; *cursor; ++cursor) {
        if (*cursor == '\n') {
            ++count;
        }
    }
    return count;
}

static void redrawInteractiveLine(const char *prompt,
                                  const char *buffer,
                                  size_t length,
                                  size_t cursor,
                                  size_t *displayed_length,
                                  size_t *displayed_prompt_lines) {
    size_t previous = displayed_length ? *displayed_length : 0;
    size_t previous_prompt_lines =
        displayed_prompt_lines ? *displayed_prompt_lines : 0;
    fputs("\r", stdout);
    for (size_t i = 0; i < previous_prompt_lines; ++i) {
        fputs("\033[A", stdout);
    }
    if (prompt) {
        fputs(prompt, stdout);
    }
    if (buffer && length > 0) {
        fwrite(buffer, 1, length, stdout);
    }
    if (previous > length) {
        size_t diff = previous - length;
        for (size_t i = 0; i < diff; ++i) {
            fputc(' ', stdout);
        }
        for (size_t i = 0; i < diff; ++i) {
            fputc('\b', stdout);
        }
    }
    size_t desired_cursor = cursor;
    if (desired_cursor < length) {
        size_t moves = length - desired_cursor;
        for (size_t i = 0; i < moves; ++i) {
            fputc('\b', stdout);
        }
    }
    fflush(stdout);
    if (displayed_length) {
        *displayed_length = length;
    }
    if (displayed_prompt_lines) {
        *displayed_prompt_lines = shellPromptLineBreakCount(prompt);
    }
}

static bool interactiveEnsureCapacity(char **buffer, size_t *capacity, size_t needed) {
    if (!buffer || !capacity) {
        return false;
    }
    if (needed <= *capacity) {
        return true;
    }
    size_t new_capacity = *capacity ? *capacity : 128;
    while (new_capacity < needed) {
        if (new_capacity > SIZE_MAX / 2) {
            new_capacity = needed;
            break;
        }
        new_capacity *= 2;
    }
    char *new_buffer = (char *)realloc(*buffer, new_capacity);
    if (!new_buffer) {
        return false;
    }
    *buffer = new_buffer;
    *capacity = new_capacity;
    return true;
}

static bool interactiveUpdateScratch(char **scratch, const char *buffer, size_t length) {
    if (!scratch) {
        return false;
    }
    char *new_scratch = (char *)realloc(*scratch, length + 1);
    if (!new_scratch) {
        return false;
    }
    if (buffer && length > 0) {
        memcpy(new_scratch, buffer, length);
    }
    new_scratch[length] = '\0';
    *scratch = new_scratch;
    return true;
}

static size_t interactiveFindWordStart(const char *buffer, size_t length) {
    if (!buffer || length == 0) {
        return length;
    }
    size_t index = length;
    while (index > 0) {
        unsigned char c = (unsigned char)buffer[index - 1];
        if (c == ' ' || c == '\t' || c == '\n' || c == '\r') {
            break;
        }
        index--;
    }
    return index;
}

static bool interactiveWordLooksDynamic(const char *word) {
    if (!word || !*word) {
        return false;
    }
    bool escaped = false;
    for (const char *cursor = word; *cursor; ++cursor) {
        if (escaped) {
            escaped = false;
            continue;
        }
        if (*cursor == '\\') {
            escaped = true;
            continue;
        }
        if (*cursor == '\'' || *cursor == '"' || *cursor == '$' || *cursor == '`') {
            return true;
        }
    }
    return false;
}

static size_t interactiveCommonPrefixLength(char *const *items, size_t count) {
    if (!items || count == 0) {
        return 0;
    }
    const char *first = items[0];
    if (!first) {
        return 0;
    }
    size_t prefix_len = strlen(first);
    for (size_t i = 1; i < count && prefix_len > 0; ++i) {
        const char *item = items[i];
        if (!item) {
            prefix_len = 0;
            break;
        }
        size_t j = 0;
        while (j < prefix_len && first[j] == item[j]) {
            ++j;
        }
        prefix_len = j;
    }
    return prefix_len;
}

static bool interactiveHandleTabCompletion(const char *prompt,
                                           char **buffer,
                                           size_t *length,
                                           size_t *cursor,
                                           size_t *capacity,
                                           size_t *displayed_length,
                                           size_t *displayed_prompt_lines,
                                           char **scratch) {
    if (!buffer || !*buffer || !length || !capacity || !cursor) {
        return false;
    }
    if (*cursor != *length) {
        return false;
    }
    size_t word_start = interactiveFindWordStart(*buffer, *length);
    if (word_start >= *length) {
        return false;
    }
    char *word = *buffer + word_start;
    size_t word_len = *length - word_start;
    if (interactiveWordLooksDynamic(word)) {
        return false;
    }
    for (size_t i = 0; i < word_len; ++i) {
        if (word[i] == '*' || word[i] == '?' || word[i] == '[') {
            return false;
        }
    }

    size_t pattern_len = word_len + 2;
    char *pattern = (char *)malloc(pattern_len);
    if (!pattern) {
        return false;
    }
    memcpy(pattern, word, word_len);
    pattern[word_len] = '*';
    pattern[word_len + 1] = '\0';

    glob_t results;
    memset(&results, 0, sizeof(results));
    int glob_flags = GLOB_TILDE | GLOB_MARK;
    int glob_status = glob(pattern, glob_flags, NULL, &results);
    free(pattern);
    if (glob_status != 0 || results.gl_pathc == 0) {
        globfree(&results);
        return false;
    }

    size_t replacement_len = 0;
    bool append_space = false;
    if (results.gl_pathc == 1) {
        const char *match = results.gl_pathv[0];
        if (!match) {
            globfree(&results);
            return false;
        }
        replacement_len = strlen(match);
        if (replacement_len > 0 && match[replacement_len - 1] != '/') {
            append_space = true;
        }
    } else {
        replacement_len = interactiveCommonPrefixLength(results.gl_pathv, results.gl_pathc);
        if (replacement_len <= word_len) {
            globfree(&results);
            return false;
        }
    }

    size_t total_len = word_start + replacement_len + (append_space ? 1 : 0);
    if (!interactiveEnsureCapacity(buffer, capacity, total_len + 1)) {
        globfree(&results);
        return false;
    }

    if (results.gl_pathc == 1) {
        memcpy(*buffer + word_start, results.gl_pathv[0], replacement_len);
    } else {
        memcpy(*buffer + word_start, results.gl_pathv[0], replacement_len);
    }
    if (append_space) {
        (*buffer)[word_start + replacement_len] = ' ';
        replacement_len += 1;
    }
    *length = word_start + replacement_len;
    (*buffer)[*length] = '\0';
    globfree(&results);

    *cursor = *length;
    redrawInteractiveLine(prompt,
                          *buffer,
                          *length,
                          *cursor,
                          displayed_length,
                          displayed_prompt_lines);
    if (scratch) {
        interactiveUpdateScratch(scratch, *buffer, *length);
    }
    return true;
}

static char *interactiveExpandTilde(const char *line) {
    if (!line) {
        return NULL;
    }
    const char *home = getenv("HOME");
    if (!home || !*home) {
        return strdup(line);
    }
    size_t home_len = strlen(home);
    size_t capacity = strlen(line) + home_len + 1;
    char *result = (char *)malloc(capacity);
    if (!result) {
        return NULL;
    }
    size_t out_len = 0;
    bool in_single_quote = false;
    bool in_double_quote = false;
    bool escaped = false;
    for (size_t i = 0; line[i] != '\0'; ++i) {
        unsigned char c = (unsigned char)line[i];
        if (escaped) {
            if (!interactiveEnsureCapacity(&result, &capacity, out_len + 2)) {
                free(result);
                return NULL;
            }
            result[out_len++] = (char)c;
            escaped = false;
            continue;
        }
        if (c == '\\') {
            if (!interactiveEnsureCapacity(&result, &capacity, out_len + 2)) {
                free(result);
                return NULL;
            }
            result[out_len++] = (char)c;
            escaped = true;
            continue;
        }
        if (c == '\'' && !in_double_quote) {
            in_single_quote = !in_single_quote;
        } else if (c == '"' && !in_single_quote) {
            in_double_quote = !in_double_quote;
        }
        bool expand = false;
        if (!in_single_quote && !in_double_quote && c == '~') {
            char prev = (i > 0) ? line[i - 1] : '\0';
            if (i == 0 || prev == ' ' || prev == '\t' || prev == '\n' || prev == '\r' || prev == '=') {
                char next = line[i + 1];
                if (next == '/' || next == '\0') {
                    expand = true;
                }
            }
        }
        if (expand) {
            if (!interactiveEnsureCapacity(&result, &capacity, out_len + home_len + 1)) {
                free(result);
                return NULL;
            }
            memcpy(result + out_len, home, home_len);
            out_len += home_len;
            continue;
        }
        if (!interactiveEnsureCapacity(&result, &capacity, out_len + 2)) {
            free(result);
            return NULL;
        }
        result[out_len++] = (char)c;
    }
    char *new_result = (char *)realloc(result, out_len + 1);
    if (new_result) {
        result = new_result;
    }
    result[out_len] = '\0';
    return result;
}

static char *readInteractiveLine(const char *prompt,
                                 bool *out_eof,
                                 bool *out_editor_failed) {
    bool installed_sigint_handler = false;
    if (out_eof) {
        *out_eof = false;
    }
    if (out_editor_failed) {
        *out_editor_failed = false;
    }
    if (!prompt) {
        prompt = "";
    }

    struct termios original_termios;
    if (tcgetattr(STDIN_FILENO, &original_termios) != 0) {
        if (out_editor_failed) {
            *out_editor_failed = true;
        }
        return NULL;
    }

    struct termios raw_termios = original_termios;
    raw_termios.c_lflag &= ~(ICANON | ECHO);
    raw_termios.c_cc[VMIN] = 1;
    raw_termios.c_cc[VTIME] = 0;
    gInteractiveOriginalTermios = original_termios;
    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw_termios) != 0) {
        if (out_editor_failed) {
            *out_editor_failed = true;
        }
        return NULL;
    }
    gInteractiveTermiosValid = 1;

    struct sigaction sigint_action;
    memset(&sigint_action, 0, sizeof(sigint_action));
    sigemptyset(&sigint_action.sa_mask);
    sigint_action.sa_handler = interactiveSigintHandler;
    if (sigaction(SIGINT, &sigint_action, &gInteractiveOldSigintAction) != 0) {
        interactiveRestoreTerminal();
        if (out_editor_failed) {
            *out_editor_failed = true;
        }
        return NULL;
    }
    gInteractiveHasOldSigint = 1;
    installed_sigint_handler = true;

    struct sigaction sigtstp_action;
    memset(&sigtstp_action, 0, sizeof(sigtstp_action));
    sigemptyset(&sigtstp_action.sa_mask);
    sigtstp_action.sa_handler = SIG_IGN;
    if (sigaction(SIGTSTP, &sigtstp_action, &gInteractiveOldSigtstpAction) != 0) {
        interactiveRestoreSigintHandler();
        installed_sigint_handler = false;
        interactiveRestoreTerminal();
        if (out_editor_failed) {
            *out_editor_failed = true;
        }
        return NULL;
    }
    gInteractiveHasOldSigtstp = 1;

    size_t capacity = 128;
    char *buffer = (char *)malloc(capacity);
    if (!buffer) {
        if (installed_sigint_handler) {
            interactiveRestoreSigintHandler();
        }
        interactiveRestoreSigtstpHandler();
        interactiveRestoreTerminal();
        if (out_editor_failed) {
            *out_editor_failed = true;
        }
        return NULL;
    }
    buffer[0] = '\0';
    size_t length = 0;
    size_t displayed_length = 0;
    size_t displayed_prompt_lines = shellPromptLineBreakCount(prompt);
    size_t history_index = 0;
    size_t cursor = 0;
    char *scratch = NULL;
    interactiveUpdateScratch(&scratch, buffer, length);

    fputs(prompt, stdout);
    fflush(stdout);

    bool done = false;
    bool eof_requested = false;

    while (!done) {
        unsigned char ch = 0;
        ssize_t read_count = read(STDIN_FILENO, &ch, 1);
        if (read_count <= 0) {
            eof_requested = true;
            break;
        }

        if (ch == '\r' || ch == '\n') {
            fputc('\n', stdout);
            fflush(stdout);
            done = true;
            break;
        }

        if (ch == 4) { /* Ctrl-D */
            if (length == 0) {
                eof_requested = true;
                break;
            }
            continue;
        }

        if (ch == 3) { /* Ctrl-C */
            fputs("^C\n", stdout);
            fflush(stdout);
            length = 0;
            cursor = 0;
            buffer[0] = '\0';
            displayed_length = 0;
            displayed_prompt_lines = shellPromptLineBreakCount(prompt);
            history_index = 0;
            interactiveUpdateScratch(&scratch, buffer, length);
            fputs(prompt, stdout);
            fflush(stdout);
            continue;
        }

        if (ch == 26) { /* Ctrl-Z */
            fputc('\a', stdout);
            fflush(stdout);
            continue;
        }

        if (ch == 127 || ch == 8) { /* Backspace */
            if (cursor > 0) {
                memmove(buffer + cursor - 1, buffer + cursor, length - cursor + 1);
                cursor--;
                length--;
                redrawInteractiveLine(prompt,
                                      buffer,
                                      length,
                                      cursor,
                                      &displayed_length,
                                      &displayed_prompt_lines);
                history_index = 0;
                interactiveUpdateScratch(&scratch, buffer, length);
            } else {
                fputc('\a', stdout);
                fflush(stdout);
            }
            continue;
        }

        if (ch == 27) { /* Escape sequence */
            unsigned char seq[3];
            if (read(STDIN_FILENO, &seq[0], 1) <= 0) {
                continue;
            }
            if (seq[0] == '[') {
                if (read(STDIN_FILENO, &seq[1], 1) <= 0) {
                    continue;
                }
                if (seq[1] == 'A') { /* Up arrow */
                    size_t history_count = shellRuntimeHistoryCount();
                    if (history_index < history_count) {
                        if (history_index == 0) {
                            interactiveUpdateScratch(&scratch, buffer, length);
                        }
                        history_index++;
                        char *entry = NULL;
                        if (shellRuntimeHistoryGetEntry(history_index - 1, &entry)) {
                            size_t entry_len = strlen(entry);
                            if (entry_len + 1 > capacity) {
                                size_t new_capacity = entry_len + 1;
                                char *new_buffer = (char *)realloc(buffer, new_capacity);
                                if (!new_buffer) {
                                    free(entry);
                                    history_index--;
                                    fputc('\a', stdout);
                                    fflush(stdout);
                                    continue;
                                }
                                buffer = new_buffer;
                                capacity = new_capacity;
                            }
                            memcpy(buffer, entry, entry_len);
                            buffer[entry_len] = '\0';
                            length = entry_len;
                            cursor = length;
                            redrawInteractiveLine(prompt,
                                                  buffer,
                                                  length,
                                                  cursor,
                                                  &displayed_length,
                                                  &displayed_prompt_lines);
                        } else {
                            history_index--;
                            fputc('\a', stdout);
                            fflush(stdout);
                        }
                        free(entry);
                    } else {
                        fputc('\a', stdout);
                        fflush(stdout);
                    }
                    continue;
                } else if (seq[1] == 'B') { /* Down arrow */
                    if (history_index > 0) {
                        history_index--;
                        const char *replacement = "";
                        char *entry = NULL;
                        if (history_index > 0) {
                            if (shellRuntimeHistoryGetEntry(history_index - 1, &entry)) {
                                replacement = entry;
                            }
                        } else if (scratch) {
                            replacement = scratch;
                        }
                        size_t entry_len = strlen(replacement);
                        if (entry_len + 1 > capacity) {
                            size_t new_capacity = entry_len + 1;
                            char *new_buffer = (char *)realloc(buffer, new_capacity);
                            if (!new_buffer) {
                                free(entry);
                                fputc('\a', stdout);
                                fflush(stdout);
                                continue;
                            }
                            buffer = new_buffer;
                            capacity = new_capacity;
                        }
                        memcpy(buffer, replacement, entry_len);
                        buffer[entry_len] = '\0';
                        length = entry_len;
                        cursor = length;
                        redrawInteractiveLine(prompt,
                                              buffer,
                                              length,
                                              cursor,
                                              &displayed_length,
                                              &displayed_prompt_lines);
                        if (history_index == 0) {
                            interactiveUpdateScratch(&scratch, buffer, length);
                        }
                        free(entry);
                    }
                    continue;
                } else if (seq[1] == 'C') { /* Right arrow */
                    if (cursor < length) {
                        cursor++;
                        fputs("\033[C", stdout);
                        fflush(stdout);
                    } else {
                        fputc('\a', stdout);
                        fflush(stdout);
                    }
                    continue;
                } else if (seq[1] == 'D') { /* Left arrow */
                    if (cursor > 0) {
                        cursor--;
                        fputs("\033[D", stdout);
                        fflush(stdout);
                    } else {
                        fputc('\a', stdout);
                        fflush(stdout);
                    }
                    continue;
                } else if (seq[1] >= '0' && seq[1] <= '9') {
                    if (read(STDIN_FILENO, &seq[2], 1) <= 0) {
                        continue;
                    }
                    if (seq[1] == '3' && seq[2] == '~') { /* Delete */
                        if (cursor < length) {
                            memmove(buffer + cursor, buffer + cursor + 1, length - cursor);
                            length--;
                            redrawInteractiveLine(prompt,
                                                  buffer,
                                                  length,
                                                  cursor,
                                                  &displayed_length,
                                                  &displayed_prompt_lines);
                            history_index = 0;
                            interactiveUpdateScratch(&scratch, buffer, length);
                        } else {
                            fputc('\a', stdout);
                            fflush(stdout);
                        }
                        continue;
                    }
                }
            }
            continue;
        }

        if (ch == '\t') { /* Tab completion */
            if (!interactiveHandleTabCompletion(prompt,
                                                &buffer,
                                                &length,
                                                &cursor,
                                                &capacity,
                                                &displayed_length,
                                                &displayed_prompt_lines,
                                                &scratch)) {
                fputc('\a', stdout);
                fflush(stdout);
            } else {
                history_index = 0;
            }
            continue;
        }

        if (!isprint(ch)) {
            fputc('\a', stdout);
            fflush(stdout);
            continue;
        }

        if (length + 1 >= capacity) {
            size_t new_capacity = capacity * 2;
            if (new_capacity <= length + 1) {
                new_capacity = length + 2;
            }
            char *new_buffer = (char *)realloc(buffer, new_capacity);
            if (!new_buffer) {
                fputc('\a', stdout);
                fflush(stdout);
                continue;
            }
            buffer = new_buffer;
            capacity = new_capacity;
        }

        if (cursor < length) {
            memmove(buffer + cursor + 1, buffer + cursor, length - cursor);
        }
        buffer[cursor] = (char)ch;
        cursor++;
        length++;
        buffer[length] = '\0';
        redrawInteractiveLine(prompt,
                              buffer,
                              length,
                              cursor,
                              &displayed_length,
                              &displayed_prompt_lines);
        history_index = 0;
        interactiveUpdateScratch(&scratch, buffer, length);
    }

    if (installed_sigint_handler) {
        interactiveRestoreSigintHandler();
    }
    interactiveRestoreSigtstpHandler();
    interactiveRestoreTerminal();
    free(scratch);

    if (eof_requested && length == 0) {
        free(buffer);
        if (out_eof) {
            *out_eof = true;
        }
        return NULL;
    }

    if (!done) {
        free(buffer);
        if (out_editor_failed) {
            *out_editor_failed = true;
        }
        return NULL;
    }

    char *result = (char *)realloc(buffer, length + 1);
    if (!result) {
        result = buffer;
    }
    result[length] = '\0';
    return result;
}

static int runInteractiveSession(const ShellRunOptions *options) {
    ShellRunOptions exec_opts = *options;
    exec_opts.no_cache = 1;
    exec_opts.quiet = true;

    int last_status = shellRuntimeLastStatus();
    bool tty = isatty(STDIN_FILENO);

    while (true) {
        char *prompt_storage = shellResolveInteractivePrompt();
        const char *prompt = prompt_storage ? prompt_storage : "exsh$ ";
        char *line = NULL;
        bool interactive_eof = false;
        bool editor_failed = false;
        if (tty) {
            line = readInteractiveLine(prompt, &interactive_eof, &editor_failed);
            if (!line && editor_failed) {
                tty = false;
            }
            if (!line && interactive_eof) {
                fputc('\n', stdout);
                free(prompt_storage);
                break;
            }
        }
        size_t line_capacity = 0;
        ssize_t read = 0;
        if (!line) {
            if (isatty(STDIN_FILENO)) {
                fputs(prompt, stdout);
                fflush(stdout);
            }
            read = getline(&line, &line_capacity, stdin);
            if (read < 0) {
                free(line);
                if (isatty(STDIN_FILENO)) {
                    fputc('\n', stdout);
                }
                free(prompt_storage);
                break;
            }
        } else {
            read = (ssize_t)strlen(line);
        }
        free(prompt_storage);
        bool only_whitespace = true;
        for (ssize_t i = 0; i < read; ++i) {
            if (line[i] != ' ' && line[i] != '\t' && line[i] != '\n' && line[i] != '\r') {
                only_whitespace = false;
                break;
            }
        }
        if (only_whitespace) {
            free(line);
            continue;
        }

        char *expanded_line = NULL;
        bool used_history = false;
        char *history_error = NULL;
        if (!shellRuntimeExpandHistoryReference(line, &expanded_line, &used_history, &history_error)) {
            if (history_error) {
                fprintf(stderr, "exsh: %s: event not found\n", history_error);
                free(history_error);
            } else {
                fprintf(stderr, "exsh: history expansion failed\n");
            }
            free(line);
            continue;
        }
        if (used_history && isatty(STDIN_FILENO)) {
            printf("%s\n", expanded_line);
            fflush(stdout);
        }
        if (history_error) {
            free(history_error);
        }
        free(line);
        line = expanded_line;

        char *expanded_tilde = interactiveExpandTilde(line);
        if (!expanded_tilde) {
            fprintf(stderr, "exsh: failed to expand home directory\n");
            free(line);
            continue;
        }
        shellRuntimeRecordHistory(line);
        bool exit_requested = false;
        last_status = shellRunSource(expanded_tilde, "<stdin>", &exec_opts, &exit_requested);
        free(expanded_tilde);
        free(line);
        if (exit_requested) {
            break;
        }
    }

    return last_status;
}

int main(int argc, char **argv) {
    ShellRunOptions options = {0};
    options.frontend_path = (argc > 0) ? argv[0] : "exsh";
    shellRuntimeSetArg0(options.frontend_path);

    int dump_ext_builtins_flag = 0;
    const char *path = NULL;
    int arg_start_index = 0;

    for (int i = 1; i < argc; ++i) {
        if (strcmp(argv[i], "-v") == 0) {
            printf("Shell Frontend Version: %s (latest tag: %s)\n",
                   pscal_program_version_string(), pscal_git_tag_string());
            return vmExitWithCleanup(EXIT_SUCCESS);
        } else if (strcmp(argv[i], "--dump-ast-json") == 0) {
            options.dump_ast_json = 1;
        } else if (strcmp(argv[i], "--dump-bytecode") == 0) {
            options.dump_bytecode = 1;
        } else if (strcmp(argv[i], "--dump-bytecode-only") == 0) {
            options.dump_bytecode = 1;
            options.dump_bytecode_only = 1;
        } else if (strcmp(argv[i], "--dump-ext-builtins") == 0) {
            dump_ext_builtins_flag = 1;
        } else if (strcmp(argv[i], "--no-cache") == 0) {
            options.no_cache = 1;
        } else if (strncmp(argv[i], "--vm-trace-head=", 16) == 0) {
            options.vm_trace_head = atoi(argv[i] + 16);
        } else if (strcmp(argv[i], "-d") == 0) {
            options.verbose_errors = true;
        } else if (argv[i][0] == '-') {
            fprintf(stderr, "Unknown option: %s\n%s\n", argv[i], SHELL_USAGE);
            return EXIT_FAILURE;
        } else {
            path = argv[i];
            arg_start_index = i + 1;
            break;
        }
    }

    if (dump_ext_builtins_flag) {
        shellDumpBuiltins(stdout);
        return vmExitWithCleanup(EXIT_SUCCESS);
    }

    setenv("PSCALSHELL_LAST_STATUS", "0", 1);

    if (path) {
        char *src = shellLoadFile(path);
        if (!src) {
            return EXIT_FAILURE;
        }
        if (arg_start_index < argc) {
            gParamCount = argc - arg_start_index;
            gParamValues = &argv[arg_start_index];
        }
        shellRuntimeSetArg0(path);
        bool exit_requested = false;
        int status = shellRunSource(src, path, &options, &exit_requested);
        (void)exit_requested;
        free(src);
        shellRuntimeSetArg0(options.frontend_path);
        return vmExitWithCleanup(status);
    }

    gParamCount = 0;
    gParamValues = NULL;

    if (isatty(STDIN_FILENO)) {
        int status = runInteractiveSession(&options);
        return vmExitWithCleanup(status);
    }

    char *stdin_src = readStream(stdin);
    if (!stdin_src) {
        return EXIT_FAILURE;
    }

    ShellRunOptions stdin_opts = options;
    stdin_opts.no_cache = 1;
    stdin_opts.quiet = true;
    bool exit_requested = false;
    int status = shellRunSource(stdin_src, "<stdin>", &stdin_opts, &exit_requested);
    (void)exit_requested;
    free(stdin_src);
    return vmExitWithCleanup(status);
}
