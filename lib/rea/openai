module OpenAI {

    str hexDigits() {
        return "0123456789ABCDEF";
    }

    str charToString(char ch) {
        str result;
        setlength(result, 1);
        result[1] = ch;
        return result;
    }

    bool isHighSurrogate(int codePoint) {
        return codePoint >= 0xD800 && codePoint <= 0xDBFF;
    }

    bool isLowSurrogate(int codePoint) {
        return codePoint >= 0xDC00 && codePoint <= 0xDFFF;
    }

    int decodeSurrogatePair(int high, int low) {
        return 0x10000 + ((high - 0xD800) << 10) + (low - 0xDC00);
    }

    str encodeUtf8CodePoint(int codePoint) {
        int value = codePoint;
        if (value < 0 || value > 0x10FFFF) {
            value = 0xFFFD;
        }
        if (value <= 0x7F) {
            return charToString(tochar(value));
        }
        str result;
        if (value <= 0x7FF) {
            setlength(result, 2);
            result[1] = tochar(0xC0 | (value >> 6));
            result[2] = tochar(0x80 | (value & 0x3F));
            return result;
        }
        if (value <= 0xFFFF) {
            setlength(result, 3);
            result[1] = tochar(0xE0 | (value >> 12));
            result[2] = tochar(0x80 | ((value >> 6) & 0x3F));
            result[3] = tochar(0x80 | (value & 0x3F));
            return result;
        }
        setlength(result, 4);
        result[1] = tochar(0xF0 | (value >> 18));
        result[2] = tochar(0x80 | ((value >> 12) & 0x3F));
        result[3] = tochar(0x80 | ((value >> 6) & 0x3F));
        result[4] = tochar(0x80 | (value & 0x3F));
        return result;
    }

    int hexDigitValue(char ch) {
        if (ch >= '0' && ch <= '9') {
            return ord(ch) - ord('0');
        }
        if (ch >= 'A' && ch <= 'F') {
            return ord(ch) - ord('A') + 10;
        }
        if (ch >= 'a' && ch <= 'f') {
            return ord(ch) - ord('a') + 10;
        }
        return -1;
    }

    int parseHexAt(str text, int index) {
        int len = length(text);
        if (index + 3 > len) {
            return -1;
        }
        int value = 0;
        int i = 0;
        while (i < 4) {
            char ch = text[index + i];
            int digit = hexDigitValue(ch);
            if (digit < 0) {
                return -1;
            }
            value = (value << 4) + digit;
            i = i + 1;
        }
        return value;
    }

    str jsonEscape(str text) {
        int len = length(text);
        int i = 1;
        str result = "";
        while (i <= len) {
            char ch = text[i];
            int code = ord(ch);
            if (ch == '"') {
                result = result + "\\\"";
            } else if (ch == '\\') {
                result = result + "\\\\";
            } else if (code == 8) {
                result = result + "\\b";
            } else if (code == 9) {
                result = result + "\\t";
            } else if (code == 10) {
                result = result + "\\n";
            } else if (code == 12) {
                result = result + "\\f";
            } else if (code == 13) {
                result = result + "\\r";
            } else if (code < 32) {
                int high = ((code >> 4) & 15) + 1;
                int low = (code & 15) + 1;
                str digits = hexDigits();
                result = result + "\\u00" + charToString(digits[high]) +
                    charToString(digits[low]);
            } else {
                result = result + charToString(ch);
            }
            i = i + 1;
        }
        return result;
    }

    bool isWhitespace(char ch) {
        return ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r';
    }

    int skipWhitespace(str text, int index) {
        int len = length(text);
        while (index <= len) {
            if (!isWhitespace(text[index])) {
                break;
            }
            index = index + 1;
        }
        return index;
    }

    int findSubstring(str haystack, str needle, int startIndex) {
        int hayLen = length(haystack);
        int needleLen = length(needle);
        if (needleLen == 0) {
            return startIndex;
        }
        int limit = hayLen - needleLen + 1;
        int i = startIndex;
        while (i <= limit) {
            bool match = true;
            int j = 1;
            while (j <= needleLen) {
                if (haystack[i + j - 1] != needle[j]) {
                    match = false;
                    break;
                }
                j = j + 1;
            }
            if (match) {
                return i;
            }
            i = i + 1;
        }
        return 0;
    }

    str extractFirstContent(str response) {
        int len = length(response);
        int searchStart = 1;
        while (searchStart <= len) {
            int idx = findSubstring(response, "\"content\"", searchStart);
            if (idx <= 0) {
                break;
            }
            int cursor = idx + 9;
            cursor = skipWhitespace(response, cursor);
            if (cursor <= len && response[cursor] == ':') {
                cursor = cursor + 1;
                cursor = skipWhitespace(response, cursor);
                if (cursor <= len && response[cursor] == '"') {
                    cursor = cursor + 1;
                    str decoded = "";
                    bool ok = false;
                    int index = cursor;
                    while (index <= len) {
                        char ch = response[index];
                        if (ch == '"') {
                            ok = true;
                            index = index + 1;
                            break;
                        } else if (ch == '\\') {
                            index = index + 1;
                            if (index > len) {
                                break;
                            }
                            char esc = response[index];
                            if (esc == '"' || esc == '\\' || esc == '/') {
                                decoded = decoded + charToString(esc);
                            } else if (esc == 'b') {
                                decoded = decoded + tochar(8);
                            } else if (esc == 'f') {
                                decoded = decoded + tochar(12);
                            } else if (esc == 'n') {
                                decoded = decoded + "\n";
                            } else if (esc == 'r') {
                                decoded = decoded + "\r";
                            } else if (esc == 't') {
                                decoded = decoded + "\t";
                            } else if (esc == 'u') {
                                int code = parseHexAt(response, index + 1);
                                if (code < 0) {
                                    break;
                                }
                                index = index + 4;
                                if (isHighSurrogate(code)) {
                                    int pairStart = index + 1;
                                    if (pairStart + 5 <= len && response[pairStart] == '\\' &&
                                        response[pairStart + 1] == 'u') {
                                        int low = parseHexAt(response, pairStart + 2);
                                        if (isLowSurrogate(low)) {
                                            code = decodeSurrogatePair(code, low);
                                            index = pairStart + 5;
                                        } else {
                                            code = 0xFFFD;
                                        }
                                    } else {
                                        code = 0xFFFD;
                                    }
                                } else if (isLowSurrogate(code)) {
                                    code = 0xFFFD;
                                }
                                decoded = decoded + encodeUtf8CodePoint(code);
                            } else {
                                decoded = decoded + charToString(esc);
                            }
                        } else {
                            decoded = decoded + charToString(ch);
                        }
                        index = index + 1;
                    }
                    if (ok) {
                        return decoded;
                    }
                }
            }
            searchStart = idx + 8;
        }
        return response;
    }

    str composeMessages(str systemPrompt, str userPrompt) {
        str result = "[";
        if (length(systemPrompt) > 0) {
            result = result + "{\"role\":\"system\",\"content\":\"" +
                jsonEscape(systemPrompt) + "\"}";
            if (length(userPrompt) > 0) {
                result = result + ",";
            }
        }
        result = result + "{\"role\":\"user\",\"content\":\"" +
            jsonEscape(userPrompt) + "\"}]";
        return result;
    }

    export str chatRaw(str model, str messagesJson) {
        return OpenAIChatCompletions(model, messagesJson);
    }

    export str chatCustom(str model, str messagesJson, str optionsJson,
                          str apiKey, str baseUrl) {
        return OpenAIChatCompletions(model, messagesJson, optionsJson, apiKey, baseUrl);
    }

    export str chatWithOptions(str model, str systemPrompt, str userPrompt,
                               str optionsJson, str apiKey, str baseUrl) {
        str messages = composeMessages(systemPrompt, userPrompt);
        str response = OpenAIChatCompletions(model, messages, optionsJson, apiKey, baseUrl);
        return extractFirstContent(response);
    }

    export str chatWithSystem(str model, str systemPrompt, str userPrompt) {
        return chatWithOptions(model, systemPrompt, userPrompt, "", "", "");
    }

    export str chat(str model, str userPrompt) {
        return chatWithSystem(model, "", userPrompt);
    }
}
