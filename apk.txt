Summary
PSCAL already builds cleanly with CMake and has install rules for its binaries and shell completions, so packaging for Alpine mainly involves wrapping the existing build/install flow inside abuild and copying the runtime assets the upstream install.sh script normally lays out.

The project’s runtime relies on libcurl at a minimum, with SDL/SQLite/other extensions gated behind CMake options you can toggle from the APKBUILD.

Creating an Alpine apk
Prepare your packaging workspace

Set up the standard abuild tree (e.g., ~/aports/community/pscal) and initialize your signing key if you haven’t already (abuild-keygen -a).

Install the toolchain and headers you’ll need at build time: build-base, cmake, curl-dev, and optionally sqlite-dev, sdl2-dev, sdl2_image-dev, sdl2_mixer-dev, and sdl2_ttf-dev if you plan to enable the corresponding CMake flags.

Author APKBUILD

Set pkgname=pscal, point source at either a release tarball or a git commit snapshot, and declare:

makedepends="cmake curl-dev ..." (add SDL/SQLite packages when enabling those knobs).

depends="curl" for runtime (again, append SDL/SQLite libs if you enable them).

In build(), call:

cmake -B build -S "$srcdir"/pscal \
  -DCMAKE_BUILD_TYPE=RelWithDebInfo \
  -DCMAKE_INSTALL_PREFIX=/usr \
  -DSDL=OFF \
  -DENABLE_EXT_BUILTIN_SQLITE=OFF
cmake --build build
Flip -DSDL/-DENABLE_EXT_BUILTIN_* as desired for the feature set you intend to ship; binaries land in build/bin by default when you need to inspect them during packaging.

Optional check() phase: if you can afford the time and have the needed dependencies, run ctest --output-on-failure --test-dir build; otherwise declare options="!check".

Package installation layout

In package(), perform the staged install and then add the runtime assets:

DESTDIR="$pkgdir" cmake --install build
install -Dm644 README.md "$pkgdir"/usr/share/doc/pscal/README.md
cp -a lib fonts etc Tests/libs "$pkgdir"/usr/share/pscal/
The upstream install.sh copies lib/, fonts/, etc/, and Tests/libs/ into the installation prefix and creates compatibility links, so mirror that structure under /usr/share/pscal (or another conventional data dir) and add symlinks such as /usr/share/pscal/pascal/lib → /usr/share/pscal/lib/pascal if you want to preserve the legacy layout.

The CMake install target already places pascal, pscalvm, optional dascal/pscald, the pscaljson2bc utility, and shell completion files into the correct GNU install dirs, so no extra work is needed there beyond the cmake --install call.

Split out docs or examples into subpackages if you follow Alpine conventions (e.g., subpackages="$pkgname-doc").

Build the package

Run abuild checksum after updating source, then abuild -r to build and sign the package inside a clean chroot.

Test-install the resulting .apk with doas apk add --allow-untrusted /path/to/pscal-*.apk and verify the CLI front ends can locate their assets under /usr/share/pscal.
